<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>XMC Peripheral Library for XMC1000 Family: SCU</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="IFX_LOGO_4C_medium.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">XMC Peripheral Library for XMC1000 Family
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">SCU<div class="ingroups"><a class="el" href="group___x_m_clib.html">XMC Peripheral Library</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___s_c_u___c_l_o_c_k___c_o_n_f_i_g__t.html">XMC_SCU_CLOCK_CONFIG_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___s_c_u___c_l_o_c_k___d_e_e_p___s_l_e_e_p__t.html">XMC_SCU_CLOCK_DEEP_SLEEP_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___s_c_u___s_u_p_p_l_y_m_o_n_i_t_o_r__t.html">XMC_SCU_SUPPLYMONITOR_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga87cf336cf51860955435acebcacb704c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga87cf336cf51860955435acebcacb704c">XMC_SCU_MAJOR_VERSION</a>&#160;&#160;&#160;(1U)</td></tr>
<tr class="separator:ga87cf336cf51860955435acebcacb704c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdd702a84c73c50d01294e2bf761b2f0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gacdd702a84c73c50d01294e2bf761b2f0">XMC_SCU_MINOR_VERSION</a>&#160;&#160;&#160;(0U)</td></tr>
<tr class="separator:gacdd702a84c73c50d01294e2bf761b2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae4d75cdeae18f943f60f45d13759690"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gaae4d75cdeae18f943f60f45d13759690">XMC_SCU_PATCH_VERSION</a>&#160;&#160;&#160;(2U)</td></tr>
<tr class="separator:gaae4d75cdeae18f943f60f45d13759690"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga4b50170c441fb21833c07a27b814a581"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga4b50170c441fb21833c07a27b814a581">XMC_SCU_INTERRUPT_EVENT_HANDLER_t</a>) (void)</td></tr>
<tr class="separator:ga4b50170c441fb21833c07a27b814a581"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga51850699f03c906a5fefcc4f04c6b2c1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga51850699f03c906a5fefcc4f04c6b2c1">XMC_SCU_CCU_TRIGGER_t</a> { <br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga51850699f03c906a5fefcc4f04c6b2c1ab9e67fe77a9a1219bd0d4594c3f7a0ea">XMC_SCU_CCU_TRIGGER_CCU40</a> = SCU_GENERAL_CCUCON_GSC40_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga51850699f03c906a5fefcc4f04c6b2c1ae5aa55222489a096c454eb0ce95e1bf2">XMC_SCU_CCU_TRIGGER_CCU80</a> = SCU_GENERAL_CCUCON_GSC80_Msk
<br />
 }</td></tr>
<tr class="separator:ga51850699f03c906a5fefcc4f04c6b2c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4ef17eaabe7b13c5c159ba6b24c6a2c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gad4ef17eaabe7b13c5c159ba6b24c6a2c">XMC_SCU_CLOCK_PCLKSRC_t</a> { <br />
&#160;&#160;<a class="el" href="group___s_c_u.html#ggad4ef17eaabe7b13c5c159ba6b24c6a2ca68981ef360c0c5bd355918858a72c3f3">XMC_SCU_CLOCK_PCLKSRC_MCLK</a> = (0UL &lt;&lt; SCU_CLK_CLKCR_PCLKSEL_Pos), 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#ggad4ef17eaabe7b13c5c159ba6b24c6a2cac5e87eeb279a280a096fccee739e1cc1">XMC_SCU_CLOCK_PCLKSRC_DOUBLE_MCLK</a> = (1UL &lt;&lt; SCU_CLK_CLKCR_PCLKSEL_Pos)
<br />
 }</td></tr>
<tr class="separator:gad4ef17eaabe7b13c5c159ba6b24c6a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cf5c338f64adfc26ef8c49e826cd752"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga6cf5c338f64adfc26ef8c49e826cd752">XMC_SCU_CLOCK_RTCCLKSRC_t</a> { <br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga6cf5c338f64adfc26ef8c49e826cd752a53e45cffbefd82a99a6b3823ac158007">XMC_SCU_CLOCK_RTCCLKSRC_DCO2</a> = (0x0UL &lt;&lt; SCU_CLK_CLKCR_RTCCLKSEL_Pos), 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga6cf5c338f64adfc26ef8c49e826cd752a73ebf57da51c953f94ac117429da1728">XMC_SCU_CLOCK_RTCCLKSRC_ERU_IOUT0</a> = (0x1UL &lt;&lt; SCU_CLK_CLKCR_RTCCLKSEL_Pos), 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga6cf5c338f64adfc26ef8c49e826cd752a41b802a680db96bfed5bb865e665101b">XMC_SCU_CLOCK_RTCCLKSRC_ACMP0_OUT</a> = (0x2UL &lt;&lt; SCU_CLK_CLKCR_RTCCLKSEL_Pos), 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga6cf5c338f64adfc26ef8c49e826cd752a1c9bca4660e4084fe22e2b5f8025ccf5">XMC_SCU_CLOCK_RTCCLKSRC_ACMP1_OUT</a> = (0x3UL &lt;&lt; SCU_CLK_CLKCR_RTCCLKSEL_Pos), 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga6cf5c338f64adfc26ef8c49e826cd752a2fe29d440be9a7d055d919a602ed86c8">XMC_SCU_CLOCK_RTCCLKSRC_ACMP2_OUT</a> = (0x4UL &lt;&lt; SCU_CLK_CLKCR_RTCCLKSEL_Pos)
<br />
 }</td></tr>
<tr class="separator:ga6cf5c338f64adfc26ef8c49e826cd752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03e9302206c9d6eef0c1002f39f12faf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga03e9302206c9d6eef0c1002f39f12faf">XMC_SCU_INTERRUPT_EVENT_t</a> { <br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga03e9302206c9d6eef0c1002f39f12fafab49e4cfec05bd67841c9083334f6873b">XMC_SCU_INTERRUPT_EVENT_WDT_WARN</a> = SCU_INTERRUPT_SRMSK_PRWARN_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga03e9302206c9d6eef0c1002f39f12fafa6e4f042e507ac6856f1e36768a978c3b">XMC_SCU_INTERRUPT_EVENT_RTC_PERIODIC</a> = SCU_INTERRUPT_SRCLR_PI_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga03e9302206c9d6eef0c1002f39f12fafae112208768ed97572e5804e0826707bd">XMC_SCU_INTERRUPT_EVENT_RTC_ALARM</a> = SCU_INTERRUPT_SRCLR_AI_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga03e9302206c9d6eef0c1002f39f12fafa36be7a15b49011db6b22f9b4fb63794e">XMC_SCU_INTERRUPT_EVENT_VDDPI</a> = SCU_INTERRUPT_SRMSK_VDDPI_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga03e9302206c9d6eef0c1002f39f12fafa2ae9830cbb1db5218af7bcb781f5dae5">XMC_SCU_INTERRUPT_EVENT_ACMP0</a> = SCU_INTERRUPT_SRMSK_ACMP0I_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga03e9302206c9d6eef0c1002f39f12fafaf515ba586422108d444e680d5ec91206">XMC_SCU_INTERRUPT_EVENT_ACMP1</a> = SCU_INTERRUPT_SRMSK_ACMP1I_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga03e9302206c9d6eef0c1002f39f12fafa9f7562edaccc7d6f3396d41c7ba8fc14">XMC_SCU_INTERRUPT_EVENT_ACMP2</a> = SCU_INTERRUPT_SRMSK_ACMP2I_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga03e9302206c9d6eef0c1002f39f12fafa8b8d4ea9329a46658590e426f3f47583">XMC_SCU_INTERRUPT_EVENT_VDROP</a> = SCU_INTERRUPT_SRMSK_VDROPI_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga03e9302206c9d6eef0c1002f39f12fafa8a662e56d91004fb969dff632cd67f3f">XMC_SCU_INTERRUPT_EVENT_ORC0</a> = SCU_INTERRUPT_SRMSK_ORC0I_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga03e9302206c9d6eef0c1002f39f12fafa1b0b35f9b1ff46b07c48ac9274e5ffef">XMC_SCU_INTERRUPT_EVENT_ORC1</a> = SCU_INTERRUPT_SRMSK_ORC1I_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga03e9302206c9d6eef0c1002f39f12fafaaec278b2db003ceb5e83622ad07b6bba">XMC_SCU_INTERRUPT_EVENT_ORC2</a> = SCU_INTERRUPT_SRMSK_ORC2I_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga03e9302206c9d6eef0c1002f39f12fafa79e531670b77b2bae7845a55a11b0ca3">XMC_SCU_INTERRUPT_EVENT_ORC3</a> = SCU_INTERRUPT_SRMSK_ORC3I_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga03e9302206c9d6eef0c1002f39f12fafa63c1cd122d983e237fa6266edd122b21">XMC_SCU_INTERRUPT_EVENT_ORC4</a> = SCU_INTERRUPT_SRMSK_ORC4I_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga03e9302206c9d6eef0c1002f39f12fafae9d442589f144d49707ac629a76146a8">XMC_SCU_INTERRUPT_EVENT_ORC5</a> = SCU_INTERRUPT_SRMSK_ORC5I_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga03e9302206c9d6eef0c1002f39f12fafa43d075a0b8f88ca6abb1a10c7a15d404">XMC_SCU_INTERRUPT_EVENT_ORC6</a> = SCU_INTERRUPT_SRMSK_ORC6I_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga03e9302206c9d6eef0c1002f39f12fafa0e1b8e66ed9421a136c7bfebf3c3f04b">XMC_SCU_INTERRUPT_EVENT_ORC7</a> = SCU_INTERRUPT_SRMSK_ORC7I_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga03e9302206c9d6eef0c1002f39f12fafac8f3e1ab42ded809ccc2d8460769e930">XMC_SCU_INTERRUPT_EVENT_LOCI</a> = SCU_INTERRUPT_SRMSK_LOCI_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga03e9302206c9d6eef0c1002f39f12fafa3fd4e102d2041791cb21d2931521103e">XMC_SCU_INTERRUPT_EVENT_PESRAM</a> = SCU_INTERRUPT_SRMSK_PESRAMI_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga03e9302206c9d6eef0c1002f39f12fafadf68182bcd64a2141b20f04d8be2d5b1">XMC_SCU_INTERRUPT_EVENT_PUSIC</a> = SCU_INTERRUPT_SRMSK_PEU0I_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga03e9302206c9d6eef0c1002f39f12fafacb7fdee91cedc2ad4f8187bb894ee8c2">XMC_SCU_INTERRUPT_EVENT_FLASH_ERROR</a> = SCU_INTERRUPT_SRMSK_FLECC2I_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga03e9302206c9d6eef0c1002f39f12fafa41347d9c5d33b0e27163b5c5dc461b13">XMC_SCU_INTERRUPT_EVENT_FLASH_COMPLETED</a> = SCU_INTERRUPT_SRCLR_FLCMPLTI_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga03e9302206c9d6eef0c1002f39f12fafa4c51bacdb7b51e920e67fbed636bd063">XMC_SCU_INTERRUPT_EVENT_VCLIP</a> = SCU_INTERRUPT_SRMSK_VCLIPI_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga03e9302206c9d6eef0c1002f39f12fafa3b5def96ebde8b8a3f2e8c8c208f86ad">XMC_SCU_INTERRUPT_EVENT_STDBYCLKFAIL</a> = SCU_INTERRUPT_SRMSK_SBYCLKFI_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga03e9302206c9d6eef0c1002f39f12fafaf6a54c2ca347337984a5fa9555e1cb3c">XMC_SCU_INTERRUPT_EVENT_RTCCTR_UPDATED</a> = SCU_INTERRUPT_SRMSK_RTC_CTR_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga03e9302206c9d6eef0c1002f39f12fafafeeeb43ec31dd9576349de17fd81acfa">XMC_SCU_INTERRUPT_EVENT_RTCATIM0_UPDATED</a> = SCU_INTERRUPT_SRMSK_RTC_ATIM0_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga03e9302206c9d6eef0c1002f39f12fafadf611625f44d6a95a62ddcf0bc7ccfdf">XMC_SCU_INTERRUPT_EVENT_RTCATIM1_UPDATED</a> = SCU_INTERRUPT_SRMSK_RTC_ATIM1_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga03e9302206c9d6eef0c1002f39f12fafa3ca830417c184f558a9f01187052414d">XMC_SCU_INTERRUPT_EVENT_RTCTIM0_UPDATED</a> = SCU_INTERRUPT_SRMSK_RTC_TIM0_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga03e9302206c9d6eef0c1002f39f12fafa858993fe3ea2c5bdc861ef643ef9ad4f">XMC_SCU_INTERRUPT_EVENT_RTCTIM1_UPDATED</a> = SCU_INTERRUPT_SRMSK_RTC_TIM1_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga03e9302206c9d6eef0c1002f39f12fafaabbc68752cfef4087aac834074a8b5bf">XMC_SCU_INTERRUPT_EVENT_TSE_DONE</a> = SCU_INTERRUPT_SRMSK_TSE_DONE_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga03e9302206c9d6eef0c1002f39f12fafa461c6d77f2bf6560cd051bffa271fc07">XMC_SCU_INTERRUPT_EVENT_TSE_HIGH</a> = SCU_INTERRUPT_SRMSK_TSE_HIGH_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga03e9302206c9d6eef0c1002f39f12fafae7ecc9a9cf091592eecf694d80920085">XMC_SCU_INTERRUPT_EVENT_TSE_LOW</a> = (int32_t)SCU_INTERRUPT_SRMSK_TSE_LOW_Msk
<br />
 }</td></tr>
<tr class="separator:ga03e9302206c9d6eef0c1002f39f12faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29713150fdafc3c88f3c73f621410239"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga29713150fdafc3c88f3c73f621410239">XMC_SCU_PERIPHERAL_CLOCK_t</a> { <br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga29713150fdafc3c88f3c73f621410239a52c9f76dec72eff13f90cdc046d47401">XMC_SCU_PERIPHERAL_CLOCK_VADC</a> = SCU_CLK_CGATSTAT0_VADC_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga29713150fdafc3c88f3c73f621410239a0bb88ac36dfd3545282123f56c5c2374">XMC_SCU_PERIPHERAL_CLOCK_CCU80</a> = SCU_CLK_CGATSTAT0_CCU80_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga29713150fdafc3c88f3c73f621410239a346af75d76735810851f4175e0aa7510">XMC_SCU_PERIPHERAL_CLOCK_CCU40</a> = SCU_CLK_CGATSTAT0_CCU40_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga29713150fdafc3c88f3c73f621410239a3b7bdfee77b9c35016b8c8367fa19cc2">XMC_SCU_PERIPHERAL_CLOCK_USIC0</a> = SCU_CLK_CGATSTAT0_USIC0_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga29713150fdafc3c88f3c73f621410239ad9f67751fcf7facbbf4cd2a5b36e38f0">XMC_SCU_PERIPHERAL_CLOCK_BCCU0</a> = SCU_CLK_CGATSTAT0_BCCU0_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga29713150fdafc3c88f3c73f621410239a2cdc8717b252a95151639d5f95c5d0a2">XMC_SCU_PERIPHERAL_CLOCK_LEDTS0</a> = SCU_CLK_CGATSTAT0_LEDTS0_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga29713150fdafc3c88f3c73f621410239a9979deef2f645ef5335292f656b301b8">XMC_SCU_PERIPHERAL_CLOCK_LEDTS1</a> = SCU_CLK_CGATSTAT0_LEDTS1_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga29713150fdafc3c88f3c73f621410239a7d81755a02791cef84e36351a4e21ca5">XMC_SCU_PERIPHERAL_CLOCK_POSIF0</a> = SCU_CLK_CGATSTAT0_POSIF0_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga29713150fdafc3c88f3c73f621410239abd383e07c1966b805eabc208362baefd">XMC_SCU_PERIPHERAL_CLOCK_MATH</a> = SCU_CLK_CGATSTAT0_MATH_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga29713150fdafc3c88f3c73f621410239a94022ad63fa2dbbbf514709a230956ea">XMC_SCU_PERIPHERAL_CLOCK_WDT</a> = SCU_CLK_CGATSTAT0_WDT_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga29713150fdafc3c88f3c73f621410239a274fa98fa526d3ea003785ecbcba9e36">XMC_SCU_PERIPHERAL_CLOCK_RTC</a> = SCU_CLK_CGATSTAT0_RTC_Msk
<br />
 }</td></tr>
<tr class="separator:ga29713150fdafc3c88f3c73f621410239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae01c08f5d524dadbc6e0c4128b348dc3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gae01c08f5d524dadbc6e0c4128b348dc3">XMC_SCU_RESET_REASON_t</a> { <br />
&#160;&#160;<a class="el" href="group___s_c_u.html#ggae01c08f5d524dadbc6e0c4128b348dc3ae8bea77e364f87d9c74afb215da65273">XMC_SCU_RESET_REASON_PORST</a> = (1UL &lt;&lt; SCU_RESET_RSTSTAT_RSTSTAT_Pos), 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#ggae01c08f5d524dadbc6e0c4128b348dc3a1742c1894d91860d7541385f3f0c4fe1">XMC_SCU_RESET_REASON_MASTER</a> = (2UL &lt;&lt; SCU_RESET_RSTSTAT_RSTSTAT_Pos), 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#ggae01c08f5d524dadbc6e0c4128b348dc3aa6d2a43d58beebfabf3897c2ed65bd03">XMC_SCU_RESET_REASON_SW</a> = (4UL &lt;&lt; SCU_RESET_RSTSTAT_RSTSTAT_Pos), 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#ggae01c08f5d524dadbc6e0c4128b348dc3aa147b82fa48ea09fe9137601ce28b6c9">XMC_SCU_RESET_REASON_LOCKUP</a> = (8UL &lt;&lt; SCU_RESET_RSTSTAT_RSTSTAT_Pos), 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#ggae01c08f5d524dadbc6e0c4128b348dc3a5b52d4b8f8aa89a37e05e865ffaef900">XMC_SCU_RESET_REASON_FLASH</a> = (16UL &lt;&lt; SCU_RESET_RSTSTAT_RSTSTAT_Pos), 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#ggae01c08f5d524dadbc6e0c4128b348dc3acd2ed3c6d9ade72259637c7c80a840cb">XMC_SCU_RESET_REASON_WATCHDOG</a> = (32UL &lt;&lt; SCU_RESET_RSTSTAT_RSTSTAT_Pos), 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#ggae01c08f5d524dadbc6e0c4128b348dc3a0e3a7d9ed387fd8d11576c4f63d61cb2">XMC_SCU_RESET_REASON_CLOCK_LOSS</a> = (64UL &lt;&lt; SCU_RESET_RSTSTAT_RSTSTAT_Pos), 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#ggae01c08f5d524dadbc6e0c4128b348dc3a9d34595d39facbd7b114462d5cc5b0c8">XMC_SCU_RESET_REASON_PARITY_ERROR</a> = (128UL &lt;&lt; SCU_RESET_RSTSTAT_RSTSTAT_Pos)
<br />
 }</td></tr>
<tr class="separator:gae01c08f5d524dadbc6e0c4128b348dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga236deb68e8388f2f1283e5573e76d7a7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga236deb68e8388f2f1283e5573e76d7a7">XMC_SCU_SLEEP_CLK_INSTR_t</a> { <br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga236deb68e8388f2f1283e5573e76d7a7a5e86ca5bf880797effdf66301de95af5">XMC_SCU_SLEEP_CLK_INSTR_ENTER</a> = 0UL, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga236deb68e8388f2f1283e5573e76d7a7a93cc1a7893d01dabed8f6d09f7b3e460">XMC_SCU_SLEEP_CLK_INSTR_EXIT</a>
<br />
 }</td></tr>
<tr class="separator:ga236deb68e8388f2f1283e5573e76d7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff029b1575acc0712d494932d8ca6d60"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gaff029b1575acc0712d494932d8ca6d60">XMC_SCU_STATUS_t</a> { <br />
&#160;&#160;<a class="el" href="group___s_c_u.html#ggaff029b1575acc0712d494932d8ca6d60a764eaaa84d169b3222ae9174d1fa6855">XMC_SCU_STATUS_OK</a> = 0UL, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#ggaff029b1575acc0712d494932d8ca6d60a6f6a43bd2a61be2a1b0b57601d58bd77">XMC_SCU_STATUS_BUSY</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#ggaff029b1575acc0712d494932d8ca6d60aaf8f778e9be5e754dcaa0c1cf83e1e4b">XMC_SCU_STATUS_ERROR</a>
<br />
 }</td></tr>
<tr class="separator:gaff029b1575acc0712d494932d8ca6d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4988413b7da85ed020b8d1a8243e28aa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga4988413b7da85ed020b8d1a8243e28aa">XMC_SCU_SYSTEM_RESET_REQUEST_t</a> { <br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga4988413b7da85ed020b8d1a8243e28aaa97383dd0b2c36dbb082441a879289a0d">XMC_SCU_RESET_REQUEST_FLASH_ECC_ERROR</a> = SCU_RESET_RSTCON_ECCRSTEN_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga4988413b7da85ed020b8d1a8243e28aaa4e8060a113c0650c5c1ef3f200ce4e39">XMC_SCU_RESET_REQUEST_CLOCK_LOSS</a> = SCU_RESET_RSTCON_LOCRSTEN_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga4988413b7da85ed020b8d1a8243e28aaaa2c6d4ddc9c83f71bf47d2b39ef25e83">XMC_SCU_RESET_REQUEST_SRAM_PARITY_ERROR</a> = SCU_RESET_RSTCON_SPERSTEN_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_c_u.html#gga4988413b7da85ed020b8d1a8243e28aaa50dee8709c1bc2b69bcf3e90ca52ce90">XMC_SCU_RESET_REQUEST_USIC_SRAM_PARITY_ERROR</a> = SCU_RESET_RSTCON_U0PERSTEN_Msk
<br />
 }</td></tr>
<tr class="separator:ga4988413b7da85ed020b8d1a8243e28aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab0af70f90b9a1f24d3a0a4764543d833"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gab0af70f90b9a1f24d3a0a4764543d833">XMC_SCU_CLOCK_GatePeripheralClock</a> (const <a class="el" href="group___s_c_u.html#ga29713150fdafc3c88f3c73f621410239">XMC_SCU_PERIPHERAL_CLOCK_t</a> peripheral)</td></tr>
<tr class="separator:gab0af70f90b9a1f24d3a0a4764543d833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e78410c4d0c9f9b54aa0965d16c3795"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga3e78410c4d0c9f9b54aa0965d16c3795">XMC_SCU_CLOCK_GetCpuClockFrequency</a> (void)</td></tr>
<tr class="separator:ga3e78410c4d0c9f9b54aa0965d16c3795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4269bd27311f46c895b7ca474236d71c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga4269bd27311f46c895b7ca474236d71c">XMC_SCU_CLOCK_GetFastPeripheralClockFrequency</a> (void)</td></tr>
<tr class="separator:ga4269bd27311f46c895b7ca474236d71c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55a1be4f0e96fcda7b2c0feb542af250"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga55a1be4f0e96fcda7b2c0feb542af250">XMC_SCU_CLOCK_GetPeripheralClockFrequency</a> (void)</td></tr>
<tr class="separator:ga55a1be4f0e96fcda7b2c0feb542af250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08c337e8a728604e7eb54dff78ae2d9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga08c337e8a728604e7eb54dff78ae2d9d">XMC_SCU_CLOCK_Init</a> (const <a class="el" href="struct_x_m_c___s_c_u___c_l_o_c_k___c_o_n_f_i_g__t.html">XMC_SCU_CLOCK_CONFIG_t</a> *const config)</td></tr>
<tr class="separator:ga08c337e8a728604e7eb54dff78ae2d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga804f98badedf0e0ba4ce09f445687a37"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga804f98badedf0e0ba4ce09f445687a37">XMC_SCU_CLOCK_IsPeripheralClockGated</a> (const <a class="el" href="group___s_c_u.html#ga29713150fdafc3c88f3c73f621410239">XMC_SCU_PERIPHERAL_CLOCK_t</a> peripheral)</td></tr>
<tr class="separator:ga804f98badedf0e0ba4ce09f445687a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6103bc92c9cd326903ee4e6b2e1d055d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga6103bc92c9cd326903ee4e6b2e1d055d">XMC_SCU_CLOCK_SetFastPeripheralClockSource</a> (const <a class="el" href="group___s_c_u.html#gad4ef17eaabe7b13c5c159ba6b24c6a2c">XMC_SCU_CLOCK_PCLKSRC_t</a> source)</td></tr>
<tr class="separator:ga6103bc92c9cd326903ee4e6b2e1d055d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga702904d10b6e6c6a55db381763fd322f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga702904d10b6e6c6a55db381763fd322f">XMC_SCU_CLOCK_UngatePeripheralClock</a> (const <a class="el" href="group___s_c_u.html#ga29713150fdafc3c88f3c73f621410239">XMC_SCU_PERIPHERAL_CLOCK_t</a> peripheral)</td></tr>
<tr class="separator:ga702904d10b6e6c6a55db381763fd322f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f5fc5dbf267604cb41063d9a3c028e4"><td class="memItemLeft" align="right" valign="top">XMC_DRIVER_VERSION_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga5f5fc5dbf267604cb41063d9a3c028e4">XMC_SCU_GetDriverVersion</a> (void)</td></tr>
<tr class="separator:ga5f5fc5dbf267604cb41063d9a3c028e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga494b75a841498374cfee9664e6ce9cee"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga494b75a841498374cfee9664e6ce9cee">XMC_SCU_GetMirrorStatus</a> (void)</td></tr>
<tr class="separator:ga494b75a841498374cfee9664e6ce9cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71c4f02eb6036f0d3a13af5e10bf56cc"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga71c4f02eb6036f0d3a13af5e10bf56cc">XMC_SCU_GetTemperature</a> (void)</td></tr>
<tr class="separator:ga71c4f02eb6036f0d3a13af5e10bf56cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a0ad9c467d9549542d0f0275bae6314"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga5a0ad9c467d9549542d0f0275bae6314">XMC_SCU_HighTemperature</a> (void)</td></tr>
<tr class="separator:ga5a0ad9c467d9549542d0f0275bae6314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bd0ece17f08fdd68d1e2ebda723b25e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga6bd0ece17f08fdd68d1e2ebda723b25e">XMC_SCU_INTERRUPT_ClearEventStatus</a> (const uint32_t event)</td></tr>
<tr class="separator:ga6bd0ece17f08fdd68d1e2ebda723b25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5db18b53ccbc47c21b8af53e6998120"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gad5db18b53ccbc47c21b8af53e6998120">XMC_SCU_INTERRUPT_DisableEvent</a> (const uint32_t event)</td></tr>
<tr class="separator:gad5db18b53ccbc47c21b8af53e6998120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf151dd6fcd9b87597df94d9c1f91459e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gaf151dd6fcd9b87597df94d9c1f91459e">XMC_SCU_INTERRUPT_EnableEvent</a> (const uint32_t event)</td></tr>
<tr class="separator:gaf151dd6fcd9b87597df94d9c1f91459e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ae03c6bcc3ccade266b46d84f7715e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___s_c_u.html#gaff029b1575acc0712d494932d8ca6d60">XMC_SCU_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga4ae03c6bcc3ccade266b46d84f7715e6">XMC_SCU_INTERRUPT_SetEventHandler</a> (const <a class="el" href="group___s_c_u.html#ga03e9302206c9d6eef0c1002f39f12faf">XMC_SCU_INTERRUPT_EVENT_t</a> event, const <a class="el" href="group___s_c_u.html#ga4b50170c441fb21833c07a27b814a581">XMC_SCU_INTERRUPT_EVENT_HANDLER_t</a> handler)</td></tr>
<tr class="separator:ga4ae03c6bcc3ccade266b46d84f7715e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62abdedd61269613d36968eb15627073"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga62abdedd61269613d36968eb15627073">XMC_SCU_INTERRUPT_TriggerEvent</a> (const uint32_t event)</td></tr>
<tr class="separator:ga62abdedd61269613d36968eb15627073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24e6e575b87666b99a59f4e992d5471a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga24e6e575b87666b99a59f4e992d5471a">XMC_SCU_INTERUPT_GetEventStatus</a> (void)</td></tr>
<tr class="separator:ga24e6e575b87666b99a59f4e992d5471a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ba1ce317ce89edfea107893fbd8a0be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga9ba1ce317ce89edfea107893fbd8a0be">XMC_SCU_IRQHandler</a> (uint32_t sr_num)</td></tr>
<tr class="separator:ga9ba1ce317ce89edfea107893fbd8a0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9ba5dce219ea8390f4aa9f7bc46aafe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gad9ba5dce219ea8390f4aa9f7bc46aafe">XMC_SCU_LockProtectedBits</a> (void)</td></tr>
<tr class="separator:gad9ba5dce219ea8390f4aa9f7bc46aafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8573534003ebf11fbaa49e331238fb86"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga8573534003ebf11fbaa49e331238fb86">XMC_SCU_LowTemperature</a> (void)</td></tr>
<tr class="separator:ga8573534003ebf11fbaa49e331238fb86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77c6ab2add788e4bd31eb563e0f8f8b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga77c6ab2add788e4bd31eb563e0f8f8b1">XMC_SCU_RESET_AssertMasterReset</a> (void)</td></tr>
<tr class="separator:ga77c6ab2add788e4bd31eb563e0f8f8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bf9396e8b46be98f73999575d13bf6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga4bf9396e8b46be98f73999575d13bf6d">XMC_SCU_RESET_ClearDeviceResetReason</a> (void)</td></tr>
<tr class="separator:ga4bf9396e8b46be98f73999575d13bf6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4dbbfd3a9346cc7eb84bda46d084607"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gaa4dbbfd3a9346cc7eb84bda46d084607">XMC_SCU_RESET_EnableResetRequest</a> (uint32_t request)</td></tr>
<tr class="separator:gaa4dbbfd3a9346cc7eb84bda46d084607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f779c81bdc29b44c644017a52aff300"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga3f779c81bdc29b44c644017a52aff300">XMC_SCU_RESET_GetDeviceResetReason</a> (void)</td></tr>
<tr class="separator:ga3f779c81bdc29b44c644017a52aff300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac10ca2cd72477476ffe38a4818bcae4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gac10ca2cd72477476ffe38a4818bcae4b">XMC_SCU_SetCcuTriggerHigh</a> (const uint32_t trigger)</td></tr>
<tr class="separator:gac10ca2cd72477476ffe38a4818bcae4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53300d587bbd03bc34c5a4396f5a34b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga53300d587bbd03bc34c5a4396f5a34b9">XMC_SCU_SetCcuTriggerLow</a> (const uint32_t trigger)</td></tr>
<tr class="separator:ga53300d587bbd03bc34c5a4396f5a34b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f600fa31f024ec9d8e0c17fc767772f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga0f600fa31f024ec9d8e0c17fc767772f">XMC_SCU_SetRawTempLimits</a> (const uint32_t lower_temp, const uint32_t upper_temp)</td></tr>
<tr class="separator:ga0f600fa31f024ec9d8e0c17fc767772f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba2aa44ad65c101852033173e2fc9949"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___s_c_u.html#gaff029b1575acc0712d494932d8ca6d60">XMC_SCU_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gaba2aa44ad65c101852033173e2fc9949">XMC_SCU_StartTempMeasurement</a> (void)</td></tr>
<tr class="separator:gaba2aa44ad65c101852033173e2fc9949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5851b97d5f0830ba58eecc516a488db0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga5851b97d5f0830ba58eecc516a488db0">XMC_SCU_StopTempMeasurement</a> (void)</td></tr>
<tr class="separator:ga5851b97d5f0830ba58eecc516a488db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab79580e5b6decc4f6ecce14be9efe17d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gab79580e5b6decc4f6ecce14be9efe17d">XMC_SCU_SupplyMonitorInit</a> (const <a class="el" href="struct_x_m_c___s_c_u___s_u_p_p_l_y_m_o_n_i_t_o_r__t.html">XMC_SCU_SUPPLYMONITOR_t</a> *obj)</td></tr>
<tr class="separator:gab79580e5b6decc4f6ecce14be9efe17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf60632360634a2f1be0f8af715c03dea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gaf60632360634a2f1be0f8af715c03dea">XMC_SCU_UnlockProtectedBits</a> (void)</td></tr>
<tr class="separator:gaf60632360634a2f1be0f8af715c03dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>System control unit is the SoC power, reset and a clock manager with additional responsibility of providing system stability protection and other auxiliary functions.<br />
 SCU provides the following features,</p><ol type="1">
<li>Power control</li>
<li>Reset control</li>
<li>Clock control</li>
<li>Miscellaneous control(boot mode, system interrupts etc.)<br />
<br />
</li>
</ol>
<p>The SCU driver is divided in to clock control logic, reset control logic, system interrupt control logic and miscellaneous control logic.<br />
</p>
<p>Clock driver features:</p><ol type="1">
<li>Allows clock configuration using the structure <a class="el" href="struct_x_m_c___s_c_u___c_l_o_c_k___c_o_n_f_i_g__t.html">XMC_SCU_CLOCK_CONFIG_t</a> and API <a class="el" href="group___s_c_u.html#ga08c337e8a728604e7eb54dff78ae2d9d">XMC_SCU_CLOCK_Init()</a></li>
<li>Allows selection of peripheral clock frequency, <a class="el" href="group___s_c_u.html#ga6103bc92c9cd326903ee4e6b2e1d055d">XMC_SCU_CLOCK_SetFastPeripheralClockSource()</a></li>
<li>Provides API to get the peripheral clock frequency, <a class="el" href="group___s_c_u.html#ga4269bd27311f46c895b7ca474236d71c">XMC_SCU_CLOCK_GetFastPeripheralClockFrequency()</a></li>
</ol>
<p>Reset driver features:</p><ol type="1">
<li>Allows to trigger device reset <a class="el" href="group___s_c_u.html#ga77c6ab2add788e4bd31eb563e0f8f8b1">XMC_SCU_RESET_AssertMasterReset()</a></li>
<li>Allows to configure multiple sources for reset, <a class="el" href="group___s_c_u.html#gaa4dbbfd3a9346cc7eb84bda46d084607">XMC_SCU_RESET_EnableResetRequest()</a> <br />
</li>
</ol>
<p>Interrupt driver features:</p><ol type="1">
<li>Provides APIs for enabling/ disabling interrupt event generation <a class="el" href="group___s_c_u.html#gaf151dd6fcd9b87597df94d9c1f91459e">XMC_SCU_INTERRUPT_EnableEvent()</a>, <a class="el" href="group___s_c_u.html#gad5db18b53ccbc47c21b8af53e6998120">XMC_SCU_INTERRUPT_DisableEvent()</a></li>
<li>Provides API for registering callback function for events <a class="el" href="group___s_c_u.html#ga4ae03c6bcc3ccade266b46d84f7715e6">XMC_SCU_INTERRUPT_SetEventHandler()</a><br />
</li>
</ol>
<p>Miscellaneous features:</p><ol type="1">
<li>Allows to trigger multiple capture compare unit(CCU) channels to be started together <a class="el" href="group___s_c_u.html#gac10ca2cd72477476ffe38a4818bcae4b">XMC_SCU_SetCcuTriggerHigh()</a></li>
<li>Enables configuration of die temperature sensor <a class="el" href="group___s_c_u.html#gaba2aa44ad65c101852033173e2fc9949">XMC_SCU_StartTempMeasurement()</a>, <a class="el" href="group___s_c_u.html#ga0f600fa31f024ec9d8e0c17fc767772f">XMC_SCU_SetRawTempLimits()</a></li>
<li>Allows configuring supply monitor unit using the structure <a class="el" href="struct_x_m_c___s_c_u___s_u_p_p_l_y_m_o_n_i_t_o_r__t.html">XMC_SCU_SUPPLYMONITOR_t</a> and API <a class="el" href="group___s_c_u.html#gab79580e5b6decc4f6ecce14be9efe17d">XMC_SCU_SupplyMonitorInit()</a></li>
<li>Allows handling of protected bits <a class="el" href="group___s_c_u.html#gad9ba5dce219ea8390f4aa9f7bc46aafe">XMC_SCU_LockProtectedBits()</a>, <a class="el" href="group___s_c_u.html#gaf60632360634a2f1be0f8af715c03dea">XMC_SCU_UnlockProtectedBits()</a><br />
 </li>
</ol>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga87cf336cf51860955435acebcacb704c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_MAJOR_VERSION&#160;&#160;&#160;(1U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Major number of the SCU driver version, which is &lt;major&gt;.&lt;minor&gt;.&lt;patch&gt; e.g. 1.5.3. </p>

</div>
</div>
<a class="anchor" id="gacdd702a84c73c50d01294e2bf761b2f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_MINOR_VERSION&#160;&#160;&#160;(0U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Minor number of the SCU driver version, which is &lt;major&gt;.&lt;minor&gt;.&lt;patch&gt; e.g. 1.5.3. </p>

</div>
</div>
<a class="anchor" id="gaae4d75cdeae18f943f60f45d13759690"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_PATCH_VERSION&#160;&#160;&#160;(2U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Patch number of the SCU driver version, which is &lt;major&gt;.&lt;minor&gt;.&lt;patch&gt; e.g. 1.5.3. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga4b50170c441fb21833c07a27b814a581"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* XMC_SCU_INTERRUPT_EVENT_HANDLER_t) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function pointer type used for registering callback functions on SCU event occurence. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga51850699f03c906a5fefcc4f04c6b2c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#ga51850699f03c906a5fefcc4f04c6b2c1">XMC_SCU_CCU_TRIGGER_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines options for Capture/Compare unit timer slice trigger that enables synchronous start function available on the <em>SCU</em>, <em>CCUCON</em> register. Use type <em>XMC_SCU_CCU_TRIGGER_t</em> for accessing these enum parameters. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga51850699f03c906a5fefcc4f04c6b2c1ab9e67fe77a9a1219bd0d4594c3f7a0ea"></a>XMC_SCU_CCU_TRIGGER_CCU40&#160;</td><td class="fielddoc">
<p>Trigger CCU40 peripheral. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga51850699f03c906a5fefcc4f04c6b2c1ae5aa55222489a096c454eb0ce95e1bf2"></a>XMC_SCU_CCU_TRIGGER_CCU80&#160;</td><td class="fielddoc">
<p>Trigger CCU80 peripheral. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gad4ef17eaabe7b13c5c159ba6b24c6a2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#gad4ef17eaabe7b13c5c159ba6b24c6a2c">XMC_SCU_CLOCK_PCLKSRC_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines possible sources of peripheral clock (PCLK). These enums can be used to configure <em>PCLKSEL</em> bits of <em>CLKCR</em> Clock Control Register. Use type <em>XMC_SCU_CLOCK_PCLKSRC_t</em> for accessing these enum parameters. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggad4ef17eaabe7b13c5c159ba6b24c6a2ca68981ef360c0c5bd355918858a72c3f3"></a>XMC_SCU_CLOCK_PCLKSRC_MCLK&#160;</td><td class="fielddoc">
<p>MCLK as the source for PCLK. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggad4ef17eaabe7b13c5c159ba6b24c6a2cac5e87eeb279a280a096fccee739e1cc1"></a>XMC_SCU_CLOCK_PCLKSRC_DOUBLE_MCLK&#160;</td><td class="fielddoc">
<p>Source of PCLK is twice the MCLK. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga6cf5c338f64adfc26ef8c49e826cd752"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#ga6cf5c338f64adfc26ef8c49e826cd752">XMC_SCU_CLOCK_RTCCLKSRC_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines possible sources of RTC clock. These enums can be used to configure <em>RTCCLKSEL</em> bits of <em>CLKCR</em> Clock Control Register. Use type <em>XMC_SCU_CLOCK_RTCCLKSRC_t</em> for accessing these enum parameters. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga6cf5c338f64adfc26ef8c49e826cd752a53e45cffbefd82a99a6b3823ac158007"></a>XMC_SCU_CLOCK_RTCCLKSRC_DCO2&#160;</td><td class="fielddoc">
<p>RTC clock source is standby clock. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6cf5c338f64adfc26ef8c49e826cd752a73ebf57da51c953f94ac117429da1728"></a>XMC_SCU_CLOCK_RTCCLKSRC_ERU_IOUT0&#160;</td><td class="fielddoc">
<p>RTC clock source is external clock from ERU0.IOUT0. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6cf5c338f64adfc26ef8c49e826cd752a41b802a680db96bfed5bb865e665101b"></a>XMC_SCU_CLOCK_RTCCLKSRC_ACMP0_OUT&#160;</td><td class="fielddoc">
<p>RTC clock source is external clock from ACMP0.OUT. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6cf5c338f64adfc26ef8c49e826cd752a1c9bca4660e4084fe22e2b5f8025ccf5"></a>XMC_SCU_CLOCK_RTCCLKSRC_ACMP1_OUT&#160;</td><td class="fielddoc">
<p>RTC clock source is external clock from ACMP1.OUT. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6cf5c338f64adfc26ef8c49e826cd752a2fe29d440be9a7d055d919a602ed86c8"></a>XMC_SCU_CLOCK_RTCCLKSRC_ACMP2_OUT&#160;</td><td class="fielddoc">
<p>RTC clock source is external clock from ACMP2.OUT. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga03e9302206c9d6eef0c1002f39f12faf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#ga03e9302206c9d6eef0c1002f39f12faf">XMC_SCU_INTERRUPT_EVENT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines list of events that can generate SCU interrupt. These enums can be used to configure events in <em>SRMSK</em> register for assertion of interrupt. All the enum items are tabulated as per bits present in <em>SRMSK</em> register. Use type <em>XMC_SCU_INTERRUPT_EVENT_t</em> for accessing these enum parameters. These enums can also be used for checking the status of events from the <em>SRSTAT</em> register. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga03e9302206c9d6eef0c1002f39f12fafab49e4cfec05bd67841c9083334f6873b"></a>XMC_SCU_INTERRUPT_EVENT_WDT_WARN&#160;</td><td class="fielddoc">
<p>WDT pre-warning event. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga03e9302206c9d6eef0c1002f39f12fafa6e4f042e507ac6856f1e36768a978c3b"></a>XMC_SCU_INTERRUPT_EVENT_RTC_PERIODIC&#160;</td><td class="fielddoc">
<p>RTC periodic event. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga03e9302206c9d6eef0c1002f39f12fafae112208768ed97572e5804e0826707bd"></a>XMC_SCU_INTERRUPT_EVENT_RTC_ALARM&#160;</td><td class="fielddoc">
<p>RTC alarm event. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga03e9302206c9d6eef0c1002f39f12fafa36be7a15b49011db6b22f9b4fb63794e"></a>XMC_SCU_INTERRUPT_EVENT_VDDPI&#160;</td><td class="fielddoc">
<p>VDDP pre-warning event. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga03e9302206c9d6eef0c1002f39f12fafa2ae9830cbb1db5218af7bcb781f5dae5"></a>XMC_SCU_INTERRUPT_EVENT_ACMP0&#160;</td><td class="fielddoc">
<p>Analog comparator-0 output event. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga03e9302206c9d6eef0c1002f39f12fafaf515ba586422108d444e680d5ec91206"></a>XMC_SCU_INTERRUPT_EVENT_ACMP1&#160;</td><td class="fielddoc">
<p>Analog comparator-1 output event. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga03e9302206c9d6eef0c1002f39f12fafa9f7562edaccc7d6f3396d41c7ba8fc14"></a>XMC_SCU_INTERRUPT_EVENT_ACMP2&#160;</td><td class="fielddoc">
<p>Analog comparator-2 output event. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga03e9302206c9d6eef0c1002f39f12fafa8b8d4ea9329a46658590e426f3f47583"></a>XMC_SCU_INTERRUPT_EVENT_VDROP&#160;</td><td class="fielddoc">
<p>VDROP event. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga03e9302206c9d6eef0c1002f39f12fafa8a662e56d91004fb969dff632cd67f3f"></a>XMC_SCU_INTERRUPT_EVENT_ORC0&#160;</td><td class="fielddoc">
<p>Out of range comparator-0 event. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga03e9302206c9d6eef0c1002f39f12fafa1b0b35f9b1ff46b07c48ac9274e5ffef"></a>XMC_SCU_INTERRUPT_EVENT_ORC1&#160;</td><td class="fielddoc">
<p>Out of range comparator-1 event. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga03e9302206c9d6eef0c1002f39f12fafaaec278b2db003ceb5e83622ad07b6bba"></a>XMC_SCU_INTERRUPT_EVENT_ORC2&#160;</td><td class="fielddoc">
<p>Out of range comparator-2 event. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga03e9302206c9d6eef0c1002f39f12fafa79e531670b77b2bae7845a55a11b0ca3"></a>XMC_SCU_INTERRUPT_EVENT_ORC3&#160;</td><td class="fielddoc">
<p>Out of range comparator-3 event. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga03e9302206c9d6eef0c1002f39f12fafa63c1cd122d983e237fa6266edd122b21"></a>XMC_SCU_INTERRUPT_EVENT_ORC4&#160;</td><td class="fielddoc">
<p>Out of range comparator-4 event. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga03e9302206c9d6eef0c1002f39f12fafae9d442589f144d49707ac629a76146a8"></a>XMC_SCU_INTERRUPT_EVENT_ORC5&#160;</td><td class="fielddoc">
<p>Out of range comparator-5 event. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga03e9302206c9d6eef0c1002f39f12fafa43d075a0b8f88ca6abb1a10c7a15d404"></a>XMC_SCU_INTERRUPT_EVENT_ORC6&#160;</td><td class="fielddoc">
<p>Out of range comparator-6 event. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga03e9302206c9d6eef0c1002f39f12fafa0e1b8e66ed9421a136c7bfebf3c3f04b"></a>XMC_SCU_INTERRUPT_EVENT_ORC7&#160;</td><td class="fielddoc">
<p>Out of range comparator-7 event. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga03e9302206c9d6eef0c1002f39f12fafac8f3e1ab42ded809ccc2d8460769e930"></a>XMC_SCU_INTERRUPT_EVENT_LOCI&#160;</td><td class="fielddoc">
<p>Loss of clock event. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga03e9302206c9d6eef0c1002f39f12fafa3fd4e102d2041791cb21d2931521103e"></a>XMC_SCU_INTERRUPT_EVENT_PESRAM&#160;</td><td class="fielddoc">
<p>PSRAM Parity error event. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga03e9302206c9d6eef0c1002f39f12fafadf68182bcd64a2141b20f04d8be2d5b1"></a>XMC_SCU_INTERRUPT_EVENT_PUSIC&#160;</td><td class="fielddoc">
<p>USIC Parity error event. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga03e9302206c9d6eef0c1002f39f12fafacb7fdee91cedc2ad4f8187bb894ee8c2"></a>XMC_SCU_INTERRUPT_EVENT_FLASH_ERROR&#160;</td><td class="fielddoc">
<p>Flash ECC double bit error event. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga03e9302206c9d6eef0c1002f39f12fafa41347d9c5d33b0e27163b5c5dc461b13"></a>XMC_SCU_INTERRUPT_EVENT_FLASH_COMPLETED&#160;</td><td class="fielddoc">
<p>Flash operation completion event. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga03e9302206c9d6eef0c1002f39f12fafa4c51bacdb7b51e920e67fbed636bd063"></a>XMC_SCU_INTERRUPT_EVENT_VCLIP&#160;</td><td class="fielddoc">
<p>VCLIP event. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga03e9302206c9d6eef0c1002f39f12fafa3b5def96ebde8b8a3f2e8c8c208f86ad"></a>XMC_SCU_INTERRUPT_EVENT_STDBYCLKFAIL&#160;</td><td class="fielddoc">
<p>Standby clock failure event. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga03e9302206c9d6eef0c1002f39f12fafaf6a54c2ca347337984a5fa9555e1cb3c"></a>XMC_SCU_INTERRUPT_EVENT_RTCCTR_UPDATED&#160;</td><td class="fielddoc">
<p>RTCCTR register update event. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga03e9302206c9d6eef0c1002f39f12fafafeeeb43ec31dd9576349de17fd81acfa"></a>XMC_SCU_INTERRUPT_EVENT_RTCATIM0_UPDATED&#160;</td><td class="fielddoc">
<p>RTCATIM0 register update event. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga03e9302206c9d6eef0c1002f39f12fafadf611625f44d6a95a62ddcf0bc7ccfdf"></a>XMC_SCU_INTERRUPT_EVENT_RTCATIM1_UPDATED&#160;</td><td class="fielddoc">
<p>RTCATIM1 register update event. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga03e9302206c9d6eef0c1002f39f12fafa3ca830417c184f558a9f01187052414d"></a>XMC_SCU_INTERRUPT_EVENT_RTCTIM0_UPDATED&#160;</td><td class="fielddoc">
<p>RTCTIM0 register update event. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga03e9302206c9d6eef0c1002f39f12fafa858993fe3ea2c5bdc861ef643ef9ad4f"></a>XMC_SCU_INTERRUPT_EVENT_RTCTIM1_UPDATED&#160;</td><td class="fielddoc">
<p>RTCTIM1 register update event. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga03e9302206c9d6eef0c1002f39f12fafaabbc68752cfef4087aac834074a8b5bf"></a>XMC_SCU_INTERRUPT_EVENT_TSE_DONE&#160;</td><td class="fielddoc">
<p>Temperature measurement Completion event. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga03e9302206c9d6eef0c1002f39f12fafa461c6d77f2bf6560cd051bffa271fc07"></a>XMC_SCU_INTERRUPT_EVENT_TSE_HIGH&#160;</td><td class="fielddoc">
<p>Temperature too high event. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga03e9302206c9d6eef0c1002f39f12fafae7ecc9a9cf091592eecf694d80920085"></a>XMC_SCU_INTERRUPT_EVENT_TSE_LOW&#160;</td><td class="fielddoc">
<p>Temperature too low event. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga29713150fdafc3c88f3c73f621410239"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#ga29713150fdafc3c88f3c73f621410239">XMC_SCU_PERIPHERAL_CLOCK_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines th list of various sources that support gating of clock to peripherals. After a master reset, only core, memories, SCU and PORT peripheral are not clock gated. The rest of the peripherals are default clock gated. All the enum items are tabulated as per bits present in <em>CGATSTAT0</em> register. Use type <em>XMC_SCU_PERIPHERAL_CLOCK_t</em> for accessing these enum parameters. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga29713150fdafc3c88f3c73f621410239a52c9f76dec72eff13f90cdc046d47401"></a>XMC_SCU_PERIPHERAL_CLOCK_VADC&#160;</td><td class="fielddoc">
<p>VADC peripheral clock gate. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga29713150fdafc3c88f3c73f621410239a0bb88ac36dfd3545282123f56c5c2374"></a>XMC_SCU_PERIPHERAL_CLOCK_CCU80&#160;</td><td class="fielddoc">
<p>CCU80 peripheral clock gate. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga29713150fdafc3c88f3c73f621410239a346af75d76735810851f4175e0aa7510"></a>XMC_SCU_PERIPHERAL_CLOCK_CCU40&#160;</td><td class="fielddoc">
<p>CCU40 peripheral clock gate. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga29713150fdafc3c88f3c73f621410239a3b7bdfee77b9c35016b8c8367fa19cc2"></a>XMC_SCU_PERIPHERAL_CLOCK_USIC0&#160;</td><td class="fielddoc">
<p>USIC0 peripheral clock gate. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga29713150fdafc3c88f3c73f621410239ad9f67751fcf7facbbf4cd2a5b36e38f0"></a>XMC_SCU_PERIPHERAL_CLOCK_BCCU0&#160;</td><td class="fielddoc">
<p>BCCU0 peripheral clock gate. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga29713150fdafc3c88f3c73f621410239a2cdc8717b252a95151639d5f95c5d0a2"></a>XMC_SCU_PERIPHERAL_CLOCK_LEDTS0&#160;</td><td class="fielddoc">
<p>LEDTS0 peripheral clock gate. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga29713150fdafc3c88f3c73f621410239a9979deef2f645ef5335292f656b301b8"></a>XMC_SCU_PERIPHERAL_CLOCK_LEDTS1&#160;</td><td class="fielddoc">
<p>LEDTS1 peripheral clock gate. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga29713150fdafc3c88f3c73f621410239a7d81755a02791cef84e36351a4e21ca5"></a>XMC_SCU_PERIPHERAL_CLOCK_POSIF0&#160;</td><td class="fielddoc">
<p>POSIF0 peripheral clock gate. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga29713150fdafc3c88f3c73f621410239abd383e07c1966b805eabc208362baefd"></a>XMC_SCU_PERIPHERAL_CLOCK_MATH&#160;</td><td class="fielddoc">
<p>MATH peripheral clock gate. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga29713150fdafc3c88f3c73f621410239a94022ad63fa2dbbbf514709a230956ea"></a>XMC_SCU_PERIPHERAL_CLOCK_WDT&#160;</td><td class="fielddoc">
<p>WDT peripheral clock gate. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga29713150fdafc3c88f3c73f621410239a274fa98fa526d3ea003785ecbcba9e36"></a>XMC_SCU_PERIPHERAL_CLOCK_RTC&#160;</td><td class="fielddoc">
<p>RTC peripheral clock gate. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gae01c08f5d524dadbc6e0c4128b348dc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#gae01c08f5d524dadbc6e0c4128b348dc3">XMC_SCU_RESET_REASON_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the cause of last reset. The cause of last reset gets automatically stored in the <em>SCU_RSTSTAT</em> register and can be checked by user software to determine the state of the system and for debug purpose. All the enum items are tabulated as per bits present in <em>SCU_RSTSTAT</em> register. Use type <em>XMC_SCU_RESET_REASON_t</em> for accessing these enum parameters. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggae01c08f5d524dadbc6e0c4128b348dc3ae8bea77e364f87d9c74afb215da65273"></a>XMC_SCU_RESET_REASON_PORST&#160;</td><td class="fielddoc">
<p>Reset due to Power On reset. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae01c08f5d524dadbc6e0c4128b348dc3a1742c1894d91860d7541385f3f0c4fe1"></a>XMC_SCU_RESET_REASON_MASTER&#160;</td><td class="fielddoc">
<p>Reset due to Master reset. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae01c08f5d524dadbc6e0c4128b348dc3aa6d2a43d58beebfabf3897c2ed65bd03"></a>XMC_SCU_RESET_REASON_SW&#160;</td><td class="fielddoc">
<p>Reset due to Software initiated reset. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae01c08f5d524dadbc6e0c4128b348dc3aa147b82fa48ea09fe9137601ce28b6c9"></a>XMC_SCU_RESET_REASON_LOCKUP&#160;</td><td class="fielddoc">
<p>Reset due to CPU lockup. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae01c08f5d524dadbc6e0c4128b348dc3a5b52d4b8f8aa89a37e05e865ffaef900"></a>XMC_SCU_RESET_REASON_FLASH&#160;</td><td class="fielddoc">
<p>Reset due to flash error. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae01c08f5d524dadbc6e0c4128b348dc3acd2ed3c6d9ade72259637c7c80a840cb"></a>XMC_SCU_RESET_REASON_WATCHDOG&#160;</td><td class="fielddoc">
<p>Reset due to watchdog. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae01c08f5d524dadbc6e0c4128b348dc3a0e3a7d9ed387fd8d11576c4f63d61cb2"></a>XMC_SCU_RESET_REASON_CLOCK_LOSS&#160;</td><td class="fielddoc">
<p>Reset due to clock loss. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae01c08f5d524dadbc6e0c4128b348dc3a9d34595d39facbd7b114462d5cc5b0c8"></a>XMC_SCU_RESET_REASON_PARITY_ERROR&#160;</td><td class="fielddoc">
<p>Reset due to RAM parity error. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga236deb68e8388f2f1283e5573e76d7a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#ga236deb68e8388f2f1283e5573e76d7a7">XMC_SCU_SLEEP_CLK_INSTR_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines different states used while changing the device sleep modes. Use type <em>XMC_SCU_SLEEP_CLK_INSTR_t</em> for accessing these enum parameters. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga236deb68e8388f2f1283e5573e76d7a7a5e86ca5bf880797effdf66301de95af5"></a>XMC_SCU_SLEEP_CLK_INSTR_ENTER&#160;</td><td class="fielddoc">
<p>Enter sleep mode : In this state, a snapshot of clocks that are active is taken. All peripheral clocks are disabled before sleep mode instruction (WFI) is executed. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga236deb68e8388f2f1283e5573e76d7a7a93cc1a7893d01dabed8f6d09f7b3e460"></a>XMC_SCU_SLEEP_CLK_INSTR_EXIT&#160;</td><td class="fielddoc">
<p>Exit sleep mode : In this state, all the peripheral clocks that were active before entering the sleep mode are enabled. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gaff029b1575acc0712d494932d8ca6d60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#gaff029b1575acc0712d494932d8ca6d60">XMC_SCU_STATUS_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the status of SCU API execution, used to verify the SCU related API calls. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaff029b1575acc0712d494932d8ca6d60a764eaaa84d169b3222ae9174d1fa6855"></a>XMC_SCU_STATUS_OK&#160;</td><td class="fielddoc">
<p>SCU related operation successfully completed. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaff029b1575acc0712d494932d8ca6d60a6f6a43bd2a61be2a1b0b57601d58bd77"></a>XMC_SCU_STATUS_BUSY&#160;</td><td class="fielddoc">
<p>Cannot execute the SCU related operation request because another operation is in progress. <em>XMC_SCU_STATUS_BUSY</em> is returned when API is busy processing another request. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaff029b1575acc0712d494932d8ca6d60aaf8f778e9be5e754dcaa0c1cf83e1e4b"></a>XMC_SCU_STATUS_ERROR&#160;</td><td class="fielddoc">
<p>SCU related operation failed. When API cannot fulfill request, this value is returned. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga4988413b7da85ed020b8d1a8243e28aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#ga4988413b7da85ed020b8d1a8243e28aa">XMC_SCU_SYSTEM_RESET_REQUEST_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the reset sources that can cause device reset. These enums can be used to configure reset source in reset control <em>RSTCON</em> register which enables different reset sources to identify the reset cause. The <em>SCU_RSTSTAT</em> register can be checked by user software to determine the state of the system and for debug purpose. Use type <em>XMC_SCU_SYSTEM_RESET_REQUEST_t</em> for accessing these enum parameters. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga4988413b7da85ed020b8d1a8243e28aaa97383dd0b2c36dbb082441a879289a0d"></a>XMC_SCU_RESET_REQUEST_FLASH_ECC_ERROR&#160;</td><td class="fielddoc">
<p>Reset when ECC double bit error occurs. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4988413b7da85ed020b8d1a8243e28aaa4e8060a113c0650c5c1ef3f200ce4e39"></a>XMC_SCU_RESET_REQUEST_CLOCK_LOSS&#160;</td><td class="fielddoc">
<p>Reset when loss of clock occurs. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4988413b7da85ed020b8d1a8243e28aaaa2c6d4ddc9c83f71bf47d2b39ef25e83"></a>XMC_SCU_RESET_REQUEST_SRAM_PARITY_ERROR&#160;</td><td class="fielddoc">
<p>Reset when SRAM parity error occurs. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4988413b7da85ed020b8d1a8243e28aaa50dee8709c1bc2b69bcf3e90ca52ce90"></a>XMC_SCU_RESET_REQUEST_USIC_SRAM_PARITY_ERROR&#160;</td><td class="fielddoc">
<p>Reset when USIC0 memory parity error occurs. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gab0af70f90b9a1f24d3a0a4764543d833"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_GatePeripheralClock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___s_c_u.html#ga29713150fdafc3c88f3c73f621410239">XMC_SCU_PERIPHERAL_CLOCK_t</a>&#160;</td>
          <td class="paramname"><em>peripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peripheral</td><td>The peripheral for which the clock has to be gated. <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga29713150fdafc3c88f3c73f621410239">XMC_SCU_PERIPHERAL_CLOCK_t</a> to identify the peripheral clock to be gated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Blocks the supply of clock to the selected peripheral.<br />
<br />
Clock gating helps in reducing the power consumption. User can selectively gate the clocks of unused peripherals. fPCLK is the source of clock to various peripherals. Some peripherals support clock gate. Such a gate blocks the clock supply for the selected peripheral. Software can request for individual gating of such peripheral clocks by enabling the <em>SCU_CGATSET0</em> register bit field. Every bit in <em>SCU_CGATSET0</em> register is protected by the bit protection scheme. Access to protected bit fields are handled internally. Note: Clock gating shall not be activated unless the module is in reset state. So use <em><a class="el" href="group___s_c_u.html#ga804f98badedf0e0ba4ce09f445687a37">XMC_SCU_CLOCK_IsPeripheralClockGated()</a></em> API before enabling the gating of any peripheral. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga804f98badedf0e0ba4ce09f445687a37">XMC_SCU_CLOCK_IsPeripheralClockGated()</a>, <a class="el" href="group___s_c_u.html#ga702904d10b6e6c6a55db381763fd322f">XMC_SCU_CLOCK_UngatePeripheralClock()</a> <br />
<br />
<br />
</dd></dl>

<p>Referenced by <a class="el" href="group___m_a_t_h.html#ga71d099b1395e99beea8f38c8f837194f">XMC_MATH_Disable()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3e78410c4d0c9f9b54aa0965d16c3795"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_CLOCK_GetCpuClockFrequency </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>uint32_t Value of CPU clock frequency.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the vlaue of CPU clock frequency.<br />
<br />
The value is stored in a global variable <em><b>SystemCoreClock</b>.</em> It is updated when the clock configuration is done using the SCU LLD APIs. The value represents the frequency of clock used for CPU operation. <b>Range:</b> Value is of type uint32_t, and gives the value of frequency in Hertz.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga55a1be4f0e96fcda7b2c0feb542af250">XMC_SCU_CLOCK_GetPeripheralClockFrequency()</a>, <a class="el" href="group___s_c_u.html#gab0af70f90b9a1f24d3a0a4764543d833">XMC_SCU_CLOCK_GatePeripheralClock()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga4269bd27311f46c895b7ca474236d71c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_CLOCK_GetFastPeripheralClockFrequency </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>uint32_t Fast peripheral clock frequency in Hertz.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the clock frequency of peripherals on the peripheral bus that are using a shared functional clock.<br />
<br />
The value is derived using the bitfield <em>PCLKSEL</em> from <em>CLKCR</em> register. Peripheral clock can have 2 times the frequency of system clock if the <em>PCLKSEL</em> is set. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga6103bc92c9cd326903ee4e6b2e1d055d">XMC_SCU_CLOCK_SetFastPeripheralClockSource()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga55a1be4f0e96fcda7b2c0feb542af250"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_CLOCK_GetPeripheralClockFrequency </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>uint32_t Value of peripheral clock frequency in Hertz.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the vlaue of clock frequency at which the peripherals are working.<br />
<br />
The value is derived from the CPU frequency. <b>Range:</b> Value is of type uint32_t. It is represented in Hertz. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga3e78410c4d0c9f9b54aa0965d16c3795">XMC_SCU_CLOCK_GetCpuClockFrequency()</a>,<a class="el" href="group___s_c_u.html#gab0af70f90b9a1f24d3a0a4764543d833">XMC_SCU_CLOCK_GatePeripheralClock()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga08c337e8a728604e7eb54dff78ae2d9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_Init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___s_c_u___c_l_o_c_k___c_o_n_f_i_g__t.html">XMC_SCU_CLOCK_CONFIG_t</a> *const&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>Pointer to structure holding the clock prescaler values and divider values for configuring clock generators and clock tree.<br />
 <b>Range:</b> Configure the members of structure <a class="el" href="struct_x_m_c___s_c_u___c_l_o_c_k___c_o_n_f_i_g__t.html">XMC_SCU_CLOCK_CONFIG_t</a> for various parameters of clock setup.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Initializes clock generators and clock tree.<br />
<br />
Peripheral clock and system clock are configured based on the input configuration <em>config</em>. The system clock frequency is tuned by configuring the FDIV and IDIV values of CLKCR register. The values of FDIV and IDIV can be provided as part of input configuration. The PCLK divider determines the ratio of peripheral clock to the system clock. The source of RTC clock is set based on the input configuration. <em>SystemCoreClock</em> variable will be updated with the value of system clock frequency. Access to protected bit fields are handled internally. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga55a1be4f0e96fcda7b2c0feb542af250">XMC_SCU_CLOCK_GetPeripheralClockFrequency()</a>, <a class="el" href="group___s_c_u.html#ga3e78410c4d0c9f9b54aa0965d16c3795">XMC_SCU_CLOCK_GetCpuClockFrequency()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga804f98badedf0e0ba4ce09f445687a37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_SCU_CLOCK_IsPeripheralClockGated </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___s_c_u.html#ga29713150fdafc3c88f3c73f621410239">XMC_SCU_PERIPHERAL_CLOCK_t</a>&#160;</td>
          <td class="paramname"><em>peripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peripheral</td><td>The peripheral for which the check for clock gating has to be done. <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga29713150fdafc3c88f3c73f621410239">XMC_SCU_PERIPHERAL_CLOCK_t</a> to identify the peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool Status of the peripheral clock gating. <b>Range:</b> true if the peripheral clock is gated. false if the peripheral clock ungated(gate de-asserted).</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Gives the status of peripheral clock gating.<br />
<br />
Checks the status of peripheral clock gating using the register CGATSTAT0. It is recommended to use this API before enabling the gating of any peripherals through <em><a class="el" href="group___s_c_u.html#gab0af70f90b9a1f24d3a0a4764543d833">XMC_SCU_CLOCK_GatePeripheralClock()</a></em> API.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga702904d10b6e6c6a55db381763fd322f">XMC_SCU_CLOCK_UngatePeripheralClock()</a>, <a class="el" href="group___s_c_u.html#gab0af70f90b9a1f24d3a0a4764543d833">XMC_SCU_CLOCK_GatePeripheralClock()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga6103bc92c9cd326903ee4e6b2e1d055d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_SetFastPeripheralClockSource </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___s_c_u.html#gad4ef17eaabe7b13c5c159ba6b24c6a2c">XMC_SCU_CLOCK_PCLKSRC_t</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Fast peripheral clock source.<br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#gad4ef17eaabe7b13c5c159ba6b24c6a2c">XMC_SCU_CLOCK_PCLKSRC_t</a> to identify the clock source.<br />
 XMC_SCU_CLOCK_PCLKSRC_MCLK- Use MCLK as the peripheral clock.<br />
 XMC_SCU_CLOCK_PCLKSRC_DOUBLE_MCLK- peripheral clock will be 2 times the MCLK frequency.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Configures the source of peripheral clock. <br />
<br />
The peripheral clock can be either same as MCLK or twice the frequency of MCLK. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga4269bd27311f46c895b7ca474236d71c">XMC_SCU_CLOCK_GetFastPeripheralClockFrequency()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga702904d10b6e6c6a55db381763fd322f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_UngatePeripheralClock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___s_c_u.html#ga29713150fdafc3c88f3c73f621410239">XMC_SCU_PERIPHERAL_CLOCK_t</a>&#160;</td>
          <td class="paramname"><em>peripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peripheral</td><td>The peripheral for which the clock has to be ungated. <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga29713150fdafc3c88f3c73f621410239">XMC_SCU_PERIPHERAL_CLOCK_t</a> to identify the peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables the supply of clock to the selected peripheral.<br />
<br />
By default when the device powers on, the peripheral clock will be gated for the peripherals that support clock gating. The peripheral clock should be enabled before using it for any functionality. fPCLK is the source of clock to various peripherals. Some peripherals support clock gate. Software can request for individual ungating of such peripheral clocks by setting respective bits in the <em>SCU_CGATCLR0</em> register.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga804f98badedf0e0ba4ce09f445687a37">XMC_SCU_CLOCK_IsPeripheralClockGated()</a>, <a class="el" href="group___s_c_u.html#gab0af70f90b9a1f24d3a0a4764543d833">XMC_SCU_CLOCK_GatePeripheralClock()</a> <br />
<br />
<br />
</dd></dl>

<p>Referenced by <a class="el" href="group___m_a_t_h.html#ga96deae384cc966238f54343e8d5a1b28">XMC_MATH_Enable()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5f5fc5dbf267604cb41063d9a3c028e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XMC_DRIVER_VERSION_t XMC_SCU_GetDriverVersion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Data structure (::XMC_DRIVER_VERSION_t) storing driver version</dd></dl>
<dl class="section user"><dt>Description: </dt><dd>Returns the version of the low level driver <br />
</dd></dl>
<dl class="section user"><dt></dt><dd>The function can be used to check application software compatibility with a specific version of the low level driver. </dd></dl>

</div>
</div>
<a class="anchor" id="ga494b75a841498374cfee9664e6ce9cee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_GetMirrorStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>uint32_t Status of the register mirror update.<br />
 <b>Range:</b> Use the bit mask of the SCU_GENERAL_MIRRSTS register for the mirror update event of interest. e.g.: SCU_GENERAL_MIRRSTS_RTC_CTR_Msk. Multiple update events can be combined using <em>OR</em> operation.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the status of hibernate domain register update, when the respective mirror registers are changed. <br />
<br />
The hibernate domain is connected to the core domain via SPI serial communication. MIRRSTS is a status register representing the communication of changed value of a mirror register to its corresponding register in the hibernate domain. The bit fields of the register indicate that a corresponding register of the hibernate domain is ready to accept a write or that the communication interface is busy with executing the previous operation.<br />
Note: There is no hibernate domain in XMC1x devices. This register is retained for legacy purpose. </dd></dl>

</div>
</div>
<a class="anchor" id="ga71c4f02eb6036f0d3a13af5e10bf56cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_GetTemperature </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>uint32_t Die temperature value. <b>Range:</b> 16 bit value.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the die temperature value.<br />
<br />
The API reads temperature measurement result from <em>SCU_ANALOG-&gt;ANATSEMON</em> bit fields. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gaba2aa44ad65c101852033173e2fc9949">XMC_SCU_StartTempMeasurement()</a>, <a class="el" href="group___s_c_u.html#ga0f600fa31f024ec9d8e0c17fc767772f">XMC_SCU_SetRawTempLimits()</a>, <a class="el" href="group___s_c_u.html#ga5a0ad9c467d9549542d0f0275bae6314">XMC_SCU_HighTemperature()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga5a0ad9c467d9549542d0f0275bae6314"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_SCU_HighTemperature </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>bool Result of checking whether the die temperature is more than the upper threshold.<br />
 <b>Range:</b> <em>false</em> if temperature is below the upper threshold. <em>true</em> if temperature has exceeded the upper threshold configured in <em>ANATSEIH</em> register.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Check if the temperature has exceeded the upper threshold value.<br />
<br />
The API checks for <em>TSE_HIGH</em> bit (TSE Compare High Temperature Event Status bit) of <em>SRRAW</em> register. The bit will be set when the <em>TSE_MON</em> value in <em>ANATSEMON</em> register exceeds the value of <em>TSE_IH</em> value in <em>ANATSEIH</em> register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gaba2aa44ad65c101852033173e2fc9949">XMC_SCU_StartTempMeasurement()</a>, <a class="el" href="group___s_c_u.html#ga0f600fa31f024ec9d8e0c17fc767772f">XMC_SCU_SetRawTempLimits()</a>, <a class="el" href="group___s_c_u.html#ga71c4f02eb6036f0d3a13af5e10bf56cc">XMC_SCU_GetTemperature()</a>, <a class="el" href="group___s_c_u.html#ga8573534003ebf11fbaa49e331238fb86">XMC_SCU_LowTemperature()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga6bd0ece17f08fdd68d1e2ebda723b25e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_INTERRUPT_ClearEventStatus </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Bit mask of the events to clear. <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga03e9302206c9d6eef0c1002f39f12faf">XMC_SCU_INTERRUPT_EVENT_t</a> for providing the input value. Multiple events can be combined using the <em>OR</em> operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Clears the event status bit in SRRAW register.<br />
<br />
The events are cleared by writing value 1 to their bit positions in the SRCLR register. The API can be used when polling method is used. After detecting the event, the event status should be cleared using software to detect the event again.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga24e6e575b87666b99a59f4e992d5471a">XMC_SCU_INTERUPT_GetEventStatus()</a>, <a class="el" href="group___s_c_u.html#ga62abdedd61269613d36968eb15627073">XMC_SCU_INTERRUPT_TriggerEvent()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gad5db18b53ccbc47c21b8af53e6998120"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_INTERRUPT_DisableEvent </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Bit mask of the event to disable. <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga03e9302206c9d6eef0c1002f39f12faf">XMC_SCU_INTERRUPT_EVENT_t</a> for providing the input value. Multiple events can be combined using the <em>OR</em> operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables generation of interrupt on occurence of the input event.<br />
<br />
The events are disabled by resetting the respective bit fields in the SRMSK register. <br />
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>NVIC_DisableIRQ(), <a class="el" href="group___s_c_u.html#gaf151dd6fcd9b87597df94d9c1f91459e">XMC_SCU_INTERRUPT_EnableEvent()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gaf151dd6fcd9b87597df94d9c1f91459e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_INTERRUPT_EnableEvent </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Bit mask of the event to enable. <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga03e9302206c9d6eef0c1002f39f12faf">XMC_SCU_INTERRUPT_EVENT_t</a> for providing the input value. Multiple events can be combined using the <em>OR</em> operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables the generation of interrupt for the input events.<br />
<br />
The events are enabled by setting the respective bit fields in the SRMSK register. <br />
Note: User should separately enable the NVIC node responsible for handling the SCU interrupt. The interrupt will be generated when the respective event occurs. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>NVIC_EnableIRQ(), <a class="el" href="group___s_c_u.html#gad5db18b53ccbc47c21b8af53e6998120">XMC_SCU_INTERRUPT_DisableEvent()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga4ae03c6bcc3ccade266b46d84f7715e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___s_c_u.html#gaff029b1575acc0712d494932d8ca6d60">XMC_SCU_STATUS_t</a> XMC_SCU_INTERRUPT_SetEventHandler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___s_c_u.html#ga03e9302206c9d6eef0c1002f39f12faf">XMC_SCU_INTERRUPT_EVENT_t</a>&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___s_c_u.html#ga4b50170c441fb21833c07a27b814a581">XMC_SCU_INTERRUPT_EVENT_HANDLER_t</a>&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The event for which the interrupt handler is to be configured. <br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga03e9302206c9d6eef0c1002f39f12faf">XMC_SCU_INTERRUPT_EVENT_t</a> for identifying the event. </td></tr>
    <tr><td class="paramname">handler</td><td>Name of the function to be executed when the event if detected. <br />
 <b>Range:</b> The function accepts no arguments and returns no value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XMC_SCU_STATUS_t Status of configuring the event handler function for the selected event.<br />
 <b>Range:</b> <em>XMC_SCU_STATUS_OK</em> if the event handler is successfully configured.<br />
 <em>XMC_SCU_STATUS_ERROR</em> if the input event is invalid.<br />
</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Assigns the event handler function to be executed on occurence of the selected event.<br />
<br />
If the input event is valid, the handler function will be assigned to a table to be executed when the interrupt is generated and the event status is set in the event status register. By using this API, polling for a particular event can be avoided. This way the CPU utilization will be optimized. Multiple SCU events can generate a common interrupt. When the interrupt is generated, a common interrupt service routine is executed. It checks for status flags of events which can generate the interrupt. The handler function will be executed if the event flag is set.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga62abdedd61269613d36968eb15627073">XMC_SCU_INTERRUPT_TriggerEvent()</a>, <a class="el" href="group___s_c_u.html#ga24e6e575b87666b99a59f4e992d5471a">XMC_SCU_INTERUPT_GetEventStatus()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga62abdedd61269613d36968eb15627073"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_INTERRUPT_TriggerEvent </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Bit mask of the event to be triggered. <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga03e9302206c9d6eef0c1002f39f12faf">XMC_SCU_INTERRUPT_EVENT_t</a> for providing the input value. Multiple events can be combined using the <em>OR</em> operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Triggers the event as if the hardware raised it.<br />
<br />
Event will be triggered by setting the respective bitfield in the SRSET register.<br />
Note: User should enable the NVIC node that handles the respective event for interrupt generation. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>NVIC_EnableIRQ(), <a class="el" href="group___s_c_u.html#ga24e6e575b87666b99a59f4e992d5471a">XMC_SCU_INTERUPT_GetEventStatus()</a>, <a class="el" href="group___s_c_u.html#ga6bd0ece17f08fdd68d1e2ebda723b25e">XMC_SCU_INTERRUPT_ClearEventStatus()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga24e6e575b87666b99a59f4e992d5471a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_INTERUPT_GetEventStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>uint32_t Status of the SCU events.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the status of all SCU events.<br />
<br />
The status is read from the SRRAW register. To check the status of a particular event, the returned value should be masked with the bit mask of the event. The bitmask of events can be obtained using the type <a class="el" href="group___s_c_u.html#ga03e9302206c9d6eef0c1002f39f12faf">XMC_SCU_INTERRUPT_EVENT_t</a>. Multiple events' status can be checked by combining the bit masks using <em>OR</em> operation. After detecting the event, the event status should be cleared using software to detect the event again. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga6bd0ece17f08fdd68d1e2ebda723b25e">XMC_SCU_INTERRUPT_ClearEventStatus()</a>, <a class="el" href="group___s_c_u.html#ga62abdedd61269613d36968eb15627073">XMC_SCU_INTERRUPT_TriggerEvent()</a>, <a class="el" href="group___s_c_u.html#ga4ae03c6bcc3ccade266b46d84f7715e6">XMC_SCU_INTERRUPT_SetEventHandler()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga9ba1ce317ce89edfea107893fbd8a0be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_IRQHandler </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sr_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sr_num</td><td>Service request number identifying the SCU interrupt generated.<br />
 <b>Range:</b> 0 to 2. XMC4x devices have one common SCU interrupt, so the value should be 0.<br />
 But XMC1x devices support 3 interrupt nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>
<dl class="section user"><dt>Description</dt><dd>A common function to execute callback functions for multiple events.<br />
<br />
It checks for the status of events which can generate the interrupt with the selected service request. If the event is set, the corresponding callback function will be executed. It also clears the event status bit.<br />
<b>Note:</b> This is an internal function. It should not be called by the user application.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga4ae03c6bcc3ccade266b46d84f7715e6">XMC_SCU_INTERRUPT_SetEventHandler()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gad9ba5dce219ea8390f4aa9f7bc46aafe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_LockProtectedBits </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Locks access to protected bit fields of the SCU.<br />
<br />
The bit protection scheme prevents changing selected register bits by unauthorized code. Bit protection scheme is enabled by writing 000000C3H to <em>PASSWD</em> register. By writing this value, the API is setting the <em>MODE</em> bit field to bit protection enabled state.<br />
List of Protected Register Bit Fields are mentioned below. <br />
<table class="doxtable">
<tr>
<td><em>Register</em>  </td><td><em>Bit</em> fields  </td></tr>
<tr>
<td>SCU_CLKCR  </td><td>FDIV, IDIV, PCLKSEL, RTCLKSEL  </td></tr>
<tr>
<td>SCU_CGATSET0  </td><td>All bits  </td></tr>
<tr>
<td>SCU_CGATCLR0  </td><td>All bits  </td></tr>
<tr>
<td>SCU_ANAOFFSET  </td><td>ADJL_OFFSET  </td></tr>
<tr>
<td>VADC0_ACCPROT0  </td><td>All bits  </td></tr>
<tr>
<td>VADC0_ACCPROT1  </td><td>All bits  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gaf60632360634a2f1be0f8af715c03dea">XMC_SCU_UnlockProtectedBits()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga8573534003ebf11fbaa49e331238fb86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_SCU_LowTemperature </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>bool Result of checking whether the die temperature is less than the lower threshold.<br />
 <b>Range:</b> <em>false</em> if temperature is higher than the lower threshold. <em>true</em> if temperature has dropped below the lower threshold configured in <em>ANATSEIL</em> register.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Check if the temperature has dropped below the lower threshold value.<br />
<br />
The API checks for <em>TSE_LOW</em> bit (TSE Compare Low Temperature Event Status bit) of <em>SRRAW</em> register. The bit will be set when the <em>TSE_MON</em> value in <em>ANATSEMON</em> register drops below the value of <em>TSE_IL</em> value in <em>ANATSEIL</em> register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gaba2aa44ad65c101852033173e2fc9949">XMC_SCU_StartTempMeasurement()</a>, <a class="el" href="group___s_c_u.html#ga0f600fa31f024ec9d8e0c17fc767772f">XMC_SCU_SetRawTempLimits()</a>, <a class="el" href="group___s_c_u.html#ga71c4f02eb6036f0d3a13af5e10bf56cc">XMC_SCU_GetTemperature()</a>, <a class="el" href="group___s_c_u.html#ga5a0ad9c467d9549542d0f0275bae6314">XMC_SCU_HighTemperature()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga77c6ab2add788e4bd31eb563e0f8f8b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_RESET_AssertMasterReset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Trigger device master reset.<br />
<br />
The API triggers master reset by setting the <em>MRSTEN</em> bit of <em>RSTCON</em> register. It also internally triggers system reset. Almost all the logics of the device are affected by this reset. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gaa4dbbfd3a9346cc7eb84bda46d084607">XMC_SCU_RESET_EnableResetRequest()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga4bf9396e8b46be98f73999575d13bf6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_RESET_ClearDeviceResetReason </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Clears the reset reason bits in the reset status register. <br />
<br />
Clearing of the reset status information in the <em>SCU_RSTSTAT</em> register via register bit <em>RSTCLR.RSCLR</em> is strongly recommended to ensure a clear indication of the cause of next reset.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga3f779c81bdc29b44c644017a52aff300">XMC_SCU_RESET_GetDeviceResetReason()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gaa4dbbfd3a9346cc7eb84bda46d084607"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_RESET_EnableResetRequest </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>request</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>Reset source to trigger the device reset.<br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga4988413b7da85ed020b8d1a8243e28aa">XMC_SCU_SYSTEM_RESET_REQUEST_t</a> to identify the reset source.<br />
 XMC_SCU_RESET_REQUEST_FLASH_ECC_ERROR- Reset when flash memory double bit error is detected.<br />
 XMC_SCU_RESET_REQUEST_CLOCK_LOSS- Reset when loss of clock is detected.<br />
 XMC_SCU_RESET_REQUEST_SRAM_PARITY_ERROR- Reset when SRAM parity error is detected.<br />
 XMC_SCU_RESET_REQUEST_USIC_SRAM_PARITY_ERROR- Reset when USIC0 SRAM parity error is detected.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Configures trigger for system reset from the selected source.<br />
<br />
The API configures the reset source specific bit in the <em>RSTCON</em> register. Multiple reset sources can be combined using <em>OR</em> operation. By enabling the reset using this API will not trigger the reset. The reset will happen when the configured source event is detected. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga77c6ab2add788e4bd31eb563e0f8f8b1">XMC_SCU_RESET_AssertMasterReset()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga3f779c81bdc29b44c644017a52aff300"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_RESET_GetDeviceResetReason </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>uint32_t Status representing the reason for device reset.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the value representing the reason for device reset.<br />
<br />
The return value is an encoded word, which can indicate multiple reasons for the last reset. Each bit position of the returned word is representative of a last reset cause. The returned value should be appropriately masked to check the cause of reset. The cause of the last reset gets automatically stored in the <em>SCU_RSTSTAT</em> register. The reset status shall be reset after each startup in order to ensure consistent source indication after the next reset. <b>Range:</b> The type <a class="el" href="group___s_c_u.html#gae01c08f5d524dadbc6e0c4128b348dc3">XMC_SCU_RESET_REASON_t</a> can be used to get the bit masks of the reset cause.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga4bf9396e8b46be98f73999575d13bf6d">XMC_SCU_RESET_ClearDeviceResetReason()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gac10ca2cd72477476ffe38a4818bcae4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_SetCcuTriggerHigh </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>trigger</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trigger</td><td>CCU slices to be triggered synchronously via software. The value is a bitmask of CCU slice bits in the register CCUCON. <br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga51850699f03c906a5fefcc4f04c6b2c1">XMC_SCU_CCU_TRIGGER_t</a> for bitmask of individual CCU slices. Multiple slices can be combined using <em>OR</em> operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Generates active edge(low to high) trigger for multiple CCU units at the same time.<br />
<br />
Before executing this API, all the required CCU timers should configure external start. The edge of the start signal should be selected as active edge. The input signal for the CCU slice should be selected as SCU input. The above mentioned configurations can be made using the CCU LLD API <a class="el" href="group___c_c_u4.html#gac029dc08c5d54be8e773df0de9641691">XMC_CCU4_SLICE_StartConfig()</a>. CCU timer slice should be started using <a class="el" href="group___c_c_u4.html#ga9997bb59706a4034e3e3be33a4935a7c">XMC_CCU4_SLICE_StartTimer()</a> before triggering the timer using this API.<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#gac029dc08c5d54be8e773df0de9641691">XMC_CCU4_SLICE_StartConfig()</a>, <a class="el" href="group___c_c_u4.html#ga28e214514acb1a75a67de63e6d74b167">XMC_CCU4_SLICE_SetInput()</a>, <a class="el" href="group___s_c_u.html#ga53300d587bbd03bc34c5a4396f5a34b9">XMC_SCU_SetCcuTriggerLow()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga53300d587bbd03bc34c5a4396f5a34b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_SetCcuTriggerLow </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>trigger</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trigger</td><td>CCU slices to be triggered synchronously via software. The value is a bitmask of CCU slice bits in the register CCUCON. <br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga51850699f03c906a5fefcc4f04c6b2c1">XMC_SCU_CCU_TRIGGER_t</a> for bitmask of individual CCU slices. Multiple slices can be combined using <em>OR</em> operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Generates passive edge(high to low) trigger for multiple CCU units at the same time.<br />
<br />
Before executing this API, all the required CCU timers should configure external start. The edge of the start signal should be selected as passive edge. The input signal for the CCU slice should be selected as SCU input. The above mentioned configurations can be made using the CCU LLD API <a class="el" href="group___c_c_u4.html#gac029dc08c5d54be8e773df0de9641691">XMC_CCU4_SLICE_StartConfig()</a>. CCU timer slice should be started using <a class="el" href="group___c_c_u4.html#ga9997bb59706a4034e3e3be33a4935a7c">XMC_CCU4_SLICE_StartTimer()</a> before triggering the timer using this API.<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#gac029dc08c5d54be8e773df0de9641691">XMC_CCU4_SLICE_StartConfig()</a>, <a class="el" href="group___c_c_u4.html#ga28e214514acb1a75a67de63e6d74b167">XMC_CCU4_SLICE_SetInput()</a>, <a class="el" href="group___s_c_u.html#gac10ca2cd72477476ffe38a4818bcae4b">XMC_SCU_SetCcuTriggerHigh()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga0f600fa31f024ec9d8e0c17fc767772f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_SetRawTempLimits </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>lower_temp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>upper_temp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lower_temp</td><td>Lower threshold value for the die temperature.<br />
 <b>Range:</b> 0 to 65535(16 bit unsigned value). </td></tr>
    <tr><td class="paramname">upper_temp</td><td>Upper threshold value for the die temperature.<br />
 <b>Range:</b> 0 to 65535(16 bit unsigned value).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Configures upper and lower thresholds of die temperature as raw digital values into temperature sensor.<br />
<br />
The API configures <em>ANATSEIH</em> and <em>ANATSEIL</em> registers for upper and lower die temperature threshold limits respectively.<br />
It is recommended to use following steps:<br />
<ul>
<li>Call <em>XMC_SCU_StopTempMeasurement</em> to stop temperature measurement if it was started previously.<br />
</li>
<li>Call <em>XMC_SCU_SetRawTempLimits</em> with desired lower and upper temperature threshold limit values.<br />
</li>
<li>Finally call <em>XMC_SCU_StartTempMeasurement</em> to start temperature measurement.<br />
 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga5851b97d5f0830ba58eecc516a488db0">XMC_SCU_StopTempMeasurement()</a>, <a class="el" href="group___s_c_u.html#gaba2aa44ad65c101852033173e2fc9949">XMC_SCU_StartTempMeasurement()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gaba2aa44ad65c101852033173e2fc9949"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___s_c_u.html#gaff029b1575acc0712d494932d8ca6d60">XMC_SCU_STATUS_t</a> XMC_SCU_StartTempMeasurement </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>XMC_SCU_STATUS_t Status of starting the temperature measurement.<br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#gaff029b1575acc0712d494932d8ca6d60">XMC_SCU_STATUS_t</a> to identify the result.<br />
 XMC_SCU_STATUS_OK- Temperature measurement started successfully.<br />
 Always returns the above status.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Starts die temperature measurement using internal temperature sensor.<br />
<br />
The API, enables die temperature measurement and waits for about 10000 cycles until temperature measurement result is available on <em>SCU_ANALOG-&gt;ANATSEMON</em> bit fields.<br />
It is recommended to use following steps:<br />
<ul>
<li>Call <em>XMC_SCU_StopTempMeasurement</em> to stop temperature measurement if it was started previously.<br />
</li>
<li>Call <em>XMC_SCU_SetRawTempLimits</em> with desired lower and upper temperature threshold limit values if it is needed.<br />
</li>
<li>Call <em>XMC_SCU_StartTempMeasurement</em> to start temperature measurement.<br />
</li>
<li>Read die temperature value using <em>XMC_SCU_GetTemperature</em> API.<br />
</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga5851b97d5f0830ba58eecc516a488db0">XMC_SCU_StopTempMeasurement()</a>, <a class="el" href="group___s_c_u.html#ga0f600fa31f024ec9d8e0c17fc767772f">XMC_SCU_SetRawTempLimits()</a>, <a class="el" href="group___s_c_u.html#ga71c4f02eb6036f0d3a13af5e10bf56cc">XMC_SCU_GetTemperature()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga5851b97d5f0830ba58eecc516a488db0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_StopTempMeasurement </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Stops the die temperature measurement.<br />
<br />
Die temperature measurement is stopped by disabling the sensor using <em>TSE_EN</em> bit of <em>ANATSECTRL</em> register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gaba2aa44ad65c101852033173e2fc9949">XMC_SCU_StartTempMeasurement()</a>, <a class="el" href="group___s_c_u.html#ga0f600fa31f024ec9d8e0c17fc767772f">XMC_SCU_SetRawTempLimits()</a>, <a class="el" href="group___s_c_u.html#ga71c4f02eb6036f0d3a13af5e10bf56cc">XMC_SCU_GetTemperature()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gab79580e5b6decc4f6ecce14be9efe17d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_SupplyMonitorInit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___s_c_u___s_u_p_p_l_y_m_o_n_i_t_o_r__t.html">XMC_SCU_SUPPLYMONITOR_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to data structure consisting voltage monitoring block configuration.<br />
 <b>Range:</b> Use type <a class="el" href="struct_x_m_c___s_c_u___s_u_p_p_l_y_m_o_n_i_t_o_r__t.html">XMC_SCU_SUPPLYMONITOR_t</a> for detailed description of structure members.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Initializes power supply monitoring unit.<br />
<br />
Supply voltage monitoring block consist of 2 detectors namely External voltage detector (VDEL) and External brownout detector (BDE) in the EVR that are used to monitor the VDDP. <em>VDEL</em> detector compares the supply voltage against a pre-warning threshold voltage <em>ext_supply_threshold</em>. The threshold level is programmable via register <em>ANAVDEL.VDEL_SELECT</em>. An interrupt if enabled via <em>enable_prewarning_int</em>, will be triggered if a level below this threshold is detected and the flag, VDDPI, in SRRAW register bit is set. Similarly interrupts can be enabled for the events of VCLIP and prewarning, using the structure members, <em>enable_vclip_int</em> and <em>enable_prewarning_int</em>. The handlers for these interrupts have to be explicitly defined using the API <a class="el" href="group___s_c_u.html#ga4ae03c6bcc3ccade266b46d84f7715e6">XMC_SCU_INTERRUPT_SetEventHandler()</a>. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga4ae03c6bcc3ccade266b46d84f7715e6">XMC_SCU_INTERRUPT_SetEventHandler()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gaf60632360634a2f1be0f8af715c03dea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_UnlockProtectedBits </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Unlocks access to protected bit fields of the SCU.<br />
<br />
The bit protection scheme prevents changing selected register bits by unauthorized code. Bit protection scheme can be temporarily(for 32 MCLK cycles) disabled by writing 000000C0H to <em>PASSWD</em> register. By writing this value, the API is setting the <em>MODE</em> bit field to bit protection disabled state. The API waits for the protection to be disabled after changing the <em>MODE</em>.<br />
User can change the values of the protected bit fields within 32 MCLK cycles. After 32 MCLK cycles the lock will be enabled automatically. List of Protected Register Bit Fields are mentioned below. <br />
<table class="doxtable">
<tr>
<td><em>Register</em>  </td><td><em>Bit</em> fields  </td></tr>
<tr>
<td>SCU_CLKCR  </td><td>FDIV, IDIV, PCLKSEL, RTCLKSEL  </td></tr>
<tr>
<td>SCU_CGATSET0  </td><td>All bits  </td></tr>
<tr>
<td>SCU_CGATCLR0  </td><td>All bits  </td></tr>
<tr>
<td>SCU_ANAOFFSET  </td><td>ADJL_OFFSET  </td></tr>
<tr>
<td>VADC0_ACCPROT0  </td><td>All bits  </td></tr>
<tr>
<td>VADC0_ACCPROT1  </td><td>All bits  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gad9ba5dce219ea8390f4aa9f7bc46aafe">XMC_SCU_LockProtectedBits()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Feb 27 2015 10:51:56 for XMC Peripheral Library for XMC1000 Family by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
