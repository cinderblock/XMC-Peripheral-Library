<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>XMC Peripheral Library for XMC1000 Family: VADC</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="IFX_LOGO_4C_medium.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">XMC Peripheral Library for XMC1000 Family
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">VADC<div class="ingroups"><a class="el" href="group___x_m_clib.html">XMC Peripheral Library</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___v_a_d_c___c_h_a_n_n_e_l___c_o_n_f_i_g__t.html">XMC_VADC_CHANNEL_CONFIG_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___v_a_d_c___g_l_o_b_a_l___c_l_a_s_s__t.html">XMC_VADC_GLOBAL_CLASS_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___v_a_d_c___g_l_o_b_a_l___c_l_o_c_k__t.html">XMC_VADC_GLOBAL_CLOCK_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___v_a_d_c___g_l_o_b_a_l___c_o_n_f_i_g__t.html">XMC_VADC_GLOBAL_CONFIG_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___v_a_d_c___g_r_o_u_p___c_l_a_s_s__t.html">XMC_VADC_GROUP_CLASS_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___v_a_d_c___g_r_o_u_p___c_o_n_f_i_g__t.html">XMC_VADC_GROUP_CONFIG_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___v_a_d_c___g_r_o_u_p___e_m_u_x_c_f_g__t.html">XMC_VADC_GROUP_EMUXCFG_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___v_a_d_c___q_u_e_u_e___c_o_n_f_i_g__t.html">XMC_VADC_QUEUE_CONFIG_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___v_a_d_c___q_u_e_u_e___e_n_t_r_y__t.html">XMC_VADC_QUEUE_ENTRY_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___v_a_d_c___r_e_s_u_l_t___c_o_n_f_i_g__t.html">XMC_VADC_RESULT_CONFIG_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___v_a_d_c___s_c_a_n___c_o_n_f_i_g__t.html">XMC_VADC_SCAN_CONFIG_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga0ee2c29ae299c63136472283e087a9a3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga0ee2c29ae299c63136472283e087a9a3">XMC_VADC_MAJOR_VERSION</a>&#160;&#160;&#160;(1U)</td></tr>
<tr class="separator:ga0ee2c29ae299c63136472283e087a9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5597a51a50125e6e64579f45f0a71ed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gaa5597a51a50125e6e64579f45f0a71ed">XMC_VADC_MINOR_VERSION</a>&#160;&#160;&#160;(0U)</td></tr>
<tr class="separator:gaa5597a51a50125e6e64579f45f0a71ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5493b6e76383802d08a3a1b8198e566e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga5493b6e76383802d08a3a1b8198e566e">XMC_VADC_NUM_CHANNELS_PER_GROUP</a>&#160;&#160;&#160;(8U)</td></tr>
<tr class="separator:ga5493b6e76383802d08a3a1b8198e566e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga744e76f616721ca88a701c042d637ab3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga744e76f616721ca88a701c042d637ab3">XMC_VADC_PATCH_VERSION</a>&#160;&#160;&#160;(2U)</td></tr>
<tr class="separator:ga744e76f616721ca88a701c042d637ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga5df621dbf8385ce88a2fbe632a75d02d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_x_m_c___v_a_d_c___s_c_a_n___c_o_n_f_i_g__t.html">XMC_VADC_SCAN_CONFIG_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga5df621dbf8385ce88a2fbe632a75d02d">XMC_VADC_BACKGROUND_CONFIG_t</a></td></tr>
<tr class="separator:ga5df621dbf8385ce88a2fbe632a75d02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11a8b12d7d98d3a9b81c95f9d5c671c4"><td class="memItemLeft" align="right" valign="top">typedef SHS_Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga11a8b12d7d98d3a9b81c95f9d5c671c4">XMC_VADC_GLOBAL_SHS_t</a></td></tr>
<tr class="separator:ga11a8b12d7d98d3a9b81c95f9d5c671c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cc559b855e4da85ee2f48bcd98405cb"><td class="memItemLeft" align="right" valign="top">typedef VADC_GLOBAL_TypeDef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a></td></tr>
<tr class="separator:ga8cc559b855e4da85ee2f48bcd98405cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cab39abba3ecb096d57ab19b5774800"><td class="memItemLeft" align="right" valign="top">typedef VADC_G_TypeDef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a></td></tr>
<tr class="separator:ga1cab39abba3ecb096d57ab19b5774800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb07d5ea1ef8b662d9550d22944825d4"><td class="memItemLeft" align="right" valign="top">typedef uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gadb07d5ea1ef8b662d9550d22944825d4">XMC_VADC_RESULT_SIZE_t</a></td></tr>
<tr class="separator:gadb07d5ea1ef8b662d9550d22944825d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga32e761497c835cb7995991380b8b9676"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga32e761497c835cb7995991380b8b9676">XMC_VADC_CHANNEL_ALIAS_t</a> </td></tr>
<tr class="separator:ga32e761497c835cb7995991380b8b9676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69fe77fd05cfd4a502f14becf6352cea"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga69fe77fd05cfd4a502f14becf6352cea">XMC_VADC_CHANNEL_BOUNDARY_CONDITION_t</a> { <br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga69fe77fd05cfd4a502f14becf6352ceaa12e3fcda7b15fb19e8a24875dc4e140a">XMC_VADC_CHANNEL_BOUNDARY_CONDITION_ABOVE_BAND</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga69fe77fd05cfd4a502f14becf6352ceaa37e4c015407377c2514bd9c44c4d6662">XMC_VADC_CHANNEL_BOUNDARY_CONDITION_BELOW_BAND</a>
<br />
 }</td></tr>
<tr class="separator:ga69fe77fd05cfd4a502f14becf6352cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga203ae2271679fb3e05d185a6bd14b8b2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga203ae2271679fb3e05d185a6bd14b8b2">XMC_VADC_CHANNEL_BOUNDARY_t</a> { <br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga203ae2271679fb3e05d185a6bd14b8b2a2eb22e6976e5553aaacea29538beda6b">XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND0</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga203ae2271679fb3e05d185a6bd14b8b2a103e8fab52a5fe949383b59872d02069">XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND1</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga203ae2271679fb3e05d185a6bd14b8b2addb07a657e568468242cd7f4d6b37575">XMC_VADC_CHANNEL_BOUNDARY_GLOBAL_BOUND0</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga203ae2271679fb3e05d185a6bd14b8b2add5718928c0d3516f42886d6c96fe790">XMC_VADC_CHANNEL_BOUNDARY_GLOBAL_BOUND1</a>
<br />
 }</td></tr>
<tr class="separator:ga203ae2271679fb3e05d185a6bd14b8b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91049cf62e24988e2df8554af78e2183"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga91049cf62e24988e2df8554af78e2183">XMC_VADC_CHANNEL_BWDCH_t</a> { <br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga91049cf62e24988e2df8554af78e2183a6557c82bb5f3f79333dc0f5adf72bb40">XMC_VADC_CHANNEL_BWDCH_VAGND</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga91049cf62e24988e2df8554af78e2183ad30d5559ec906982f98c5c3b9f3a2149">XMC_VADC_CHANNEL_BWDCH_VAREF</a>
<br />
 }</td></tr>
<tr class="separator:ga91049cf62e24988e2df8554af78e2183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0da7a93877a25398b4e70482b85acd03"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga0da7a93877a25398b4e70482b85acd03">XMC_VADC_CHANNEL_CONV_t</a> { <br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga0da7a93877a25398b4e70482b85acd03a01d1d18f4ea33aae01eb486660393989">XMC_VADC_CHANNEL_CONV_GROUP_CLASS0</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga0da7a93877a25398b4e70482b85acd03aa39fbfa369d7a906592f7849e58298a2">XMC_VADC_CHANNEL_CONV_GROUP_CLASS1</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga0da7a93877a25398b4e70482b85acd03a6092acad2d6d9493846dbd0c2ac67daf">XMC_VADC_CHANNEL_CONV_GLOBAL_CLASS0</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga0da7a93877a25398b4e70482b85acd03a17cadc6c0c0772e937e23f1ad1818264">XMC_VADC_CHANNEL_CONV_GLOBAL_CLASS1</a>
<br />
 }</td></tr>
<tr class="separator:ga0da7a93877a25398b4e70482b85acd03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b6bf4c15562eef67deac95cb36a48d6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga1b6bf4c15562eef67deac95cb36a48d6">XMC_VADC_CHANNEL_EVGEN_t</a> { <br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga1b6bf4c15562eef67deac95cb36a48d6a84a7270450c56954fea5768f8dfd9f1a">XMC_VADC_CHANNEL_EVGEN_NEVER</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga1b6bf4c15562eef67deac95cb36a48d6a81136e28dae1a2b4b27184f47b197199">XMC_VADC_CHANNEL_EVGEN_INBOUND</a> = 1U, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga1b6bf4c15562eef67deac95cb36a48d6a13b50b90ecfc83823ebd41d6399078af">XMC_VADC_CHANNEL_EVGEN_COMPHIGH</a> = 1U, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga1b6bf4c15562eef67deac95cb36a48d6a67fa97a42d92971a0628e4c96102e602">XMC_VADC_CHANNEL_EVGEN_OUTBOUND</a> = 2U, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga1b6bf4c15562eef67deac95cb36a48d6a26977d4681508972cfa75c3b49be7ea9">XMC_VADC_CHANNEL_EVGEN_COMPLOW</a> = 2U, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga1b6bf4c15562eef67deac95cb36a48d6a9743b4856f1e187c9143dad7613defde">XMC_VADC_CHANNEL_EVGEN_ALWAYS</a> = 3U
<br />
 }</td></tr>
<tr class="separator:ga1b6bf4c15562eef67deac95cb36a48d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0c1eb7f8d8743b6b98ebfe8acd14e28"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gab0c1eb7f8d8743b6b98ebfe8acd14e28">XMC_VADC_CHANNEL_REF_t</a> { <br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggab0c1eb7f8d8743b6b98ebfe8acd14e28aca253c1b3d320840ed1d64e5791a69a4">XMC_VADC_CHANNEL_REF_INTREF</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggab0c1eb7f8d8743b6b98ebfe8acd14e28a4b8c8f8bfbbd58dcf804d166f159a654">XMC_VADC_CHANNEL_REF_ALT_CH0</a>
<br />
 }</td></tr>
<tr class="separator:gab0c1eb7f8d8743b6b98ebfe8acd14e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f7e6983d71750230e15684a2dc0cf12"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga9f7e6983d71750230e15684a2dc0cf12">XMC_VADC_CONVMODE_t</a> { <br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga9f7e6983d71750230e15684a2dc0cf12a92a1dd71052d7784f1b2325a3e14df70">XMC_VADC_CONVMODE_12BIT</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga9f7e6983d71750230e15684a2dc0cf12af7a5c377d4788520327c0822e0ccd18b">XMC_VADC_CONVMODE_10BIT</a> = 1, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga9f7e6983d71750230e15684a2dc0cf12a787485b122181ae78b66c8e9e56fa0a7">XMC_VADC_CONVMODE_8BIT</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga9f7e6983d71750230e15684a2dc0cf12a09e44e2e8dc7cbb1442aafb8f3f95c99">XMC_VADC_CONVMODE_FASTCOMPARE</a> = 5
<br />
 }</td></tr>
<tr class="separator:ga9f7e6983d71750230e15684a2dc0cf12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff5ca81d747517a6420fea34642c6778"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gaff5ca81d747517a6420fea34642c6778">XMC_VADC_DMM_t</a> { <br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggaff5ca81d747517a6420fea34642c6778a1bd4f88d1ae65dd412b2bea7084ac6ea">XMC_VADC_DMM_REDUCTION_MODE</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggaff5ca81d747517a6420fea34642c6778aed21d04bf248f50ed8284bdc8d82639a">XMC_VADC_DMM_FILTERING_MODE</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggaff5ca81d747517a6420fea34642c6778a721c65e6d4d9f3a61595b78f70d4e190">XMC_VADC_DMM_DIFFERENCE_MODE</a>
<br />
 }</td></tr>
<tr class="separator:gaff5ca81d747517a6420fea34642c6778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42e972915a3d2ac3b46847a4d5228c64"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga42e972915a3d2ac3b46847a4d5228c64">XMC_VADC_FAST_COMPARE_t</a> { <br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga42e972915a3d2ac3b46847a4d5228c64a60b1cf2b6fdff4aee40cece2db973494">XMC_VADC_FAST_COMPARE_LOW</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga42e972915a3d2ac3b46847a4d5228c64a17cb1fe0e80b3f5abc52c0b9c060a36b">XMC_VADC_FAST_COMPARE_HIGH</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga42e972915a3d2ac3b46847a4d5228c64ac11d5afc7241581ac99588899ff1d555">XMC_VADC_FAST_COMPARE_UNKNOWN</a>
<br />
 }</td></tr>
<tr class="separator:ga42e972915a3d2ac3b46847a4d5228c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa16f1136a4a4efddcd67ebd5fc69bc9f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gaa16f1136a4a4efddcd67ebd5fc69bc9f">XMC_VADC_GATE_INPUT_SELECT_t</a> { <br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggaa16f1136a4a4efddcd67ebd5fc69bc9fa628fa2a0ae62f6676d9f0aa6e6c78f34">XMC_VADC_REQ_GT_A</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggaa16f1136a4a4efddcd67ebd5fc69bc9fa19af54717bfaa667ea4fd277bd9b1363">XMC_VADC_REQ_GT_B</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggaa16f1136a4a4efddcd67ebd5fc69bc9faf9002b27a33b94fcbb01283f26a9af2f">XMC_VADC_REQ_GT_C</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggaa16f1136a4a4efddcd67ebd5fc69bc9fa19a4b78111378dabcc5b6cfc784f12bf">XMC_VADC_REQ_GT_D</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggaa16f1136a4a4efddcd67ebd5fc69bc9fa31eb3921627e7f9235d728ed7b3c5c55">XMC_VADC_REQ_GT_E</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggaa16f1136a4a4efddcd67ebd5fc69bc9fac5ad2424cc03a834d6c4b8ecd1588795">XMC_VADC_REQ_GT_F</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggaa16f1136a4a4efddcd67ebd5fc69bc9fac427fc9bece629f5ad3534c08ba60477">XMC_VADC_REQ_GT_G</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggaa16f1136a4a4efddcd67ebd5fc69bc9fa949e53a7798ed7e81e4441d45da8e584">XMC_VADC_REQ_GT_H</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggaa16f1136a4a4efddcd67ebd5fc69bc9fa604981cad23be4290b7186a999670de1">XMC_VADC_REQ_GT_I</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggaa16f1136a4a4efddcd67ebd5fc69bc9fad5640a3b1c65f8b13eb19b8a48bff0b1">XMC_VADC_REQ_GT_J</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggaa16f1136a4a4efddcd67ebd5fc69bc9fa39fff78f06b392778b82e5865ea30c19">XMC_VADC_REQ_GT_K</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggaa16f1136a4a4efddcd67ebd5fc69bc9fa58a6afc1fb1a441196de4c2010ee9fa9">XMC_VADC_REQ_GT_L</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggaa16f1136a4a4efddcd67ebd5fc69bc9faa3ddf0b32c2642cddd92f5a7062eb0f7">XMC_VADC_REQ_GT_M</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggaa16f1136a4a4efddcd67ebd5fc69bc9fa37a52e037bb5ef38e0843cabd63637e9">XMC_VADC_REQ_GT_N</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggaa16f1136a4a4efddcd67ebd5fc69bc9faaa030baffac71a32d53b77369fc5137a">XMC_VADC_REQ_GT_O</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggaa16f1136a4a4efddcd67ebd5fc69bc9fae36d43191eba009ea267acc503d8524f">XMC_VADC_REQ_GT_P</a>
<br />
 }</td></tr>
<tr class="separator:gaa16f1136a4a4efddcd67ebd5fc69bc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4db02e3b835b8cad941ab60ae288f8c8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga4db02e3b835b8cad941ab60ae288f8c8">XMC_VADC_GATEMODE_t</a> { <br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga4db02e3b835b8cad941ab60ae288f8c8ac913472cb9094d0ad24cb25df3a42ede">XMC_VADC_GATEMODE_BLOCK</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga4db02e3b835b8cad941ab60ae288f8c8a49069b53946c883dedc6c59dbf67dae8">XMC_VADC_GATEMODE_IGNORE</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga4db02e3b835b8cad941ab60ae288f8c8a7c7672639ef846098badaa1273b23a7b">XMC_VADC_GATEMODE_ACTIVEHIGH</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga4db02e3b835b8cad941ab60ae288f8c8a6c503bea41d82b4d2b00bbbdc1d39ac6">XMC_VADC_GATEMODE_ACTIVELOW</a>
<br />
 }</td></tr>
<tr class="separator:ga4db02e3b835b8cad941ab60ae288f8c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa69659f0a647c58e6a0c434759a5f358"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gaa69659f0a647c58e6a0c434759a5f358">XMC_VADC_GLOBAL_EVENT_t</a> { <br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggaa69659f0a647c58e6a0c434759a5f358ac6d9b471959c249288e9eb86eb874fe3">XMC_VADC_GLOBAL_EVENT_BKGNDSOURCE</a> = VADC_GLOBEFLAG_SEVGLB_Msk, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggaa69659f0a647c58e6a0c434759a5f358acd0bc4bf1a88d34dde532f8c597b3de8">XMC_VADC_GLOBAL_EVENT_RESULT</a> = VADC_GLOBEFLAG_REVGLB_Msk
<br />
 }</td></tr>
<tr class="separator:gaa69659f0a647c58e6a0c434759a5f358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeab802d00faa3aad6269c620a15a381b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gaeab802d00faa3aad6269c620a15a381b">XMC_VADC_GROUP_ARBMODE_t</a> { <br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggaeab802d00faa3aad6269c620a15a381ba2f3e98ed8180a3561aaab67e7e5bd582">XMC_VADC_GROUP_ARBMODE_ALWAYS</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggaeab802d00faa3aad6269c620a15a381baca890d7bfd6eadf36d582bde6f3e7c19">XMC_VADC_GROUP_ARBMODE_ONDEMAND</a>
<br />
 }</td></tr>
<tr class="separator:gaeab802d00faa3aad6269c620a15a381b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga017b3c6d3e14d46d5cf60602f262659d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga017b3c6d3e14d46d5cf60602f262659d">XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_t</a> { <br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga017b3c6d3e14d46d5cf60602f262659da247876a12a1ec728b08ad22a23461dd0">XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_DISABLED</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga017b3c6d3e14d46d5cf60602f262659da1c42beaee2cb5656833697e2b75a9fe5">XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_ENABLED</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga017b3c6d3e14d46d5cf60602f262659da3ec5736710604ff2d447c09d0ed521da">XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_ENABLED_ACTIVE_LOW</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga017b3c6d3e14d46d5cf60602f262659da40e92524506d5b3ed3654f83be18da33">XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_ENABLED_ACTIVE_HIGH</a>
<br />
 }</td></tr>
<tr class="separator:ga017b3c6d3e14d46d5cf60602f262659d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf393a8c811d7ee6601688797e616646"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gadf393a8c811d7ee6601688797e616646">XMC_VADC_GROUP_CONV_t</a> { <br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggadf393a8c811d7ee6601688797e616646ac78caa8ace779a519cce8e2b005e5184">XMC_VADC_GROUP_CONV_STD</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggadf393a8c811d7ee6601688797e616646a87e29eeb94abb3bcbc4075cda129d8a9">XMC_VADC_GROUP_CONV_EMUX</a>
<br />
 }</td></tr>
<tr class="separator:gadf393a8c811d7ee6601688797e616646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedf62af4b76d15e91f0786165ec34fc2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gaedf62af4b76d15e91f0786165ec34fc2">XMC_VADC_GROUP_EMUXCODE_t</a> { <br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggaedf62af4b76d15e91f0786165ec34fc2a099d6b915907a8f95b4e7cd1f3735765">XMC_VADC_GROUP_EMUXCODE_BINARY</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggaedf62af4b76d15e91f0786165ec34fc2a0d8e365e9f36b5fe5fd3e4c935e90e2f">XMC_VADC_GROUP_EMUXCODE_GRAY</a>
<br />
 }</td></tr>
<tr class="separator:gaedf62af4b76d15e91f0786165ec34fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9942639fc1d53fc2335990884b394ba"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gab9942639fc1d53fc2335990884b394ba">XMC_VADC_GROUP_EMUXMODE_t</a> { <br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggab9942639fc1d53fc2335990884b394baa1bbd7dfdc24faec8d522a758ae7fe880">XMC_VADC_GROUP_EMUXMODE_SWCTRL</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggab9942639fc1d53fc2335990884b394baaf8c2244a73ee118a28dcb5bf8ac51685">XMC_VADC_GROUP_EMUXMODE_STEADYMODE</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggab9942639fc1d53fc2335990884b394baaad4e4c8354234a5c17a3aef01c761138">XMC_VADC_GROUP_EMUXMODE_SINGLEMODE</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggab9942639fc1d53fc2335990884b394baa59b2f18f53866fc7d0cf76f34cea5939">XMC_VADC_GROUP_EMUXMODE_SEQUENCEMODE</a>
<br />
 }</td></tr>
<tr class="separator:gab9942639fc1d53fc2335990884b394ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a37056c647c7622f8102dae982336eb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga2a37056c647c7622f8102dae982336eb">XMC_VADC_GROUP_INDEX_t</a> </td></tr>
<tr class="separator:ga2a37056c647c7622f8102dae982336eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14a1cbb73bf2a92a3321aea14488f354"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga14a1cbb73bf2a92a3321aea14488f354">XMC_VADC_GROUP_IRQ_t</a> { <br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga14a1cbb73bf2a92a3321aea14488f354a063619a30aa8bb3d0bb37b0d32684d43">XMC_VADC_GROUP_IRQ_KERNEL</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga14a1cbb73bf2a92a3321aea14488f354a674afc8864f13a19d6a067c517fd8f7d">XMC_VADC_GROUP_IRQ_SHARED</a>
<br />
 }</td></tr>
<tr class="separator:ga14a1cbb73bf2a92a3321aea14488f354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7226349aef79a52f614eb5e75e3f55d9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga7226349aef79a52f614eb5e75e3f55d9">XMC_VADC_GROUP_POWERMODE_t</a> { <br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga7226349aef79a52f614eb5e75e3f55d9a498fe251b61022633a09f361b4841586">XMC_VADC_GROUP_POWERMODE_OFF</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga7226349aef79a52f614eb5e75e3f55d9ae3c0c22d5402543c828f19565cce9e8d">XMC_VADC_GROUP_POWERMODE_RESERVED1</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga7226349aef79a52f614eb5e75e3f55d9a135622a1a6f56a7b8a88b55d38e973ca">XMC_VADC_GROUP_POWERMODE_RESERVED2</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga7226349aef79a52f614eb5e75e3f55d9a4394cff3deb041f3198a2c7c9ffaa25a">XMC_VADC_GROUP_POWERMODE_NORMAL</a>
<br />
 }</td></tr>
<tr class="separator:ga7226349aef79a52f614eb5e75e3f55d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e8bcdf4c424a70b70e93368f1ef0021"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga9e8bcdf4c424a70b70e93368f1ef0021">XMC_VADC_GROUP_RS_PRIORITY_t</a> { <br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga9e8bcdf4c424a70b70e93368f1ef0021ab10f26da7901b950046a056f9c0fa145">XMC_VADC_GROUP_RS_PRIORITY_0</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga9e8bcdf4c424a70b70e93368f1ef0021aeaaca134d7c9e0b3e7fd359fb0597675">XMC_VADC_GROUP_RS_PRIORITY_1</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga9e8bcdf4c424a70b70e93368f1ef0021ab5e5ad7cfcc2afad2f6338221786812a">XMC_VADC_GROUP_RS_PRIORITY_2</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga9e8bcdf4c424a70b70e93368f1ef0021a76caa4614542b8ecb59feda23d6fa1df">XMC_VADC_GROUP_RS_PRIORITY_3</a>
<br />
 }</td></tr>
<tr class="separator:ga9e8bcdf4c424a70b70e93368f1ef0021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4effb949346537c7a515c4f2ff542df5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga4effb949346537c7a515c4f2ff542df5">XMC_VADC_GROUP_STATE_t</a> { <br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga4effb949346537c7a515c4f2ff542df5a59cb41943a0b5ba6e7e6abcf95ea6775">XMC_VADC_GROUP_STATE_IDLE</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga4effb949346537c7a515c4f2ff542df5ae99f75960aa2617f81cbceb8346b24f3">XMC_VADC_GROUP_STATE_BUSY</a>
<br />
 }</td></tr>
<tr class="separator:ga4effb949346537c7a515c4f2ff542df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5db9760a1339267ae158e21ee3047859"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga5db9760a1339267ae158e21ee3047859">XMC_VADC_RESULT_ALIGN_t</a> { <br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga5db9760a1339267ae158e21ee3047859ade5aecb252a5ad2723252659ee392551">XMC_VADC_RESULT_ALIGN_LEFT</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga5db9760a1339267ae158e21ee3047859aa99c3eed20b4f1aea940ba4fb2f981e7">XMC_VADC_RESULT_ALIGN_RIGHT</a>
<br />
 }</td></tr>
<tr class="separator:ga5db9760a1339267ae158e21ee3047859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bf69f8d48c6280914a3a07c3330fd00"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga1bf69f8d48c6280914a3a07c3330fd00">XMC_VADC_SCAN_LOAD_t</a> { <br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga1bf69f8d48c6280914a3a07c3330fd00a5c3cd3659dbddaa0ef9804a09b4e868c">XMC_VADC_SCAN_LOAD_OVERWRITE</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga1bf69f8d48c6280914a3a07c3330fd00a958c98fcf8f114f4d2fc3090eb8a9a4d">XMC_VADC_SCAN_LOAD_COMBINE</a>
<br />
 }</td></tr>
<tr class="separator:ga1bf69f8d48c6280914a3a07c3330fd00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbab535e1de48116e5461c2ce7ff5077"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gacbab535e1de48116e5461c2ce7ff5077">XMC_VADC_SCAN_TYPE_t</a> { <br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggacbab535e1de48116e5461c2ce7ff5077adbbf7a9b221f5f9e373e6ecb770f64ce">XMC_VADC_SCAN_TYPE_GROUPSCAN</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggacbab535e1de48116e5461c2ce7ff5077a4f944a59ed1cc8477ce269673a38accb">XMC_VADC_SCAN_TYPE_BACKGROUND</a>
<br />
 }</td></tr>
<tr class="separator:gacbab535e1de48116e5461c2ce7ff5077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab518b0c522cae78b7434dfa327a540b1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gab518b0c522cae78b7434dfa327a540b1">XMC_VADC_SR_t</a> { <br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggab518b0c522cae78b7434dfa327a540b1ab464629a3f5c67a4e6f9b738f2e02bb4">XMC_VADC_SR_GROUP_SR0</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggab518b0c522cae78b7434dfa327a540b1ab9c251a1ccf84c51844de7f15477c7d7">XMC_VADC_SR_GROUP_SR1</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggab518b0c522cae78b7434dfa327a540b1a5b88744b75b1e4a54fd1cc18e02cbe09">XMC_VADC_SR_GROUP_SR2</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggab518b0c522cae78b7434dfa327a540b1a12d1401a5acfec2e47607d71d559e453">XMC_VADC_SR_GROUP_SR3</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggab518b0c522cae78b7434dfa327a540b1ab49d758848e891936f2469b28c2f9ec5">XMC_VADC_SR_SHARED_SR0</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggab518b0c522cae78b7434dfa327a540b1a89d85bc678a0e381e9180468ab543900">XMC_VADC_SR_SHARED_SR1</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggab518b0c522cae78b7434dfa327a540b1aa8428db76657e0711415efe99767ef95">XMC_VADC_SR_SHARED_SR2</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggab518b0c522cae78b7434dfa327a540b1a08fe0b7046ea542383fe053bb18c293a">XMC_VADC_SR_SHARED_SR3</a>
<br />
 }</td></tr>
<tr class="separator:gab518b0c522cae78b7434dfa327a540b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga227aaa91c89c64c8402c869469276eb9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga227aaa91c89c64c8402c869469276eb9">XMC_VADC_STARTMODE_t</a> { <br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga227aaa91c89c64c8402c869469276eb9a603a2da364137de801452b7680f9b1c0">XMC_VADC_STARTMODE_WFS</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga227aaa91c89c64c8402c869469276eb9ab39b9f2a959b6ec9ac138e7c020c9aae">XMC_VADC_STARTMODE_CIR</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#gga227aaa91c89c64c8402c869469276eb9ad8450a9b8f9173ce4bb46c1f3d453e7b">XMC_VADC_STARTMODE_CNR</a>
<br />
 }</td></tr>
<tr class="separator:ga227aaa91c89c64c8402c869469276eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabac544a8f57b163dff69b444ed5f1d87"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gabac544a8f57b163dff69b444ed5f1d87">XMC_VADC_STATUS_t</a> { <br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggabac544a8f57b163dff69b444ed5f1d87a2803f6adfdcdca2268420d41686991bb">XMC_VADC_STATUS_SUCCESS</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggabac544a8f57b163dff69b444ed5f1d87a3634aa8e895380c02d16fba23f4212ec">XMC_VADC_STATUS_ERROR</a>
<br />
 }</td></tr>
<tr class="separator:gabac544a8f57b163dff69b444ed5f1d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabd0d22cd15f13e6e49809a3b811b241"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gaabd0d22cd15f13e6e49809a3b811b241">XMC_VADC_TRIGGER_EDGE_t</a> { <br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggaabd0d22cd15f13e6e49809a3b811b241a6f9b8e9ab9a1fa139050f87bf576ed85">XMC_VADC_TRIGGER_EDGE_NONE</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggaabd0d22cd15f13e6e49809a3b811b241a6c2f089ee48ddbe0709370aaff7e2eaa">XMC_VADC_TRIGGER_EDGE_FALLING</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggaabd0d22cd15f13e6e49809a3b811b241a8d7edb1df35ead7a90fd5640861228a5">XMC_VADC_TRIGGER_EDGE_RISING</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggaabd0d22cd15f13e6e49809a3b811b241a18d01d02320eb514e85edc66cd4b53e4">XMC_VADC_TRIGGER_EDGE_ANY</a>
<br />
 }</td></tr>
<tr class="separator:gaabd0d22cd15f13e6e49809a3b811b241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab71bdae1d928ee308430626a761eab97"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gab71bdae1d928ee308430626a761eab97">XMC_VADC_TRIGGER_INPUT_SELECT_t</a> { <br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggab71bdae1d928ee308430626a761eab97aa747e2d141cbdc20050f43294940282b">XMC_VADC_REQ_TR_A</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggab71bdae1d928ee308430626a761eab97a53e03e8e843f703d055a610b78291da2">XMC_VADC_REQ_TR_B</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggab71bdae1d928ee308430626a761eab97a7adc7d31060d1dcb69c97d78d9ebda36">XMC_VADC_REQ_TR_C</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggab71bdae1d928ee308430626a761eab97a816f02d251e2477463ca5e6dcca79f68">XMC_VADC_REQ_TR_D</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggab71bdae1d928ee308430626a761eab97ab62b73b50451cf3260dbb42164713bb1">XMC_VADC_REQ_TR_E</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggab71bdae1d928ee308430626a761eab97aa200440561888cab0204fb632adf0e17">XMC_VADC_REQ_TR_F</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggab71bdae1d928ee308430626a761eab97ac690682200ba8fc59f106563d4603998">XMC_VADC_REQ_TR_G</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggab71bdae1d928ee308430626a761eab97a4620708e2388498ad0efc07586fd7e30">XMC_VADC_REQ_TR_H</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggab71bdae1d928ee308430626a761eab97a29a5bc3d4ce50b42c98b568fa6d76d09">XMC_VADC_REQ_TR_I</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggab71bdae1d928ee308430626a761eab97a8676bf7270afed2fa20b8fe6b303829d">XMC_VADC_REQ_TR_J</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggab71bdae1d928ee308430626a761eab97a3fc091b811ad27e5aee89237e43b93c9">XMC_VADC_REQ_TR_K</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggab71bdae1d928ee308430626a761eab97ac94b58fec8333f270cb7c56791d1b957">XMC_VADC_REQ_TR_L</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggab71bdae1d928ee308430626a761eab97a495470ce5d64a1a25ba5709e5aa210b6">XMC_VADC_REQ_TR_M</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggab71bdae1d928ee308430626a761eab97a51236825d82a7f0ecc7110637f2e05e7">XMC_VADC_REQ_TR_N</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggab71bdae1d928ee308430626a761eab97aae6010c1367966e9c37248c877612b84">XMC_VADC_REQ_TR_O</a>, 
<br />
&#160;&#160;<a class="el" href="group___v_a_d_c.html#ggab71bdae1d928ee308430626a761eab97aeb73c906f67594383011749f10240722">XMC_VADC_REQ_TR_P</a>
<br />
 }</td></tr>
<tr class="separator:gab71bdae1d928ee308430626a761eab97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7039edfc0951575e3dcb158580452e8f"><td class="memItemLeft" align="right" valign="top">XMC_DRIVER_VERSION_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga7039edfc0951575e3dcb158580452e8f">XMC_VADC_GetDriverVersion</a> (void)</td></tr>
<tr class="separator:ga7039edfc0951575e3dcb158580452e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf9c9021b0e1d538b9d6e6571a4dc2cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gadf9c9021b0e1d538b9d6e6571a4dc2cd">XMC_VADC_GLOBAL_BackgndAddMultipleChannels</a> (<a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const global_ptr, const uint32_t grp_num, const uint32_t ch_mask)</td></tr>
<tr class="separator:gadf9c9021b0e1d538b9d6e6571a4dc2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04933ff6939f277ded8a4c19c3ef8d38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga04933ff6939f277ded8a4c19c3ef8d38">XMC_VADC_GLOBAL_BackgroundAbortSequence</a> (<a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const global_ptr)</td></tr>
<tr class="separator:ga04933ff6939f277ded8a4c19c3ef8d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67c4d922e3b0a4abbaefde613a2a3c00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga67c4d922e3b0a4abbaefde613a2a3c00">XMC_VADC_GLOBAL_BackgroundAddChannelToSequence</a> (<a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const global_ptr, const uint32_t grp_num, const uint32_t ch_num)</td></tr>
<tr class="separator:ga67c4d922e3b0a4abbaefde613a2a3c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga075844a45e021e56d4ee6e17a60dba02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga075844a45e021e56d4ee6e17a60dba02">XMC_VADC_GLOBAL_BackgroundClearReqSrcEvent</a> (<a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const global_ptr)</td></tr>
<tr class="separator:ga075844a45e021e56d4ee6e17a60dba02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf73c916feb89e889cf848fdbe6dd20e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gaf73c916feb89e889cf848fdbe6dd20e0">XMC_VADC_GLOBAL_BackgroundDisableContinuousMode</a> (<a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const global_ptr)</td></tr>
<tr class="separator:gaf73c916feb89e889cf848fdbe6dd20e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2a92785dd1bfeda948728c15c7205f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gaa2a92785dd1bfeda948728c15c7205f7">XMC_VADC_GLOBAL_BackgroundDisableExternalTrigger</a> (<a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const global_ptr)</td></tr>
<tr class="separator:gaa2a92785dd1bfeda948728c15c7205f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3242cf2af1c5d920154c06ecf1aaff72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga3242cf2af1c5d920154c06ecf1aaff72">XMC_VADC_GLOBAL_BackgroundEnableContinuousMode</a> (<a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const global_ptr)</td></tr>
<tr class="separator:ga3242cf2af1c5d920154c06ecf1aaff72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad94ac8b683df176e39944d0d2aff7501"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gad94ac8b683df176e39944d0d2aff7501">XMC_VADC_GLOBAL_BackgroundEnableExternalTrigger</a> (<a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const global_ptr)</td></tr>
<tr class="separator:gad94ac8b683df176e39944d0d2aff7501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga424f2cfadf7566780a290be6b34a63cd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga424f2cfadf7566780a290be6b34a63cd">XMC_VADC_GLOBAL_BackgroundGetNumChannelsPending</a> (<a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const global_ptr)</td></tr>
<tr class="separator:ga424f2cfadf7566780a290be6b34a63cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c6d9214be3444f9e6fc7944523c6b09"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga2c6d9214be3444f9e6fc7944523c6b09">XMC_VADC_GLOBAL_BackgroundGetReqSrcEventStatus</a> (<a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const global_ptr)</td></tr>
<tr class="separator:ga2c6d9214be3444f9e6fc7944523c6b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a669e00443f963546fdbe05a1eb0084"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga2a669e00443f963546fdbe05a1eb0084">XMC_VADC_GLOBAL_BackgroundInit</a> (<a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const global_ptr, const <a class="el" href="group___v_a_d_c.html#ga5df621dbf8385ce88a2fbe632a75d02d">XMC_VADC_BACKGROUND_CONFIG_t</a> *config)</td></tr>
<tr class="separator:ga2a669e00443f963546fdbe05a1eb0084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6e756229d4b42d79c942f594895e880"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gad6e756229d4b42d79c942f594895e880">XMC_VADC_GLOBAL_BackgroundIsChannelPending</a> (<a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const global_ptr, const uint32_t grp_num, const uint32_t ch_num)</td></tr>
<tr class="separator:gad6e756229d4b42d79c942f594895e880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacba7a4847be06bb2e71493eabf9bbb69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gacba7a4847be06bb2e71493eabf9bbb69">XMC_VADC_GLOBAL_BackgroundSelectGating</a> (<a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const global_ptr, const uint32_t input_num)</td></tr>
<tr class="separator:gacba7a4847be06bb2e71493eabf9bbb69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dc24406fa9e95d845a8095728dcbce4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga1dc24406fa9e95d845a8095728dcbce4">XMC_VADC_GLOBAL_BackgroundSelectTrigger</a> (<a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const global_ptr, const uint32_t input_num)</td></tr>
<tr class="separator:ga1dc24406fa9e95d845a8095728dcbce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c8708cf159e5c190926e0873f4055ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga8c8708cf159e5c190926e0873f4055ca">XMC_VADC_GLOBAL_BackgroundSetGatingMode</a> (<a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const global_ptr, <a class="el" href="group___v_a_d_c.html#ga4db02e3b835b8cad941ab60ae288f8c8">XMC_VADC_GATEMODE_t</a> mode_sel)</td></tr>
<tr class="separator:ga8c8708cf159e5c190926e0873f4055ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f53b56af0d025239dbbcd80af5a5481"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga7f53b56af0d025239dbbcd80af5a5481">XMC_VADC_GLOBAL_BackgroundSetReqSrcEventInterruptNode</a> (<a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const global_ptr, <a class="el" href="group___v_a_d_c.html#gab518b0c522cae78b7434dfa327a540b1">XMC_VADC_SR_t</a> sr)</td></tr>
<tr class="separator:ga7f53b56af0d025239dbbcd80af5a5481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga599af86b8424e4e378f20dc1952b4cba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga599af86b8424e4e378f20dc1952b4cba">XMC_VADC_GLOBAL_BackgroundTriggerConversion</a> (<a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const global_ptr)</td></tr>
<tr class="separator:ga599af86b8424e4e378f20dc1952b4cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fdfbc995a8b763c210c044d2d979814"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga0fdfbc995a8b763c210c044d2d979814">XMC_VADC_GLOBAL_BackgroundTriggerReqSrcEvent</a> (<a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const global_ptr)</td></tr>
<tr class="separator:ga0fdfbc995a8b763c210c044d2d979814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b17cb1350c5d568783f96f721348928"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga2b17cb1350c5d568783f96f721348928">XMC_VADC_GLOBAL_BindGroupToEMux</a> (<a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const global_ptr, const uint32_t emuxif, const uint32_t group)</td></tr>
<tr class="separator:ga2b17cb1350c5d568783f96f721348928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6a4d9c2ba0621bef3d077e899754bd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gae6a4d9c2ba0621bef3d077e899754bd9">XMC_VADC_GLOBAL_ClearEvent</a> (<a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const global_ptr, const uint32_t event_type)</td></tr>
<tr class="separator:gae6a4d9c2ba0621bef3d077e899754bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5ec0ac1eedfeedd49e8f84e0e1147fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gaf5ec0ac1eedfeedd49e8f84e0e1147fa">XMC_VADC_GLOBAL_ClockInit</a> (<a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const global_ptr, const <a class="el" href="struct_x_m_c___v_a_d_c___g_l_o_b_a_l___c_l_o_c_k__t.html">XMC_VADC_GLOBAL_CLOCK_t</a> *config)</td></tr>
<tr class="separator:gaf5ec0ac1eedfeedd49e8f84e0e1147fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa02b1286238761c5d6c1a42f552463df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gaa02b1286238761c5d6c1a42f552463df">XMC_VADC_GLOBAL_DisableModule</a> (void)</td></tr>
<tr class="separator:gaa02b1286238761c5d6c1a42f552463df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeada77d79207d448a245c39960cdc048"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gaeada77d79207d448a245c39960cdc048">XMC_VADC_GLOBAL_DisableModuleClock</a> (<a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const global_ptr)</td></tr>
<tr class="separator:gaeada77d79207d448a245c39960cdc048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91a285da9e41bf4ef81bec9eef95be57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga91a285da9e41bf4ef81bec9eef95be57">XMC_VADC_GLOBAL_DisablePostCalibration</a> (<a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const global_ptr, uint32_t group_number)</td></tr>
<tr class="separator:ga91a285da9e41bf4ef81bec9eef95be57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fdc0facec70f34cd38d018caca13141"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga3fdc0facec70f34cd38d018caca13141">XMC_VADC_GLOBAL_DisableSleepMode</a> (<a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const global_ptr)</td></tr>
<tr class="separator:ga3fdc0facec70f34cd38d018caca13141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8413b5d67494882776c5500b765424d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga8413b5d67494882776c5500b765424d6">XMC_VADC_GLOBAL_DisableStartupCalibration</a> (<a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const global_ptr)</td></tr>
<tr class="separator:ga8413b5d67494882776c5500b765424d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9751f6e7d01d01dcd69f939cc7acfc48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga9751f6e7d01d01dcd69f939cc7acfc48">XMC_VADC_GLOBAL_EnableModule</a> (void)</td></tr>
<tr class="separator:ga9751f6e7d01d01dcd69f939cc7acfc48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70fe4b872487d7243db7622c3f9b5359"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga70fe4b872487d7243db7622c3f9b5359">XMC_VADC_GLOBAL_EnableModuleClock</a> (<a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const global_ptr)</td></tr>
<tr class="separator:ga70fe4b872487d7243db7622c3f9b5359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10affbd1419c11a15022f6cf6cfc1f64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga10affbd1419c11a15022f6cf6cfc1f64">XMC_VADC_GLOBAL_EnablePostCalibration</a> (<a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const global_ptr, uint32_t group_number)</td></tr>
<tr class="separator:ga10affbd1419c11a15022f6cf6cfc1f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3693d7ff09be4b5594ca160dafb28064"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga3693d7ff09be4b5594ca160dafb28064">XMC_VADC_GLOBAL_EnableSleepMode</a> (<a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const global_ptr)</td></tr>
<tr class="separator:ga3693d7ff09be4b5594ca160dafb28064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e6a5c936529f8bf35c81f662e5a57c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___v_a_d_c.html#ga42e972915a3d2ac3b46847a4d5228c64">XMC_VADC_FAST_COMPARE_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga2e6a5c936529f8bf35c81f662e5a57c9">XMC_VADC_GLOBAL_GetCompareResult</a> (<a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const global_ptr)</td></tr>
<tr class="separator:ga2e6a5c936529f8bf35c81f662e5a57c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ae7ddbf6a4e2bc626ada83bcf72b56a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga7ae7ddbf6a4e2bc626ada83bcf72b56a">XMC_VADC_GLOBAL_GetDetailedResult</a> (<a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const global_ptr)</td></tr>
<tr class="separator:ga7ae7ddbf6a4e2bc626ada83bcf72b56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13f09c6935ff21f3c034199fd3bfe825"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___v_a_d_c.html#gadb07d5ea1ef8b662d9550d22944825d4">XMC_VADC_RESULT_SIZE_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga13f09c6935ff21f3c034199fd3bfe825">XMC_VADC_GLOBAL_GetResult</a> (<a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const global_ptr)</td></tr>
<tr class="separator:ga13f09c6935ff21f3c034199fd3bfe825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a03902554eb8c9ff9fdfb6f3e76dc2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga3a03902554eb8c9ff9fdfb6f3e76dc2c">XMC_VADC_GLOBAL_Init</a> (<a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const global_ptr, const <a class="el" href="struct_x_m_c___v_a_d_c___g_l_o_b_a_l___c_o_n_f_i_g__t.html">XMC_VADC_GLOBAL_CONFIG_t</a> *config)</td></tr>
<tr class="separator:ga3a03902554eb8c9ff9fdfb6f3e76dc2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e65df86680f0bce4057ea37a495445d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga2e65df86680f0bce4057ea37a495445d">XMC_VADC_GLOBAL_InputClassInit</a> (<a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const global_ptr, const <a class="el" href="struct_x_m_c___v_a_d_c___g_l_o_b_a_l___c_l_a_s_s__t.html">XMC_VADC_GLOBAL_CLASS_t</a> config, const <a class="el" href="group___v_a_d_c.html#gadf393a8c811d7ee6601688797e616646">XMC_VADC_GROUP_CONV_t</a> conv_type, const uint32_t set_num)</td></tr>
<tr class="separator:ga2e65df86680f0bce4057ea37a495445d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa30f659438385897376765d156118654"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gaa30f659438385897376765d156118654">XMC_VADC_GLOBAL_ResultInit</a> (<a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const global_ptr, const <a class="el" href="struct_x_m_c___v_a_d_c___r_e_s_u_l_t___c_o_n_f_i_g__t.html">XMC_VADC_RESULT_CONFIG_t</a> *config)</td></tr>
<tr class="separator:gaa30f659438385897376765d156118654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae55dd1c7a50cabe7d188e56e79319dc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gae55dd1c7a50cabe7d188e56e79319dc6">XMC_VADC_GLOBAL_SetBoundaries</a> (<a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const global_ptr, const uint32_t boundary0, const uint32_t boundary1)</td></tr>
<tr class="separator:gae55dd1c7a50cabe7d188e56e79319dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac239d3389baab5175eca043b6ac606b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gac239d3389baab5175eca043b6ac606b8">XMC_VADC_GLOBAL_SetCompareValue</a> (<a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const global_ptr, const <a class="el" href="group___v_a_d_c.html#gadb07d5ea1ef8b662d9550d22944825d4">XMC_VADC_RESULT_SIZE_t</a> compare_val)</td></tr>
<tr class="separator:gac239d3389baab5175eca043b6ac606b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9738610187d2b11716c5faa07e214c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gaa9738610187d2b11716c5faa07e214c7">XMC_VADC_GLOBAL_SetResultEventInterruptNode</a> (<a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const global_ptr, <a class="el" href="group___v_a_d_c.html#gab518b0c522cae78b7434dfa327a540b1">XMC_VADC_SR_t</a> sr)</td></tr>
<tr class="separator:gaa9738610187d2b11716c5faa07e214c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cdce2c0d6b53beb6312c43ccbaee499"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga9cdce2c0d6b53beb6312c43ccbaee499">XMC_VADC_GLOBAL_SHS_EnableAcceleratedMode</a> (<a class="el" href="group___v_a_d_c.html#ga11a8b12d7d98d3a9b81c95f9d5c671c4">XMC_VADC_GLOBAL_SHS_t</a> *const shs_ptr, <a class="el" href="group___v_a_d_c.html#ga2a37056c647c7622f8102dae982336eb">XMC_VADC_GROUP_INDEX_t</a> group_num)</td></tr>
<tr class="separator:ga9cdce2c0d6b53beb6312c43ccbaee499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac97ed253a1995c6a76a03653d267e130"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gac97ed253a1995c6a76a03653d267e130">XMC_VADC_GLOBAL_SHS_SetClockDivider</a> (<a class="el" href="group___v_a_d_c.html#ga11a8b12d7d98d3a9b81c95f9d5c671c4">XMC_VADC_GLOBAL_SHS_t</a> *const shs_ptr, uint8_t divs_value)</td></tr>
<tr class="separator:gac97ed253a1995c6a76a03653d267e130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b3ce19bc8632b14e43be44b92d79539"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga6b3ce19bc8632b14e43be44b92d79539">XMC_VADC_GLOBAL_SHS_SetShortSampleTime</a> (<a class="el" href="group___v_a_d_c.html#ga11a8b12d7d98d3a9b81c95f9d5c671c4">XMC_VADC_GLOBAL_SHS_t</a> *const shs_ptr, <a class="el" href="group___v_a_d_c.html#ga2a37056c647c7622f8102dae982336eb">XMC_VADC_GROUP_INDEX_t</a> group_num, uint8_t sst_value)</td></tr>
<tr class="separator:ga6b3ce19bc8632b14e43be44b92d79539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c267fe37fbdf8654d14f46acf2d3b86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga8c267fe37fbdf8654d14f46acf2d3b86">XMC_VADC_GLOBAL_StartupCalibration</a> (<a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const global_ptr)</td></tr>
<tr class="separator:ga8c267fe37fbdf8654d14f46acf2d3b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4880cd1755d46ad1b0bd775d4e0ac49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gaa4880cd1755d46ad1b0bd775d4e0ac49">XMC_VADC_GLOBAL_TriggerEvent</a> (<a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const global_ptr, const uint32_t event_type)</td></tr>
<tr class="separator:gaa4880cd1755d46ad1b0bd775d4e0ac49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2c5118b682ff5c4820400ea362b3cc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gaf2c5118b682ff5c4820400ea362b3cc7">XMC_VADC_GROUP_AddResultToFifo</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const uint32_t res_reg)</td></tr>
<tr class="separator:gaf2c5118b682ff5c4820400ea362b3cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3058d26882687fd994756615eb7b5b3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga3058d26882687fd994756615eb7b5b3d">XMC_VADC_GROUP_BackgroundDisableArbitrationSlot</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr)</td></tr>
<tr class="separator:ga3058d26882687fd994756615eb7b5b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63f7baff861c509eeb73f7794eff890a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga63f7baff861c509eeb73f7794eff890a">XMC_VADC_GROUP_BackgroundEnableArbitrationSlot</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr)</td></tr>
<tr class="separator:ga63f7baff861c509eeb73f7794eff890a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76846cba41d6ea170992e6b5ea61d957"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga76846cba41d6ea170992e6b5ea61d957">XMC_VADC_GROUP_ChannelClearEvent</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const uint32_t ch_num)</td></tr>
<tr class="separator:ga76846cba41d6ea170992e6b5ea61d957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5c0071a3d6728dad1f4ddcb06f6bed8"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gae5c0071a3d6728dad1f4ddcb06f6bed8">XMC_VADC_GROUP_ChannelGetResultRegister</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const uint32_t ch_num)</td></tr>
<tr class="separator:gae5c0071a3d6728dad1f4ddcb06f6bed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88e0f4deb5ddd8a85c786a6291327fa6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga88e0f4deb5ddd8a85c786a6291327fa6">XMC_VADC_GROUP_ChannelInit</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const uint32_t ch_num, const <a class="el" href="struct_x_m_c___v_a_d_c___c_h_a_n_n_e_l___c_o_n_f_i_g__t.html">XMC_VADC_CHANNEL_CONFIG_t</a> *config)</td></tr>
<tr class="separator:ga88e0f4deb5ddd8a85c786a6291327fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf864b20c64882d1c78712892dbeae965"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gaf864b20c64882d1c78712892dbeae965">XMC_VADC_GROUP_ChannelIsResultOutOfBounds</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const uint32_t ch_num)</td></tr>
<tr class="separator:gaf864b20c64882d1c78712892dbeae965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b2d0baaf1e9113c61ef28c7d45e9feb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga8b2d0baaf1e9113c61ef28c7d45e9feb">XMC_VADC_GROUP_ChannelSetEventInterruptNode</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const uint32_t ch_num, const <a class="el" href="group___v_a_d_c.html#gab518b0c522cae78b7434dfa327a540b1">XMC_VADC_SR_t</a> sr)</td></tr>
<tr class="separator:ga8b2d0baaf1e9113c61ef28c7d45e9feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02ef37668d4c2692d73b9b028202a923"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga02ef37668d4c2692d73b9b028202a923">XMC_VADC_GROUP_ChannelSetInputReference</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const uint32_t ch_num, const <a class="el" href="group___v_a_d_c.html#gab0c1eb7f8d8743b6b98ebfe8acd14e28">XMC_VADC_CHANNEL_REF_t</a> ref)</td></tr>
<tr class="separator:ga02ef37668d4c2692d73b9b028202a923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6db93a7e9cdeb07b7e9ef1d2f34defd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga6db93a7e9cdeb07b7e9ef1d2f34defd5">XMC_VADC_GROUP_ChannelSetResultRegister</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const uint32_t ch_num, const uint32_t result_reg_num)</td></tr>
<tr class="separator:ga6db93a7e9cdeb07b7e9ef1d2f34defd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga495788bc643c2c9d51444edddcb0d3cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga495788bc643c2c9d51444edddcb0d3cb">XMC_VADC_GROUP_ChannelTriggerEvent</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const uint32_t ch_num)</td></tr>
<tr class="separator:ga495788bc643c2c9d51444edddcb0d3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a6ebe138cbedaba37f2333ccfb068a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga2a6ebe138cbedaba37f2333ccfb068a2">XMC_VADC_GROUP_ChannelTriggerEventGenCriteria</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const uint32_t ch_num, const <a class="el" href="group___v_a_d_c.html#ga1b6bf4c15562eef67deac95cb36a48d6">XMC_VADC_CHANNEL_EVGEN_t</a> criteria)</td></tr>
<tr class="separator:ga2a6ebe138cbedaba37f2333ccfb068a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22b85c7c9fc777c05d74f1ae2a7cc9ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga22b85c7c9fc777c05d74f1ae2a7cc9ac">XMC_VADC_GROUP_CheckSlaveReadiness</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, uint32_t slave_group)</td></tr>
<tr class="separator:ga22b85c7c9fc777c05d74f1ae2a7cc9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4178ad4431b23112dbc89e8e258bc22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gaf4178ad4431b23112dbc89e8e258bc22">XMC_VADC_GROUP_ClearResultEvent</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const uint32_t res_reg)</td></tr>
<tr class="separator:gaf4178ad4431b23112dbc89e8e258bc22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b5c2e50ccf150e33028b51577c57749"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga2b5c2e50ccf150e33028b51577c57749">XMC_VADC_GROUP_DisableChannelSyncRequest</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const uint32_t ch_num)</td></tr>
<tr class="separator:ga2b5c2e50ccf150e33028b51577c57749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga356e5be65b3abe1ac62e58adfda17529"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga356e5be65b3abe1ac62e58adfda17529">XMC_VADC_GROUP_DisableResultEvent</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const uint32_t res_reg)</td></tr>
<tr class="separator:ga356e5be65b3abe1ac62e58adfda17529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb698bad87dcbc3fdf6ce8d6df1ecbb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gadb698bad87dcbc3fdf6ce8d6df1ecbb4">XMC_VADC_GROUP_EnableChannelSyncRequest</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const uint32_t ch_num)</td></tr>
<tr class="separator:gadb698bad87dcbc3fdf6ce8d6df1ecbb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1fa1ad973c5ab02b6a6a9ece61e1045"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gae1fa1ad973c5ab02b6a6a9ece61e1045">XMC_VADC_GROUP_EnableResultEvent</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const uint32_t res_reg)</td></tr>
<tr class="separator:gae1fa1ad973c5ab02b6a6a9ece61e1045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71ab6e09e78d8cca7fda70210d5d9d0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga71ab6e09e78d8cca7fda70210d5d9d0b">XMC_VADC_GROUP_ExternalMuxControlInit</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const <a class="el" href="struct_x_m_c___v_a_d_c___g_r_o_u_p___e_m_u_x_c_f_g__t.html">XMC_VADC_GROUP_EMUXCFG_t</a> emux_cfg)</td></tr>
<tr class="separator:ga71ab6e09e78d8cca7fda70210d5d9d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38c817eb225c4a684c4bbf5495981b2b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga38c817eb225c4a684c4bbf5495981b2b">XMC_VADC_GROUP_GetDetailedResult</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const uint32_t res_reg)</td></tr>
<tr class="separator:ga38c817eb225c4a684c4bbf5495981b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74c556f6be3e4ad892ad04afedf1f566"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___v_a_d_c.html#ga42e972915a3d2ac3b46847a4d5228c64">XMC_VADC_FAST_COMPARE_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga74c556f6be3e4ad892ad04afedf1f566">XMC_VADC_GROUP_GetFastCompareResult</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const uint32_t res_reg)</td></tr>
<tr class="separator:ga74c556f6be3e4ad892ad04afedf1f566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad190eca993528847f048cb3791bb1484"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___v_a_d_c.html#gadb07d5ea1ef8b662d9550d22944825d4">XMC_VADC_RESULT_SIZE_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gad190eca993528847f048cb3791bb1484">XMC_VADC_GROUP_GetResult</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const uint32_t res_reg)</td></tr>
<tr class="separator:gad190eca993528847f048cb3791bb1484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga902952b0e1027e6fecbd5743229f595c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga902952b0e1027e6fecbd5743229f595c">XMC_VADC_GROUP_GetResultFifoHead</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const uint32_t res_reg)</td></tr>
<tr class="separator:ga902952b0e1027e6fecbd5743229f595c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga233d039edab60b343aa4efef57d79cca"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga233d039edab60b343aa4efef57d79cca">XMC_VADC_GROUP_GetResultFifoTail</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, uint32_t res_reg)</td></tr>
<tr class="separator:ga233d039edab60b343aa4efef57d79cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e04b2a4deb50a629b3e80bcfeafa14d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga8e04b2a4deb50a629b3e80bcfeafa14d">XMC_VADC_GROUP_IgnoreSlaveReadiness</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, uint32_t slave_group)</td></tr>
<tr class="separator:ga8e04b2a4deb50a629b3e80bcfeafa14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac147b4cbfd00c81b136425fc8e70215d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gac147b4cbfd00c81b136425fc8e70215d">XMC_VADC_GROUP_Init</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const <a class="el" href="struct_x_m_c___v_a_d_c___g_r_o_u_p___c_o_n_f_i_g__t.html">XMC_VADC_GROUP_CONFIG_t</a> *config)</td></tr>
<tr class="separator:gac147b4cbfd00c81b136425fc8e70215d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7a2bbb2f627f186c23ae8b93ebf34fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gaa7a2bbb2f627f186c23ae8b93ebf34fc">XMC_VADC_GROUP_InputClassInit</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const <a class="el" href="struct_x_m_c___v_a_d_c___g_r_o_u_p___c_l_a_s_s__t.html">XMC_VADC_GROUP_CLASS_t</a> config, const <a class="el" href="group___v_a_d_c.html#gadf393a8c811d7ee6601688797e616646">XMC_VADC_GROUP_CONV_t</a> conv_type, const uint32_t set_num)</td></tr>
<tr class="separator:gaa7a2bbb2f627f186c23ae8b93ebf34fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e70ce6dfa38cee7c48004720aac8aeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___v_a_d_c.html#ga4effb949346537c7a515c4f2ff542df5">XMC_VADC_GROUP_STATE_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga8e70ce6dfa38cee7c48004720aac8aeb">XMC_VADC_GROUP_IsConverterBusy</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr)</td></tr>
<tr class="separator:ga8e70ce6dfa38cee7c48004720aac8aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fb1c3e933690c2e106823950c6fe06d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga4fb1c3e933690c2e106823950c6fe06d">XMC_VADC_GROUP_IsResultRegisterFifoHead</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const uint32_t res_reg)</td></tr>
<tr class="separator:ga4fb1c3e933690c2e106823950c6fe06d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1b61fdad9ee903b23e944e787843e46"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gae1b61fdad9ee903b23e944e787843e46">XMC_VADC_GROUP_IsResultRegisterInFifo</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const uint32_t res_reg)</td></tr>
<tr class="separator:gae1b61fdad9ee903b23e944e787843e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bfd983c7c4dc403ed40eabe3920c9db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga9bfd983c7c4dc403ed40eabe3920c9db">XMC_VADC_GROUP_QueueAbortSequence</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr)</td></tr>
<tr class="separator:ga9bfd983c7c4dc403ed40eabe3920c9db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga165449401f44c76bafa98f119569ffdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga165449401f44c76bafa98f119569ffdc">XMC_VADC_GROUP_QueueClearReqSrcEvent</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr)</td></tr>
<tr class="separator:ga165449401f44c76bafa98f119569ffdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8d19efeb6b04913e91406eaccff72ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gaa8d19efeb6b04913e91406eaccff72ed">XMC_VADC_GROUP_QueueDisableArbitrationSlot</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr)</td></tr>
<tr class="separator:gaa8d19efeb6b04913e91406eaccff72ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdb123380f2ec61225fd8c7ed70c4c8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gacdb123380f2ec61225fd8c7ed70c4c8b">XMC_VADC_GROUP_QueueDisableExternalTrigger</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr)</td></tr>
<tr class="separator:gacdb123380f2ec61225fd8c7ed70c4c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3c728f97550bccd474f79befc017365"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gaf3c728f97550bccd474f79befc017365">XMC_VADC_GROUP_QueueEnableArbitrationSlot</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr)</td></tr>
<tr class="separator:gaf3c728f97550bccd474f79befc017365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67769f0c1fba40f3fdd1026936ed50b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga67769f0c1fba40f3fdd1026936ed50b9">XMC_VADC_GROUP_QueueEnableExternalTrigger</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr)</td></tr>
<tr class="separator:ga67769f0c1fba40f3fdd1026936ed50b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ed5e69a5c33fd5b3acea763bdf957b9"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga8ed5e69a5c33fd5b3acea763bdf957b9">XMC_VADC_GROUP_QueueGetInterruptedChannel</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr)</td></tr>
<tr class="separator:ga8ed5e69a5c33fd5b3acea763bdf957b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab733f165ccdd37704dc50f5ec5801134"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gab733f165ccdd37704dc50f5ec5801134">XMC_VADC_GROUP_QueueGetLength</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr)</td></tr>
<tr class="separator:gab733f165ccdd37704dc50f5ec5801134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga305e60b302a668a2d2c35b96208cdea7"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga305e60b302a668a2d2c35b96208cdea7">XMC_VADC_GROUP_QueueGetNextChannel</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr)</td></tr>
<tr class="separator:ga305e60b302a668a2d2c35b96208cdea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf5dae90963d3decfcc07d961b2cfdaf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gaaf5dae90963d3decfcc07d961b2cfdaf">XMC_VADC_GROUP_QueueGetReqSrcEventStatus</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr)</td></tr>
<tr class="separator:gaaf5dae90963d3decfcc07d961b2cfdaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga881c16d2f992825869d02005d91ddc09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga881c16d2f992825869d02005d91ddc09">XMC_VADC_GROUP_QueueInit</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const <a class="el" href="struct_x_m_c___v_a_d_c___q_u_e_u_e___c_o_n_f_i_g__t.html">XMC_VADC_QUEUE_CONFIG_t</a> *config)</td></tr>
<tr class="separator:ga881c16d2f992825869d02005d91ddc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26dff19d499748825e53019d060a675a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga26dff19d499748825e53019d060a675a">XMC_VADC_GROUP_QueueInsertChannel</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const <a class="el" href="struct_x_m_c___v_a_d_c___q_u_e_u_e___e_n_t_r_y__t.html">XMC_VADC_QUEUE_ENTRY_t</a> entry)</td></tr>
<tr class="separator:ga26dff19d499748825e53019d060a675a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19b2912cd17132e6a10f818023fa0745"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga19b2912cd17132e6a10f818023fa0745">XMC_VADC_GROUP_QueueRemoveChannel</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr)</td></tr>
<tr class="separator:ga19b2912cd17132e6a10f818023fa0745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1962d86a697f244d19a4127580efd099"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga1962d86a697f244d19a4127580efd099">XMC_VADC_GROUP_QueueSelectGating</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const <a class="el" href="group___v_a_d_c.html#gaa16f1136a4a4efddcd67ebd5fc69bc9f">XMC_VADC_GATE_INPUT_SELECT_t</a> input_num)</td></tr>
<tr class="separator:ga1962d86a697f244d19a4127580efd099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga921d0b59c5a88d92bdc7017d7be2765f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga921d0b59c5a88d92bdc7017d7be2765f">XMC_VADC_GROUP_QueueSelectTrigger</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const <a class="el" href="group___v_a_d_c.html#gab71bdae1d928ee308430626a761eab97">XMC_VADC_TRIGGER_INPUT_SELECT_t</a> input_num)</td></tr>
<tr class="separator:ga921d0b59c5a88d92bdc7017d7be2765f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf9874010e5073415ab846b4ef46955e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gaaf9874010e5073415ab846b4ef46955e">XMC_VADC_GROUP_QueueSetGatingMode</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, <a class="el" href="group___v_a_d_c.html#ga4db02e3b835b8cad941ab60ae288f8c8">XMC_VADC_GATEMODE_t</a> mode_sel)</td></tr>
<tr class="separator:gaaf9874010e5073415ab846b4ef46955e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf8bc9e2f7207523e5fb6d6b360ea663"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gabf8bc9e2f7207523e5fb6d6b360ea663">XMC_VADC_GROUP_QueueSetReqSrcEventInterruptNode</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const <a class="el" href="group___v_a_d_c.html#gab518b0c522cae78b7434dfa327a540b1">XMC_VADC_SR_t</a> sr)</td></tr>
<tr class="separator:gabf8bc9e2f7207523e5fb6d6b360ea663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf7bf44150a8541ab60d12889f367053"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gabf7bf44150a8541ab60d12889f367053">XMC_VADC_GROUP_QueueTriggerConversion</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr)</td></tr>
<tr class="separator:gabf7bf44150a8541ab60d12889f367053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51bc955e0976c66affb8b660261cdf82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga51bc955e0976c66affb8b660261cdf82">XMC_VADC_GROUP_QueueTriggerReqSrcEvent</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr)</td></tr>
<tr class="separator:ga51bc955e0976c66affb8b660261cdf82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a5f41454d3e42d5505db9e3acf5177f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga1a5f41454d3e42d5505db9e3acf5177f">XMC_VADC_GROUP_ResultInit</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const uint32_t res_reg_num, const <a class="el" href="struct_x_m_c___v_a_d_c___r_e_s_u_l_t___c_o_n_f_i_g__t.html">XMC_VADC_RESULT_CONFIG_t</a> *config)</td></tr>
<tr class="separator:ga1a5f41454d3e42d5505db9e3acf5177f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab72f743031df5ebe062fe8a28275888b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gab72f743031df5ebe062fe8a28275888b">XMC_VADC_GROUP_ScanAddChannelToSequence</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const uint32_t ch_num)</td></tr>
<tr class="separator:gab72f743031df5ebe062fe8a28275888b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51f598fc7306207185177af62858ac65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga51f598fc7306207185177af62858ac65">XMC_VADC_GROUP_ScanAddMultipleChannels</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const uint32_t ch_mask)</td></tr>
<tr class="separator:ga51f598fc7306207185177af62858ac65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02dca0332550c23db82bbdd3750d5670"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga02dca0332550c23db82bbdd3750d5670">XMC_VADC_GROUP_ScanClearReqSrcEvent</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr)</td></tr>
<tr class="separator:ga02dca0332550c23db82bbdd3750d5670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d1f77cf454d509dfaff575717a8693f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga4d1f77cf454d509dfaff575717a8693f">XMC_VADC_GROUP_ScanDisableArbitrationSlot</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr)</td></tr>
<tr class="separator:ga4d1f77cf454d509dfaff575717a8693f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aa7cb076e7e2b56f330d0bb14645494"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga1aa7cb076e7e2b56f330d0bb14645494">XMC_VADC_GROUP_ScanDisableContinuousMode</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr)</td></tr>
<tr class="separator:ga1aa7cb076e7e2b56f330d0bb14645494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a558bd413ed6540b84d350728d57eec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga7a558bd413ed6540b84d350728d57eec">XMC_VADC_GROUP_ScanDisableExternalTrigger</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr)</td></tr>
<tr class="separator:ga7a558bd413ed6540b84d350728d57eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga916530591113892be436af6238ead6ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga916530591113892be436af6238ead6ea">XMC_VADC_GROUP_ScanEnableArbitrationSlot</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr)</td></tr>
<tr class="separator:ga916530591113892be436af6238ead6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fa59213861735578dff28c02d961120"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga4fa59213861735578dff28c02d961120">XMC_VADC_GROUP_ScanEnableContinuousMode</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr)</td></tr>
<tr class="separator:ga4fa59213861735578dff28c02d961120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa08eef43607d1b9a39aaab3fae84e7f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gaa08eef43607d1b9a39aaab3fae84e7f3">XMC_VADC_GROUP_ScanEnableExternalTrigger</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr)</td></tr>
<tr class="separator:gaa08eef43607d1b9a39aaab3fae84e7f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga723bda6902bb2b8b0641a0e60b1da61a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga723bda6902bb2b8b0641a0e60b1da61a">XMC_VADC_GROUP_ScanGetNumChannelsPending</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr)</td></tr>
<tr class="separator:ga723bda6902bb2b8b0641a0e60b1da61a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad08132ae30e2e73e5f71d2fb5b3b1c7a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gad08132ae30e2e73e5f71d2fb5b3b1c7a">XMC_VADC_GROUP_ScanGetReqSrcEventStatus</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr)</td></tr>
<tr class="separator:gad08132ae30e2e73e5f71d2fb5b3b1c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0baf952034feb3eaa81736e9761cf48f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga0baf952034feb3eaa81736e9761cf48f">XMC_VADC_GROUP_ScanInit</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const <a class="el" href="struct_x_m_c___v_a_d_c___s_c_a_n___c_o_n_f_i_g__t.html">XMC_VADC_SCAN_CONFIG_t</a> *config)</td></tr>
<tr class="separator:ga0baf952034feb3eaa81736e9761cf48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ea5f62893afbb468820cb612f09e3d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga4ea5f62893afbb468820cb612f09e3d1">XMC_VADC_GROUP_ScanIsChannelPending</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const uint32_t ch_num)</td></tr>
<tr class="separator:ga4ea5f62893afbb468820cb612f09e3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab637f1591586c7dfb8593fb394104887"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gab637f1591586c7dfb8593fb394104887">XMC_VADC_GROUP_ScanSelectGating</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, <a class="el" href="group___v_a_d_c.html#gaa16f1136a4a4efddcd67ebd5fc69bc9f">XMC_VADC_GATE_INPUT_SELECT_t</a> gating_input)</td></tr>
<tr class="separator:gab637f1591586c7dfb8593fb394104887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d29e840f790e5c763c1f00bbcf1e131"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga4d29e840f790e5c763c1f00bbcf1e131">XMC_VADC_GROUP_ScanSelectTrigger</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, <a class="el" href="group___v_a_d_c.html#gab71bdae1d928ee308430626a761eab97">XMC_VADC_TRIGGER_INPUT_SELECT_t</a> trigger_input)</td></tr>
<tr class="separator:ga4d29e840f790e5c763c1f00bbcf1e131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4963004f5c5f5bfd255b51d79d62e143"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga4963004f5c5f5bfd255b51d79d62e143">XMC_VADC_GROUP_ScanSequenceAbort</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr)</td></tr>
<tr class="separator:ga4963004f5c5f5bfd255b51d79d62e143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5db8e4e617a0df8234d948ed26d7d9a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga5db8e4e617a0df8234d948ed26d7d9a3">XMC_VADC_GROUP_ScanSetGatingMode</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, <a class="el" href="group___v_a_d_c.html#ga4db02e3b835b8cad941ab60ae288f8c8">XMC_VADC_GATEMODE_t</a> mode_sel)</td></tr>
<tr class="separator:ga5db8e4e617a0df8234d948ed26d7d9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c309bf576995893d65adc4cd362a321"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga3c309bf576995893d65adc4cd362a321">XMC_VADC_GROUP_ScanSetReqSrcEventInterruptNode</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const <a class="el" href="group___v_a_d_c.html#gab518b0c522cae78b7434dfa327a540b1">XMC_VADC_SR_t</a> sr)</td></tr>
<tr class="separator:ga3c309bf576995893d65adc4cd362a321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga013308f793d25106e935c6f1bdbd95a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga013308f793d25106e935c6f1bdbd95a9">XMC_VADC_GROUP_ScanTriggerConversion</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr)</td></tr>
<tr class="separator:ga013308f793d25106e935c6f1bdbd95a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf7d930e6e633e535725c13eaf444afc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gacf7d930e6e633e535725c13eaf444afc">XMC_VADC_GROUP_ScanTriggerReqSrcEvent</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr)</td></tr>
<tr class="separator:gacf7d930e6e633e535725c13eaf444afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f2cda270ffbbc2dcf6879d66ddb94b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga5f2cda270ffbbc2dcf6879d66ddb94b8">XMC_VADC_GROUP_SetBoundaries</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const uint32_t boundary0, const uint32_t boundary1)</td></tr>
<tr class="separator:ga5f2cda270ffbbc2dcf6879d66ddb94b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9a9864939239099c1de61555e12d223"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gaa9a9864939239099c1de61555e12d223">XMC_VADC_GROUP_SetChannelAlias</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const uint32_t src_ch_num, const uint32_t alias_ch_num)</td></tr>
<tr class="separator:gaa9a9864939239099c1de61555e12d223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae435b6b66cac1abc05d17fd17d5caca6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gae435b6b66cac1abc05d17fd17d5caca6">XMC_VADC_GROUP_SetPowerMode</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const <a class="el" href="group___v_a_d_c.html#ga7226349aef79a52f614eb5e75e3f55d9">XMC_VADC_GROUP_POWERMODE_t</a> power_mode)</td></tr>
<tr class="separator:gae435b6b66cac1abc05d17fd17d5caca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga151403257b63a3307631979702dee524"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga151403257b63a3307631979702dee524">XMC_VADC_GROUP_SetResultFastCompareValue</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const uint32_t res_reg, const <a class="el" href="group___v_a_d_c.html#gadb07d5ea1ef8b662d9550d22944825d4">XMC_VADC_RESULT_SIZE_t</a> compare_val)</td></tr>
<tr class="separator:ga151403257b63a3307631979702dee524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga701140b8237cba836cbd4f1cd3393330"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga701140b8237cba836cbd4f1cd3393330">XMC_VADC_GROUP_SetResultInterruptNode</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const uint32_t res_reg, const <a class="el" href="group___v_a_d_c.html#gab518b0c522cae78b7434dfa327a540b1">XMC_VADC_SR_t</a> sr)</td></tr>
<tr class="separator:ga701140b8237cba836cbd4f1cd3393330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1406cd26c69119e3a181b38f9d1fd26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gae1406cd26c69119e3a181b38f9d1fd26">XMC_VADC_GROUP_SetSyncMaster</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr)</td></tr>
<tr class="separator:gae1406cd26c69119e3a181b38f9d1fd26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1469b90543473edcd8bfd1253166cc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gac1469b90543473edcd8bfd1253166cc2">XMC_VADC_GROUP_SetSyncSlave</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, uint32_t master_grp, uint32_t slave_group)</td></tr>
<tr class="separator:gac1469b90543473edcd8bfd1253166cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd781581d9749d4f79c9d8a2b6570596"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#gadd781581d9749d4f79c9d8a2b6570596">XMC_VADC_GROUP_TriggerResultEvent</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const uint32_t res_reg)</td></tr>
<tr class="separator:gadd781581d9749d4f79c9d8a2b6570596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1723512610fb75b8092cab99d15997ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_a_d_c.html#ga1723512610fb75b8092cab99d15997ca">XMC_VADC_GROUP_TriggerServiceRequest</a> (<a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const group_ptr, const uint32_t sr_num, const <a class="el" href="group___v_a_d_c.html#ga14a1cbb73bf2a92a3321aea14488f354">XMC_VADC_GROUP_IRQ_t</a> type)</td></tr>
<tr class="separator:ga1723512610fb75b8092cab99d15997ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The XMC microcontroller provides a series of analog input channels connected to a cluster of Analog/Digital Converters using the Successive Approximation Register (SAR) principle to convert analog input values (voltages) to discrete digital values. The XMC1x is based on Sample &amp; Hold converters, where a cluster contains 2 Sample&amp;Hold units which share a common converter.</p>
<p>Each converter of the ADC cluster can operate independent of the others, controlled by a dedicated set of registers and triggered by a dedicated group request source. The results of each channel can be stored in a dedicated channel-specific result register or in a group-specific result register.<br />
</p>
<p>The Versatile Analog to Digital Converter module (VADC) of the XMC comprises a set of converter blocks that can be operated either independently or via a common request source that emulates a background converter. Each converter block is equipped with a dedicated input multiplexer and dedicated request sources, which together build separate groups.</p>
<div class="image">
<img src="vadc_overview_xmc1x.png" alt="vadc_overview_xmc1x.png"/>
</div>
<p>The VADC LLD is split into GLOBAL and GROUP related APIs.<br />
 <b>GLOBAL: </b><br />
 </p><ul>
<li>
Global APIs act on the entire ADC module. Configures global configuration registers </li>
<li>
Allows configuration of the background request source of the VADC. </li>
<li>
The clock related configurations for the VADC module are configured in the Global APIs/ </li>
<li>
The Global API names are prefixed by the <b>XMC_VADC_GLOBAL_</b> and they accept <a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> as one of its arguments. </li>
</ul>
<p><br />
</p>
<p><b>GROUP: </b><br />
 </p><ul>
<li>
Group APIs act on a VADC group. Configures the group configuration registers </li>
<li>
Configures the queue request source of the VADC. The APIs which act on the queue related registers are prefixed by <b>XMC_VADC_GROUP_Queue</b> </li>
<li>
Configures the scan request source of the VADC. The APIs which act on the scan related registers are prefixed by <b>XMC_VADC_GROUP_Scan</b> </li>
<li>
Configuration of the channels of each group are done by the API which have a prefix as <b>XMC_VADC_GROUP_Channel</b>. </li>
<li>
The Group API names are prefixed by the <b>XMC_VADC_GROUP_</b> and they accept <a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> as one of its arguments. </li>
</ul>
<p><br />
 </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga0ee2c29ae299c63136472283e087a9a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_VADC_MAJOR_VERSION&#160;&#160;&#160;(1U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Major number of the driver version, which is, &lt;major.&lt;minor&gt;.&lt;patch&gt; e.g. 1.5.3. </p>

</div>
</div>
<a class="anchor" id="gaa5597a51a50125e6e64579f45f0a71ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_VADC_MINOR_VERSION&#160;&#160;&#160;(0U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Minor number of the driver version, which is, &lt;major.&lt;minor&gt;.&lt;patch&gt; e.g. 1.5.3. </p>

</div>
</div>
<a class="anchor" id="ga5493b6e76383802d08a3a1b8198e566e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_VADC_NUM_CHANNELS_PER_GROUP&#160;&#160;&#160;(8U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the number of ADC channels per group </p>

<p>Referenced by <a class="el" href="group___v_a_d_c.html#ga67c4d922e3b0a4abbaefde613a2a3c00">XMC_VADC_GLOBAL_BackgroundAddChannelToSequence()</a>, and <a class="el" href="group___v_a_d_c.html#gad6e756229d4b42d79c942f594895e880">XMC_VADC_GLOBAL_BackgroundIsChannelPending()</a>.</p>

</div>
</div>
<a class="anchor" id="ga744e76f616721ca88a701c042d637ab3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_VADC_PATCH_VERSION&#160;&#160;&#160;(2U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Minor number of the driver version, which is, &lt;major.&lt;minor&gt;.&lt;patch&gt; e.g. 1.5.3. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga5df621dbf8385ce88a2fbe632a75d02d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_x_m_c___v_a_d_c___s_c_a_n___c_o_n_f_i_g__t.html">XMC_VADC_SCAN_CONFIG_t</a> <a class="el" href="group___v_a_d_c.html#ga5df621dbf8385ce88a2fbe632a75d02d">XMC_VADC_BACKGROUND_CONFIG_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type defined the scan configuration structure for background Request Source </p>

</div>
</div>
<a class="anchor" id="ga11a8b12d7d98d3a9b81c95f9d5c671c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef SHS_Type <a class="el" href="group___v_a_d_c.html#ga11a8b12d7d98d3a9b81c95f9d5c671c4">XMC_VADC_GLOBAL_SHS_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type defined the sample and hold register structure </p>

</div>
</div>
<a class="anchor" id="ga8cc559b855e4da85ee2f48bcd98405cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VADC_GLOBAL_TypeDef <a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type defined the device header file vadc global register structure type to VADC type </p>

</div>
</div>
<a class="anchor" id="ga1cab39abba3ecb096d57ab19b5774800"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VADC_G_TypeDef <a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type defined the device header file vadc group register structure type to VADC Group type </p>

</div>
</div>
<a class="anchor" id="gadb07d5ea1ef8b662d9550d22944825d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint16_t <a class="el" href="group___v_a_d_c.html#gadb07d5ea1ef8b662d9550d22944825d4">XMC_VADC_RESULT_SIZE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type defined the converted result size to unsigned 16 bit integer </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga32e761497c835cb7995991380b8b9676"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___v_a_d_c.html#ga32e761497c835cb7995991380b8b9676">XMC_VADC_CHANNEL_ALIAS_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines channel alias. All enum items are available for channels 0 and 1. Other Channels can accept only XMC_VADC_CHANNEL_ALIAS_DISABLED. </p>

</div>
</div>
<a class="anchor" id="ga69fe77fd05cfd4a502f14becf6352cea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___v_a_d_c.html#ga69fe77fd05cfd4a502f14becf6352cea">XMC_VADC_CHANNEL_BOUNDARY_CONDITION_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the criteria for boundary flag assertion. Use <a class="el" href="group___v_a_d_c.html#ga69fe77fd05cfd4a502f14becf6352cea">XMC_VADC_CHANNEL_BOUNDARY_CONDITION_t</a> for this enumeration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga69fe77fd05cfd4a502f14becf6352ceaa12e3fcda7b15fb19e8a24875dc4e140a"></a>XMC_VADC_CHANNEL_BOUNDARY_CONDITION_ABOVE_BAND&#160;</td><td class="fielddoc">
<p>Set Boundary condition criteria to assert above the band </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga69fe77fd05cfd4a502f14becf6352ceaa37e4c015407377c2514bd9c44c4d6662"></a>XMC_VADC_CHANNEL_BOUNDARY_CONDITION_BELOW_BAND&#160;</td><td class="fielddoc">
<p>Set Boundary condition criteria to assert below the band </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga203ae2271679fb3e05d185a6bd14b8b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___v_a_d_c.html#ga203ae2271679fb3e05d185a6bd14b8b2">XMC_VADC_CHANNEL_BOUNDARY_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the references to boundary values used for limit checking feature. Each of these can be assigned as either an upper bound or a lower bound. Use <a class="el" href="group___v_a_d_c.html#ga203ae2271679fb3e05d185a6bd14b8b2">XMC_VADC_CHANNEL_BOUNDARY_t</a> for this enumeration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga203ae2271679fb3e05d185a6bd14b8b2a2eb22e6976e5553aaacea29538beda6b"></a>XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND0&#160;</td><td class="fielddoc">
<p>Group specific Boundary-0 value </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga203ae2271679fb3e05d185a6bd14b8b2a103e8fab52a5fe949383b59872d02069"></a>XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND1&#160;</td><td class="fielddoc">
<p>Group specific Boundary-1 value </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga203ae2271679fb3e05d185a6bd14b8b2addb07a657e568468242cd7f4d6b37575"></a>XMC_VADC_CHANNEL_BOUNDARY_GLOBAL_BOUND0&#160;</td><td class="fielddoc">
<p>Module wide Boundary-0 value </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga203ae2271679fb3e05d185a6bd14b8b2add5718928c0d3516f42886d6c96fe790"></a>XMC_VADC_CHANNEL_BOUNDARY_GLOBAL_BOUND1&#160;</td><td class="fielddoc">
<p>Module wide Boundary-1 value </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga91049cf62e24988e2df8554af78e2183"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___v_a_d_c.html#ga91049cf62e24988e2df8554af78e2183">XMC_VADC_CHANNEL_BWDCH_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the voltage which the capacitor is charged to. Used in Broken wire detection feature. Use <a class="el" href="group___v_a_d_c.html#ga91049cf62e24988e2df8554af78e2183">XMC_VADC_CHANNEL_BWDCH_t</a> for this enumeration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga91049cf62e24988e2df8554af78e2183a6557c82bb5f3f79333dc0f5adf72bb40"></a>XMC_VADC_CHANNEL_BWDCH_VAGND&#160;</td><td class="fielddoc">
<p>Capacitor pre-charged to ground </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga91049cf62e24988e2df8554af78e2183ad30d5559ec906982f98c5c3b9f3a2149"></a>XMC_VADC_CHANNEL_BWDCH_VAREF&#160;</td><td class="fielddoc">
<p>Capacitor pre-charged to reference voltage </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga0da7a93877a25398b4e70482b85acd03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___v_a_d_c.html#ga0da7a93877a25398b4e70482b85acd03">XMC_VADC_CHANNEL_CONV_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the conversion classes that can be selected for each channel. The enumeration members holds the group or global classes. The conversion classes decides the properties of conversion, like resolution, sampling time etc Use <a class="el" href="group___v_a_d_c.html#ga0da7a93877a25398b4e70482b85acd03">XMC_VADC_CHANNEL_CONV_t</a> for this enumeration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga0da7a93877a25398b4e70482b85acd03a01d1d18f4ea33aae01eb486660393989"></a>XMC_VADC_CHANNEL_CONV_GROUP_CLASS0&#160;</td><td class="fielddoc">
<p>Conversion property set-0 specific to the group </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga0da7a93877a25398b4e70482b85acd03aa39fbfa369d7a906592f7849e58298a2"></a>XMC_VADC_CHANNEL_CONV_GROUP_CLASS1&#160;</td><td class="fielddoc">
<p>Conversion property set-1 specific to the group </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga0da7a93877a25398b4e70482b85acd03a6092acad2d6d9493846dbd0c2ac67daf"></a>XMC_VADC_CHANNEL_CONV_GLOBAL_CLASS0&#160;</td><td class="fielddoc">
<p>Conversion property set-0, Module wide </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga0da7a93877a25398b4e70482b85acd03a17cadc6c0c0772e937e23f1ad1818264"></a>XMC_VADC_CHANNEL_CONV_GLOBAL_CLASS1&#160;</td><td class="fielddoc">
<p>Conversion property set-1, Module wide </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga1b6bf4c15562eef67deac95cb36a48d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___v_a_d_c.html#ga1b6bf4c15562eef67deac95cb36a48d6">XMC_VADC_CHANNEL_EVGEN_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the criteria for event generation by the channel. Use <a class="el" href="group___v_a_d_c.html#ga1b6bf4c15562eef67deac95cb36a48d6">XMC_VADC_CHANNEL_EVGEN_t</a> for this enumeration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga1b6bf4c15562eef67deac95cb36a48d6a84a7270450c56954fea5768f8dfd9f1a"></a>XMC_VADC_CHANNEL_EVGEN_NEVER&#160;</td><td class="fielddoc">
<p>No event generated </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1b6bf4c15562eef67deac95cb36a48d6a81136e28dae1a2b4b27184f47b197199"></a>XMC_VADC_CHANNEL_EVGEN_INBOUND&#160;</td><td class="fielddoc">
<p>Event generated when the result is within the normal range </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1b6bf4c15562eef67deac95cb36a48d6a13b50b90ecfc83823ebd41d6399078af"></a>XMC_VADC_CHANNEL_EVGEN_COMPHIGH&#160;</td><td class="fielddoc">
<p>Event generated when the result of fast compare operation is high </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1b6bf4c15562eef67deac95cb36a48d6a67fa97a42d92971a0628e4c96102e602"></a>XMC_VADC_CHANNEL_EVGEN_OUTBOUND&#160;</td><td class="fielddoc">
<p>Event generated when the result is outside the normal range </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1b6bf4c15562eef67deac95cb36a48d6a26977d4681508972cfa75c3b49be7ea9"></a>XMC_VADC_CHANNEL_EVGEN_COMPLOW&#160;</td><td class="fielddoc">
<p>Event generated when the result result of fast compare operation is low </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1b6bf4c15562eef67deac95cb36a48d6a9743b4856f1e187c9143dad7613defde"></a>XMC_VADC_CHANNEL_EVGEN_ALWAYS&#160;</td><td class="fielddoc">
<p>Event generated always after conversion - unconditionally </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gab0c1eb7f8d8743b6b98ebfe8acd14e28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___v_a_d_c.html#gab0c1eb7f8d8743b6b98ebfe8acd14e28">XMC_VADC_CHANNEL_REF_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the reference voltage selection for conversion. Use <a class="el" href="group___v_a_d_c.html#gab0c1eb7f8d8743b6b98ebfe8acd14e28">XMC_VADC_CHANNEL_REF_t</a> for this enumeration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggab0c1eb7f8d8743b6b98ebfe8acd14e28aca253c1b3d320840ed1d64e5791a69a4"></a>XMC_VADC_CHANNEL_REF_INTREF&#160;</td><td class="fielddoc">
<p>Internal VARef </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab0c1eb7f8d8743b6b98ebfe8acd14e28a4b8c8f8bfbbd58dcf804d166f159a654"></a>XMC_VADC_CHANNEL_REF_ALT_CH0&#160;</td><td class="fielddoc">
<p>External voltage available on Channel-0 of the perticular group </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga9f7e6983d71750230e15684a2dc0cf12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___v_a_d_c.html#ga9f7e6983d71750230e15684a2dc0cf12">XMC_VADC_CONVMODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the conversion mode. It defines the resolution of conversion. Use XMC_VADC_CONVMODE_t for this enumeration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga9f7e6983d71750230e15684a2dc0cf12a92a1dd71052d7784f1b2325a3e14df70"></a>XMC_VADC_CONVMODE_12BIT&#160;</td><td class="fielddoc">
<p>Results of conversion are 12bits wide </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga9f7e6983d71750230e15684a2dc0cf12af7a5c377d4788520327c0822e0ccd18b"></a>XMC_VADC_CONVMODE_10BIT&#160;</td><td class="fielddoc">
<p>Results of conversion are 10bits wide </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga9f7e6983d71750230e15684a2dc0cf12a787485b122181ae78b66c8e9e56fa0a7"></a>XMC_VADC_CONVMODE_8BIT&#160;</td><td class="fielddoc">
<p>Results of conversion are 8bits wide </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga9f7e6983d71750230e15684a2dc0cf12a09e44e2e8dc7cbb1442aafb8f3f95c99"></a>XMC_VADC_CONVMODE_FASTCOMPARE&#160;</td><td class="fielddoc">
<p>Input signal compared with a preset range </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gaff5ca81d747517a6420fea34642c6778"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___v_a_d_c.html#gaff5ca81d747517a6420fea34642c6778">XMC_VADC_DMM_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the conversion result handling mode. Use <a class="el" href="group___v_a_d_c.html#gaff5ca81d747517a6420fea34642c6778">XMC_VADC_DMM_t</a> for this enumeration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaff5ca81d747517a6420fea34642c6778a1bd4f88d1ae65dd412b2bea7084ac6ea"></a>XMC_VADC_DMM_REDUCTION_MODE&#160;</td><td class="fielddoc">
<p>Standard Data reduction mode </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaff5ca81d747517a6420fea34642c6778aed21d04bf248f50ed8284bdc8d82639a"></a>XMC_VADC_DMM_FILTERING_MODE&#160;</td><td class="fielddoc">
<p>Provide option to select Finite Impulse Response Filter (FIR) or Infinite Impulse Response Filter (IIR) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaff5ca81d747517a6420fea34642c6778a721c65e6d4d9f3a61595b78f70d4e190"></a>XMC_VADC_DMM_DIFFERENCE_MODE&#160;</td><td class="fielddoc">
<p>Difference mode is selected </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga42e972915a3d2ac3b46847a4d5228c64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___v_a_d_c.html#ga42e972915a3d2ac3b46847a4d5228c64">XMC_VADC_FAST_COMPARE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the output of a fast compare mode. Use <a class="el" href="group___v_a_d_c.html#ga42e972915a3d2ac3b46847a4d5228c64">XMC_VADC_FAST_COMPARE_t</a> for this enumeration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga42e972915a3d2ac3b46847a4d5228c64a60b1cf2b6fdff4aee40cece2db973494"></a>XMC_VADC_FAST_COMPARE_LOW&#160;</td><td class="fielddoc">
<p>Input lower than than programmed reference </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga42e972915a3d2ac3b46847a4d5228c64a17cb1fe0e80b3f5abc52c0b9c060a36b"></a>XMC_VADC_FAST_COMPARE_HIGH&#160;</td><td class="fielddoc">
<p>Input higher than than programmed reference </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga42e972915a3d2ac3b46847a4d5228c64ac11d5afc7241581ac99588899ff1d555"></a>XMC_VADC_FAST_COMPARE_UNKNOWN&#160;</td><td class="fielddoc">
<p>Unknown, Conversion probably still ongoing </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gaa16f1136a4a4efddcd67ebd5fc69bc9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___v_a_d_c.html#gaa16f1136a4a4efddcd67ebd5fc69bc9f">XMC_VADC_GATE_INPUT_SELECT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the external gating input selection possibilities, to gate the conversion requests. Refer the VADC interconnects section of the reference manual for details of peripherals which can be used. Also refer xmc_vadc_map.h file for detailed definitions of the peripherals which can take the control of these enumeration items. Use <a class="el" href="group___v_a_d_c.html#gaa16f1136a4a4efddcd67ebd5fc69bc9f">XMC_VADC_GATE_INPUT_SELECT_t</a> for this enumeration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaa16f1136a4a4efddcd67ebd5fc69bc9fa628fa2a0ae62f6676d9f0aa6e6c78f34"></a>XMC_VADC_REQ_GT_A&#160;</td><td class="fielddoc">
<p>Gating select signal A </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaa16f1136a4a4efddcd67ebd5fc69bc9fa19af54717bfaa667ea4fd277bd9b1363"></a>XMC_VADC_REQ_GT_B&#160;</td><td class="fielddoc">
<p>Gating select signal B </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaa16f1136a4a4efddcd67ebd5fc69bc9faf9002b27a33b94fcbb01283f26a9af2f"></a>XMC_VADC_REQ_GT_C&#160;</td><td class="fielddoc">
<p>Gating select signal C </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaa16f1136a4a4efddcd67ebd5fc69bc9fa19a4b78111378dabcc5b6cfc784f12bf"></a>XMC_VADC_REQ_GT_D&#160;</td><td class="fielddoc">
<p>Gating select signal D </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaa16f1136a4a4efddcd67ebd5fc69bc9fa31eb3921627e7f9235d728ed7b3c5c55"></a>XMC_VADC_REQ_GT_E&#160;</td><td class="fielddoc">
<p>Gating select signal E </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaa16f1136a4a4efddcd67ebd5fc69bc9fac5ad2424cc03a834d6c4b8ecd1588795"></a>XMC_VADC_REQ_GT_F&#160;</td><td class="fielddoc">
<p>Gating select signal F </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaa16f1136a4a4efddcd67ebd5fc69bc9fac427fc9bece629f5ad3534c08ba60477"></a>XMC_VADC_REQ_GT_G&#160;</td><td class="fielddoc">
<p>Gating select signal G </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaa16f1136a4a4efddcd67ebd5fc69bc9fa949e53a7798ed7e81e4441d45da8e584"></a>XMC_VADC_REQ_GT_H&#160;</td><td class="fielddoc">
<p>Gating select signal H </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaa16f1136a4a4efddcd67ebd5fc69bc9fa604981cad23be4290b7186a999670de1"></a>XMC_VADC_REQ_GT_I&#160;</td><td class="fielddoc">
<p>Gating select signal I </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaa16f1136a4a4efddcd67ebd5fc69bc9fad5640a3b1c65f8b13eb19b8a48bff0b1"></a>XMC_VADC_REQ_GT_J&#160;</td><td class="fielddoc">
<p>Gating select signal J </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaa16f1136a4a4efddcd67ebd5fc69bc9fa39fff78f06b392778b82e5865ea30c19"></a>XMC_VADC_REQ_GT_K&#160;</td><td class="fielddoc">
<p>Gating select signal K </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaa16f1136a4a4efddcd67ebd5fc69bc9fa58a6afc1fb1a441196de4c2010ee9fa9"></a>XMC_VADC_REQ_GT_L&#160;</td><td class="fielddoc">
<p>Gating select signal L </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaa16f1136a4a4efddcd67ebd5fc69bc9faa3ddf0b32c2642cddd92f5a7062eb0f7"></a>XMC_VADC_REQ_GT_M&#160;</td><td class="fielddoc">
<p>Gating select signal M </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaa16f1136a4a4efddcd67ebd5fc69bc9fa37a52e037bb5ef38e0843cabd63637e9"></a>XMC_VADC_REQ_GT_N&#160;</td><td class="fielddoc">
<p>Gating select signal N </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaa16f1136a4a4efddcd67ebd5fc69bc9faaa030baffac71a32d53b77369fc5137a"></a>XMC_VADC_REQ_GT_O&#160;</td><td class="fielddoc">
<p>Gating select signal O </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaa16f1136a4a4efddcd67ebd5fc69bc9fae36d43191eba009ea267acc503d8524f"></a>XMC_VADC_REQ_GT_P&#160;</td><td class="fielddoc">
<p>Gating select signal P </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga4db02e3b835b8cad941ab60ae288f8c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___v_a_d_c.html#ga4db02e3b835b8cad941ab60ae288f8c8">XMC_VADC_GATEMODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the condition for gating the conversion requests. It can be used to set the ENGT field of ASMR/BSMR/QMR register respectively for auto_scan/background_scan/queue request sources. Use <a class="el" href="group___v_a_d_c.html#ga4db02e3b835b8cad941ab60ae288f8c8">XMC_VADC_GATEMODE_t</a> for this enumeration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga4db02e3b835b8cad941ab60ae288f8c8ac913472cb9094d0ad24cb25df3a42ede"></a>XMC_VADC_GATEMODE_BLOCK&#160;</td><td class="fielddoc">
<p>External triggers are permanently blocked </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4db02e3b835b8cad941ab60ae288f8c8a49069b53946c883dedc6c59dbf67dae8"></a>XMC_VADC_GATEMODE_IGNORE&#160;</td><td class="fielddoc">
<p>External triggers are unconditionally passed </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4db02e3b835b8cad941ab60ae288f8c8a7c7672639ef846098badaa1273b23a7b"></a>XMC_VADC_GATEMODE_ACTIVEHIGH&#160;</td><td class="fielddoc">
<p>External trigger is passed only if the gate signal is high </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4db02e3b835b8cad941ab60ae288f8c8a6c503bea41d82b4d2b00bbbdc1d39ac6"></a>XMC_VADC_GATEMODE_ACTIVELOW&#160;</td><td class="fielddoc">
<p>External trigger is passed only if the gate signal is low </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gaa69659f0a647c58e6a0c434759a5f358"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___v_a_d_c.html#gaa69659f0a647c58e6a0c434759a5f358">XMC_VADC_GLOBAL_EVENT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the event which can lead to a global service request assertion. Use <a class="el" href="group___v_a_d_c.html#gaa69659f0a647c58e6a0c434759a5f358">XMC_VADC_GLOBAL_EVENT_t</a> for this enumeration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaa69659f0a647c58e6a0c434759a5f358ac6d9b471959c249288e9eb86eb874fe3"></a>XMC_VADC_GLOBAL_EVENT_BKGNDSOURCE&#160;</td><td class="fielddoc">
<p>Background scan request source event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaa69659f0a647c58e6a0c434759a5f358acd0bc4bf1a88d34dde532f8c597b3de8"></a>XMC_VADC_GLOBAL_EVENT_RESULT&#160;</td><td class="fielddoc">
<p>Global result event </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gaeab802d00faa3aad6269c620a15a381b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___v_a_d_c.html#gaeab802d00faa3aad6269c620a15a381b">XMC_VADC_GROUP_ARBMODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the request source arbiter behavior. Use <a class="el" href="group___v_a_d_c.html#gaeab802d00faa3aad6269c620a15a381b">XMC_VADC_GROUP_ARBMODE_t</a> for this enumeration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaeab802d00faa3aad6269c620a15a381ba2f3e98ed8180a3561aaab67e7e5bd582"></a>XMC_VADC_GROUP_ARBMODE_ALWAYS&#160;</td><td class="fielddoc">
<p>Arbiter runs all the time </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaeab802d00faa3aad6269c620a15a381baca890d7bfd6eadf36d582bde6f3e7c19"></a>XMC_VADC_GROUP_ARBMODE_ONDEMAND&#160;</td><td class="fielddoc">
<p>Arbiter runs only if a conversion request is asserted by any of the request sources </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga017b3c6d3e14d46d5cf60602f262659d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___v_a_d_c.html#ga017b3c6d3e14d46d5cf60602f262659d">XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the various modes for the boundary flag. Use <a class="el" href="group___v_a_d_c.html#ga017b3c6d3e14d46d5cf60602f262659d">XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_t</a> for this enumeration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga017b3c6d3e14d46d5cf60602f262659da247876a12a1ec728b08ad22a23461dd0"></a>XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_DISABLED&#160;</td><td class="fielddoc">
<p>Disable boundary flag </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga017b3c6d3e14d46d5cf60602f262659da1c42beaee2cb5656833697e2b75a9fe5"></a>XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_ENABLED&#160;</td><td class="fielddoc">
<p>Always enable boundary </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga017b3c6d3e14d46d5cf60602f262659da3ec5736710604ff2d447c09d0ed521da"></a>XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_ENABLED_ACTIVE_LOW&#160;</td><td class="fielddoc">
<p>Enable boundary flag when gate level is 0 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga017b3c6d3e14d46d5cf60602f262659da40e92524506d5b3ed3654f83be18da33"></a>XMC_VADC_GROUP_BOUNDARY_FLAG_MODE_ENABLED_ACTIVE_HIGH&#160;</td><td class="fielddoc">
<p>Enable boundary flag when gate level is 1 </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gadf393a8c811d7ee6601688797e616646"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___v_a_d_c.html#gadf393a8c811d7ee6601688797e616646">XMC_VADC_GROUP_CONV_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the reference to sample time and conversion mode settings. Use <a class="el" href="group___v_a_d_c.html#gadf393a8c811d7ee6601688797e616646">XMC_VADC_GROUP_CONV_t</a> for this enumeration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggadf393a8c811d7ee6601688797e616646ac78caa8ace779a519cce8e2b005e5184"></a>XMC_VADC_GROUP_CONV_STD&#160;</td><td class="fielddoc">
<p>Settings pertaining to channels directly attached to VADC module </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggadf393a8c811d7ee6601688797e616646a87e29eeb94abb3bcbc4075cda129d8a9"></a>XMC_VADC_GROUP_CONV_EMUX&#160;</td><td class="fielddoc">
<p>Settings pertaining to channels connected to VADC via EMUX </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gaedf62af4b76d15e91f0786165ec34fc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___v_a_d_c.html#gaedf62af4b76d15e91f0786165ec34fc2">XMC_VADC_GROUP_EMUXCODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the EMUX channel selection encoding scheme. Use <a class="el" href="group___v_a_d_c.html#gaedf62af4b76d15e91f0786165ec34fc2">XMC_VADC_GROUP_EMUXCODE_t</a> for this enumeration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaedf62af4b76d15e91f0786165ec34fc2a099d6b915907a8f95b4e7cd1f3735765"></a>XMC_VADC_GROUP_EMUXCODE_BINARY&#160;</td><td class="fielddoc">
<p>A linearly incrementing code serves are MUX-SEL </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaedf62af4b76d15e91f0786165ec34fc2a0d8e365e9f36b5fe5fd3e4c935e90e2f"></a>XMC_VADC_GROUP_EMUXCODE_GRAY&#160;</td><td class="fielddoc">
<p>The MUX-SEL is gray encoded </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gab9942639fc1d53fc2335990884b394ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___v_a_d_c.html#gab9942639fc1d53fc2335990884b394ba">XMC_VADC_GROUP_EMUXMODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the EMUX mode of operation. Use <a class="el" href="group___v_a_d_c.html#gab9942639fc1d53fc2335990884b394ba">XMC_VADC_GROUP_EMUXMODE_t</a> for this enumeration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggab9942639fc1d53fc2335990884b394baa1bbd7dfdc24faec8d522a758ae7fe880"></a>XMC_VADC_GROUP_EMUXMODE_SWCTRL&#160;</td><td class="fielddoc">
<p>Perform EMUX in Software control mode </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab9942639fc1d53fc2335990884b394baaf8c2244a73ee118a28dcb5bf8ac51685"></a>XMC_VADC_GROUP_EMUXMODE_STEADYMODE&#160;</td><td class="fielddoc">
<p>Perform EMUX in Steady mode (Use EMUX set value) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab9942639fc1d53fc2335990884b394baaad4e4c8354234a5c17a3aef01c761138"></a>XMC_VADC_GROUP_EMUXMODE_SINGLEMODE&#160;</td><td class="fielddoc">
<p>Perform EMUX in Single step mode </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab9942639fc1d53fc2335990884b394baa59b2f18f53866fc7d0cf76f34cea5939"></a>XMC_VADC_GROUP_EMUXMODE_SEQUENCEMODE&#160;</td><td class="fielddoc">
<p>Perform EMUX in Sequence mode </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga2a37056c647c7622f8102dae982336eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___v_a_d_c.html#ga2a37056c647c7622f8102dae982336eb">XMC_VADC_GROUP_INDEX_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the group indices. Use <a class="el" href="group___v_a_d_c.html#ga2a37056c647c7622f8102dae982336eb">XMC_VADC_GROUP_INDEX_t</a> for this enumeration. </p>

</div>
</div>
<a class="anchor" id="ga14a1cbb73bf2a92a3321aea14488f354"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___v_a_d_c.html#ga14a1cbb73bf2a92a3321aea14488f354">XMC_VADC_GROUP_IRQ_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the service request set used. Use <a class="el" href="group___v_a_d_c.html#ga14a1cbb73bf2a92a3321aea14488f354">XMC_VADC_GROUP_IRQ_t</a> for this enumeration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga14a1cbb73bf2a92a3321aea14488f354a063619a30aa8bb3d0bb37b0d32684d43"></a>XMC_VADC_GROUP_IRQ_KERNEL&#160;</td><td class="fielddoc">
<p>Refers to Group specific service request </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga14a1cbb73bf2a92a3321aea14488f354a674afc8864f13a19d6a067c517fd8f7d"></a>XMC_VADC_GROUP_IRQ_SHARED&#160;</td><td class="fielddoc">
<p>Refers to Module wide service request </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga7226349aef79a52f614eb5e75e3f55d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___v_a_d_c.html#ga7226349aef79a52f614eb5e75e3f55d9">XMC_VADC_GROUP_POWERMODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the power modes of a VADC Group. Use <a class="el" href="group___v_a_d_c.html#ga7226349aef79a52f614eb5e75e3f55d9">XMC_VADC_GROUP_POWERMODE_t</a> for this enumeration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga7226349aef79a52f614eb5e75e3f55d9a498fe251b61022633a09f361b4841586"></a>XMC_VADC_GROUP_POWERMODE_OFF&#160;</td><td class="fielddoc">
<p>Group is powered down </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7226349aef79a52f614eb5e75e3f55d9ae3c0c22d5402543c828f19565cce9e8d"></a>XMC_VADC_GROUP_POWERMODE_RESERVED1&#160;</td><td class="fielddoc">
<p>Reserved </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7226349aef79a52f614eb5e75e3f55d9a135622a1a6f56a7b8a88b55d38e973ca"></a>XMC_VADC_GROUP_POWERMODE_RESERVED2&#160;</td><td class="fielddoc">
<p>Reserved </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7226349aef79a52f614eb5e75e3f55d9a4394cff3deb041f3198a2c7c9ffaa25a"></a>XMC_VADC_GROUP_POWERMODE_NORMAL&#160;</td><td class="fielddoc">
<p>Group is powered up </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga9e8bcdf4c424a70b70e93368f1ef0021"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___v_a_d_c.html#ga9e8bcdf4c424a70b70e93368f1ef0021">XMC_VADC_GROUP_RS_PRIORITY_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the request source arbitration priority. Use <a class="el" href="group___v_a_d_c.html#ga9e8bcdf4c424a70b70e93368f1ef0021">XMC_VADC_GROUP_RS_PRIORITY_t</a> for this enumeration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga9e8bcdf4c424a70b70e93368f1ef0021ab10f26da7901b950046a056f9c0fa145"></a>XMC_VADC_GROUP_RS_PRIORITY_0&#160;</td><td class="fielddoc">
<p>Lowest priority for the request source </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga9e8bcdf4c424a70b70e93368f1ef0021aeaaca134d7c9e0b3e7fd359fb0597675"></a>XMC_VADC_GROUP_RS_PRIORITY_1&#160;</td><td class="fielddoc">
<p>Second lowest priority for the request source </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga9e8bcdf4c424a70b70e93368f1ef0021ab5e5ad7cfcc2afad2f6338221786812a"></a>XMC_VADC_GROUP_RS_PRIORITY_2&#160;</td><td class="fielddoc">
<p>Second highest priority for the request source </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga9e8bcdf4c424a70b70e93368f1ef0021a76caa4614542b8ecb59feda23d6fa1df"></a>XMC_VADC_GROUP_RS_PRIORITY_3&#160;</td><td class="fielddoc">
<p>Highest priority for the request source </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga4effb949346537c7a515c4f2ff542df5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___v_a_d_c.html#ga4effb949346537c7a515c4f2ff542df5">XMC_VADC_GROUP_STATE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the status of a VADC group (also known as kernel). Use <a class="el" href="group___v_a_d_c.html#ga4effb949346537c7a515c4f2ff542df5">XMC_VADC_GROUP_STATE_t</a> for this enumeration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga4effb949346537c7a515c4f2ff542df5a59cb41943a0b5ba6e7e6abcf95ea6775"></a>XMC_VADC_GROUP_STATE_IDLE&#160;</td><td class="fielddoc">
<p>Idle and can convert if requested </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4effb949346537c7a515c4f2ff542df5ae99f75960aa2617f81cbceb8346b24f3"></a>XMC_VADC_GROUP_STATE_BUSY&#160;</td><td class="fielddoc">
<p>Busy with an ongoing conversion </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga5db9760a1339267ae158e21ee3047859"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___v_a_d_c.html#ga5db9760a1339267ae158e21ee3047859">XMC_VADC_RESULT_ALIGN_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the alignment of the converted result. Use <a class="el" href="group___v_a_d_c.html#ga5db9760a1339267ae158e21ee3047859">XMC_VADC_RESULT_ALIGN_t</a> for this enumeration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga5db9760a1339267ae158e21ee3047859ade5aecb252a5ad2723252659ee392551"></a>XMC_VADC_RESULT_ALIGN_LEFT&#160;</td><td class="fielddoc">
<p>Always align result to left </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga5db9760a1339267ae158e21ee3047859aa99c3eed20b4f1aea940ba4fb2f981e7"></a>XMC_VADC_RESULT_ALIGN_RIGHT&#160;</td><td class="fielddoc">
<p>Always align result to right </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga1bf69f8d48c6280914a3a07c3330fd00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___v_a_d_c.html#ga1bf69f8d48c6280914a3a07c3330fd00">XMC_VADC_SCAN_LOAD_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the behavior of load event for the scan request source. Use <a class="el" href="group___v_a_d_c.html#ga1bf69f8d48c6280914a3a07c3330fd00">XMC_VADC_SCAN_LOAD_t</a> for this enumeration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga1bf69f8d48c6280914a3a07c3330fd00a5c3cd3659dbddaa0ef9804a09b4e868c"></a>XMC_VADC_SCAN_LOAD_OVERWRITE&#160;</td><td class="fielddoc">
<p>The old set of channels is discarded in favor of the new set awaiting conversion </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1bf69f8d48c6280914a3a07c3330fd00a958c98fcf8f114f4d2fc3090eb8a9a4d"></a>XMC_VADC_SCAN_LOAD_COMBINE&#160;</td><td class="fielddoc">
<p>The new set of channels are combined with the pending channels from previous set </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gacbab535e1de48116e5461c2ce7ff5077"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___v_a_d_c.html#gacbab535e1de48116e5461c2ce7ff5077">XMC_VADC_SCAN_TYPE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the type of scan request source to be used. It can choose between auto scan and background scan request source methods. Use <a class="el" href="group___v_a_d_c.html#gacbab535e1de48116e5461c2ce7ff5077">XMC_VADC_SCAN_TYPE_t</a> for this enumeration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggacbab535e1de48116e5461c2ce7ff5077adbbf7a9b221f5f9e373e6ecb770f64ce"></a>XMC_VADC_SCAN_TYPE_GROUPSCAN&#160;</td><td class="fielddoc">
<p>Auto scan mode of operation selected. Also called as Group scan </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggacbab535e1de48116e5461c2ce7ff5077a4f944a59ed1cc8477ce269673a38accb"></a>XMC_VADC_SCAN_TYPE_BACKGROUND&#160;</td><td class="fielddoc">
<p>Background scan mode of operation selected. Also called as Global scan </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gab518b0c522cae78b7434dfa327a540b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___v_a_d_c.html#gab518b0c522cae78b7434dfa327a540b1">XMC_VADC_SR_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the various service requests lines. Each group can raise up to 4 service requests independently. While all groups together have the possibility of raising 4 module wide service requests. Use <a class="el" href="group___v_a_d_c.html#gab518b0c522cae78b7434dfa327a540b1">XMC_VADC_SR_t</a> for this enumeration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggab518b0c522cae78b7434dfa327a540b1ab464629a3f5c67a4e6f9b738f2e02bb4"></a>XMC_VADC_SR_GROUP_SR0&#160;</td><td class="fielddoc">
<p>Group specific Service Request-0 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab518b0c522cae78b7434dfa327a540b1ab9c251a1ccf84c51844de7f15477c7d7"></a>XMC_VADC_SR_GROUP_SR1&#160;</td><td class="fielddoc">
<p>Group specific Service Request-1 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab518b0c522cae78b7434dfa327a540b1a5b88744b75b1e4a54fd1cc18e02cbe09"></a>XMC_VADC_SR_GROUP_SR2&#160;</td><td class="fielddoc">
<p>Group specific Service Request-2 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab518b0c522cae78b7434dfa327a540b1a12d1401a5acfec2e47607d71d559e453"></a>XMC_VADC_SR_GROUP_SR3&#160;</td><td class="fielddoc">
<p>Group specific Service Request-3 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab518b0c522cae78b7434dfa327a540b1ab49d758848e891936f2469b28c2f9ec5"></a>XMC_VADC_SR_SHARED_SR0&#160;</td><td class="fielddoc">
<p>Module Wide Common Service Request-0 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab518b0c522cae78b7434dfa327a540b1a89d85bc678a0e381e9180468ab543900"></a>XMC_VADC_SR_SHARED_SR1&#160;</td><td class="fielddoc">
<p>Module Wide Common Service Request-1 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab518b0c522cae78b7434dfa327a540b1aa8428db76657e0711415efe99767ef95"></a>XMC_VADC_SR_SHARED_SR2&#160;</td><td class="fielddoc">
<p>Module Wide Common Service Request-2 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab518b0c522cae78b7434dfa327a540b1a08fe0b7046ea542383fe053bb18c293a"></a>XMC_VADC_SR_SHARED_SR3&#160;</td><td class="fielddoc">
<p>Module Wide Common Service Request-3 </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga227aaa91c89c64c8402c869469276eb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___v_a_d_c.html#ga227aaa91c89c64c8402c869469276eb9">XMC_VADC_STARTMODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the mode of operation of a channel, when an ongoing conversion gets interrupted in between. Use <a class="el" href="group___v_a_d_c.html#ga227aaa91c89c64c8402c869469276eb9">XMC_VADC_STARTMODE_t</a> for this enumeration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga227aaa91c89c64c8402c869469276eb9a603a2da364137de801452b7680f9b1c0"></a>XMC_VADC_STARTMODE_WFS&#160;</td><td class="fielddoc">
<p>An ongoing conversion completes without interruption </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga227aaa91c89c64c8402c869469276eb9ab39b9f2a959b6ec9ac138e7c020c9aae"></a>XMC_VADC_STARTMODE_CIR&#160;</td><td class="fielddoc">
<p>An ongoing conversion can be interrupted and resumed later </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga227aaa91c89c64c8402c869469276eb9ad8450a9b8f9173ce4bb46c1f3d453e7b"></a>XMC_VADC_STARTMODE_CNR&#160;</td><td class="fielddoc">
<p>An ongoing conversion can be interrupted and never resumed </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gabac544a8f57b163dff69b444ed5f1d87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___v_a_d_c.html#gabac544a8f57b163dff69b444ed5f1d87">XMC_VADC_STATUS_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the return status after execution of VADC specific API's. Use <a class="el" href="group___v_a_d_c.html#gabac544a8f57b163dff69b444ed5f1d87">XMC_VADC_STATUS_t</a> for this enumeration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggabac544a8f57b163dff69b444ed5f1d87a2803f6adfdcdca2268420d41686991bb"></a>XMC_VADC_STATUS_SUCCESS&#160;</td><td class="fielddoc">
<p>Returned when the API has been able to fulfill the callers request </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggabac544a8f57b163dff69b444ed5f1d87a3634aa8e895380c02d16fba23f4212ec"></a>XMC_VADC_STATUS_ERROR&#160;</td><td class="fielddoc">
<p>Returned when the API cannot fulfill the request </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gaabd0d22cd15f13e6e49809a3b811b241"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___v_a_d_c.html#gaabd0d22cd15f13e6e49809a3b811b241">XMC_VADC_TRIGGER_EDGE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the edge sensitivity of the trigger signal which can assert a conversion. Use <a class="el" href="group___v_a_d_c.html#gaabd0d22cd15f13e6e49809a3b811b241">XMC_VADC_TRIGGER_EDGE_t</a> for this enumeration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaabd0d22cd15f13e6e49809a3b811b241a6f9b8e9ab9a1fa139050f87bf576ed85"></a>XMC_VADC_TRIGGER_EDGE_NONE&#160;</td><td class="fielddoc">
<p>No external trigger. Conversion request can be asserted by software </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaabd0d22cd15f13e6e49809a3b811b241a6c2f089ee48ddbe0709370aaff7e2eaa"></a>XMC_VADC_TRIGGER_EDGE_FALLING&#160;</td><td class="fielddoc">
<p>The falling edge of the external trigger can assert conversion request </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaabd0d22cd15f13e6e49809a3b811b241a8d7edb1df35ead7a90fd5640861228a5"></a>XMC_VADC_TRIGGER_EDGE_RISING&#160;</td><td class="fielddoc">
<p>The rising edge of the external trigger can assert conversion request </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaabd0d22cd15f13e6e49809a3b811b241a18d01d02320eb514e85edc66cd4b53e4"></a>XMC_VADC_TRIGGER_EDGE_ANY&#160;</td><td class="fielddoc">
<p>Both the edges can assert conversion request </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gab71bdae1d928ee308430626a761eab97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___v_a_d_c.html#gab71bdae1d928ee308430626a761eab97">XMC_VADC_TRIGGER_INPUT_SELECT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the external trigger input selection possibilities, to assert a conversion. Refer the VADC interconnects section of the reference manual for details of peripherals which can be used. Also refer xmc_vadc_map.h file for detailed definitions of the peripherals which can take the control of these enumeration items. Use <a class="el" href="group___v_a_d_c.html#gab71bdae1d928ee308430626a761eab97">XMC_VADC_TRIGGER_INPUT_SELECT_t</a> for this enumeration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggab71bdae1d928ee308430626a761eab97aa747e2d141cbdc20050f43294940282b"></a>XMC_VADC_REQ_TR_A&#160;</td><td class="fielddoc">
<p>Trigger select signal A </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab71bdae1d928ee308430626a761eab97a53e03e8e843f703d055a610b78291da2"></a>XMC_VADC_REQ_TR_B&#160;</td><td class="fielddoc">
<p>Trigger select signal B </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab71bdae1d928ee308430626a761eab97a7adc7d31060d1dcb69c97d78d9ebda36"></a>XMC_VADC_REQ_TR_C&#160;</td><td class="fielddoc">
<p>Trigger select signal C </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab71bdae1d928ee308430626a761eab97a816f02d251e2477463ca5e6dcca79f68"></a>XMC_VADC_REQ_TR_D&#160;</td><td class="fielddoc">
<p>Trigger select signal D </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab71bdae1d928ee308430626a761eab97ab62b73b50451cf3260dbb42164713bb1"></a>XMC_VADC_REQ_TR_E&#160;</td><td class="fielddoc">
<p>Trigger select signal E </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab71bdae1d928ee308430626a761eab97aa200440561888cab0204fb632adf0e17"></a>XMC_VADC_REQ_TR_F&#160;</td><td class="fielddoc">
<p>Trigger select signal F </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab71bdae1d928ee308430626a761eab97ac690682200ba8fc59f106563d4603998"></a>XMC_VADC_REQ_TR_G&#160;</td><td class="fielddoc">
<p>Trigger select signal G </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab71bdae1d928ee308430626a761eab97a4620708e2388498ad0efc07586fd7e30"></a>XMC_VADC_REQ_TR_H&#160;</td><td class="fielddoc">
<p>Trigger select signal H </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab71bdae1d928ee308430626a761eab97a29a5bc3d4ce50b42c98b568fa6d76d09"></a>XMC_VADC_REQ_TR_I&#160;</td><td class="fielddoc">
<p>Trigger select signal I </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab71bdae1d928ee308430626a761eab97a8676bf7270afed2fa20b8fe6b303829d"></a>XMC_VADC_REQ_TR_J&#160;</td><td class="fielddoc">
<p>Trigger select signal J </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab71bdae1d928ee308430626a761eab97a3fc091b811ad27e5aee89237e43b93c9"></a>XMC_VADC_REQ_TR_K&#160;</td><td class="fielddoc">
<p>Trigger select signal K </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab71bdae1d928ee308430626a761eab97ac94b58fec8333f270cb7c56791d1b957"></a>XMC_VADC_REQ_TR_L&#160;</td><td class="fielddoc">
<p>Trigger select signal L </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab71bdae1d928ee308430626a761eab97a495470ce5d64a1a25ba5709e5aa210b6"></a>XMC_VADC_REQ_TR_M&#160;</td><td class="fielddoc">
<p>Trigger select signal M </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab71bdae1d928ee308430626a761eab97a51236825d82a7f0ecc7110637f2e05e7"></a>XMC_VADC_REQ_TR_N&#160;</td><td class="fielddoc">
<p>Trigger select signal N </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab71bdae1d928ee308430626a761eab97aae6010c1367966e9c37248c877612b84"></a>XMC_VADC_REQ_TR_O&#160;</td><td class="fielddoc">
<p>Trigger select signal O </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab71bdae1d928ee308430626a761eab97aeb73c906f67594383011749f10240722"></a>XMC_VADC_REQ_TR_P&#160;</td><td class="fielddoc">
<p>Trigger select signal P </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga7039edfc0951575e3dcb158580452e8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XMC_DRIVER_VERSION_t XMC_VADC_GetDriverVersion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Driver version information. Refer XMC_DRIVER_VERSION_t structure definition.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Return version (major, minor and patch number) of the driver.<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gadf9c9021b0e1d538b9d6e6571a4dc2cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GLOBAL_BackgndAddMultipleChannels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const&#160;</td>
          <td class="paramname"><em>global_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>grp_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>ch_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_ptr</td><td>Pointer to the VADC module </td></tr>
    <tr><td class="paramname">grp_num</td><td>ID of the VADC group whose unprioritized channels have been assigned to background scan </td></tr>
    <tr><td class="paramname">ch_mask</td><td>Mask word indicating channels which form part of scan conversion sequence Bit location 0/1/2/3/4/5/6/7 represents channels-0/1/2/3/4/5/6/7 respectively. To Add the channel to the scan sequence enable the respective bit. Passing a 0x0 will clear all the previously selected channels <br />
Range: [0x0 to 0xFF] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Adds multiple channels to the scan sequence.<br />
<br />
Call this API to insert a multiple channels into the scan request source. This will be added to a scan sequence. The added channels will be a part of the conversion sequence when the next load event occurs. A call to this API would configure the register bit fields of BRSSEL.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga67c4d922e3b0a4abbaefde613a2a3c00">XMC_VADC_GLOBAL_BackgroundAddChannelToSequence()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga04933ff6939f277ded8a4c19c3ef8d38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GLOBAL_BackgroundAbortSequence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const&#160;</td>
          <td class="paramname"><em>global_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_ptr</td><td>Pointer to the VADC module </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Aborts an ongoing background scan conversion(sequence).<br />
<br />
An ongoing sequence can be aborted at any time. The scan unit picks the pending channels one by one from a pending register and requests for their conversion. This API essentially clears the channel pending register thus creating an illusion that there are no more channels left in the sequence. A call to this API would configure the registers BRSMR, BRSCTRL, GxARBPR(if group is available) to abort the current scan sequence.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga67c4d922e3b0a4abbaefde613a2a3c00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GLOBAL_BackgroundAddChannelToSequence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const&#160;</td>
          <td class="paramname"><em>global_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>grp_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>ch_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_ptr</td><td>Pointer to the VADC module </td></tr>
    <tr><td class="paramname">grp_num</td><td>ID of the VADC group whose unprioritized channels have been assigned to background scan Request source </td></tr>
    <tr><td class="paramname">ch_num</td><td>The unprioritized channel meant to be added to the scan sequence <br />
Range: [0x0 to 0x7] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Adds a channel to the background scan sequence.<br />
<br />
Call this API to insert a new single channel into the background scan request source. This will be added to the scan sequence. The added channel will be part of the conversion sequence when the next load event occurs. A call to this API would configure the register bit fields of BRSSEL.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>XMC_VADC_GLOBAL_BackgroundAddMultipleChannels()<br />
 </dd></dl>

<p>References <a class="el" href="group___v_a_d_c.html#ga5493b6e76383802d08a3a1b8198e566e">XMC_VADC_NUM_CHANNELS_PER_GROUP</a>.</p>

</div>
</div>
<a class="anchor" id="ga075844a45e021e56d4ee6e17a60dba02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GLOBAL_BackgroundClearReqSrcEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const&#160;</td>
          <td class="paramname"><em>global_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_ptr</td><td>Pointer to the VADC module </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Acknowledges the background scan conversion complete request source event.<br />
<br />
This API will clear the request source event that occurred. This will clear a interrupt if it was raised. A call to this API would configure the register bit field GLOBEFLAG.SEVGLB</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga0fdfbc995a8b763c210c044d2d979814">XMC_VADC_GLOBAL_BackgroundTriggerReqSrcEvent()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="gaf73c916feb89e889cf848fdbe6dd20e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GLOBAL_BackgroundDisableContinuousMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const&#160;</td>
          <td class="paramname"><em>global_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_ptr</td><td>Pointer to the VADC module </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables continuous conversion mode.<br />
<br />
Typically for a Background request source to generate conversion request, either a hardware trigger or a software request is a pre-requisite. Using autoscan feature it is possible to start the conversion once and allow the sequence to repeat without any further triggers. Once all channels belonging to a Background request source have been converted, a request source completion event is generated. Generation of this event can restart the Background sequence. By invoking this API the Autoscan mode of operations is disabled. A call to this API would configure the register bit field BRSMR.SCAN.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga3242cf2af1c5d920154c06ecf1aaff72">XMC_VADC_GLOBAL_BackgroundEnableContinuousMode()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="gaa2a92785dd1bfeda948728c15c7205f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GLOBAL_BackgroundDisableExternalTrigger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const&#160;</td>
          <td class="paramname"><em>global_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_ptr</td><td>Pointer to the VADC module </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables the trigger for background scan request source.<br />
 By using this API the trigger will be deactivated for the background scan request source. This will just deactivate the H/W trigger for the background scan request source. If any configuration was done to select the trigger input in BRSCTRL will be not be effected. A call to this API would configure the register bit field BRSMR.ENTR.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#gad94ac8b683df176e39944d0d2aff7501">XMC_VADC_GLOBAL_BackgroundEnableExternalTrigger()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga3242cf2af1c5d920154c06ecf1aaff72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GLOBAL_BackgroundEnableContinuousMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const&#160;</td>
          <td class="paramname"><em>global_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_ptr</td><td>Pointer to the VADC module </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables continuous conversion mode.<br />
<br />
Typically for a Background request source to generate conversion request, either a hardware trigger or a software request is needed. Using autoscan (continuous conversion)feature it is possible to start the conversion once and allow the sequence to repeat without any further triggers. Once all channels belonging to a Background request source have been converted, a request source completion event is generated. Generation of this event can restart the Background configure sequence. Every request source event will cause a load event to occur. A call to this API would access the register bit field BRSMR.SCAN.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>XMC_VADC_GROUP_BackgroundDisableContinuousMode()<br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="gad94ac8b683df176e39944d0d2aff7501"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GLOBAL_BackgroundEnableExternalTrigger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const&#160;</td>
          <td class="paramname"><em>global_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_ptr</td><td>Pointer to the VADC module </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables the trigger for background scan request source.<br />
<br />
By using this API the trigger will be activated for the scan request source. The trigger signal and trigger edge will be selected from the BRSCTRL register. The Selection of a input will be done by <a class="el" href="group___v_a_d_c.html#ga1dc24406fa9e95d845a8095728dcbce4">XMC_VADC_GLOBAL_BackgroundSelectTrigger()</a>. A call to this API would configure the register bit field BRSMR.ENTR.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga1dc24406fa9e95d845a8095728dcbce4">XMC_VADC_GLOBAL_BackgroundSelectTrigger()</a><br />
 <a class="el" href="group___v_a_d_c.html#gaa2a92785dd1bfeda948728c15c7205f7">XMC_VADC_GLOBAL_BackgroundDisableExternalTrigger()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga424f2cfadf7566780a290be6b34a63cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_VADC_GLOBAL_BackgroundGetNumChannelsPending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const&#160;</td>
          <td class="paramname"><em>global_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_ptr</td><td>Pointer to the VADC module </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 uint32_t Returns the total channels pending for conversion. <br />
Range: [0x0 to (0x8*number of groups)]</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Returns the number of pending channels.<br />
<br />
This API will read the pending channels register and will return the number of channels that are awaiting conversion. When a load event occurs the scan sequence is pushed to a pending conversion register. From the pending register the channels are taken up by the converter. When the API is called it would return the total number of channels pending (BRSPND[<b>grp_num</b>]).</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#gad6e756229d4b42d79c942f594895e880">XMC_VADC_GLOBAL_BackgroundIsChannelPending()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga2c6d9214be3444f9e6fc7944523c6b09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_VADC_GLOBAL_BackgroundGetReqSrcEventStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const&#160;</td>
          <td class="paramname"><em>global_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_ptr</td><td>Pointer to the VADC module </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool returns true if the service request event is raised. returns false if the service request event was not raised.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Determines if the request source event is asserted.<br />
 This API will get the status of the background scan request source event. Will return a true if the event has occurred for background scan. A call to this API would configure the register bit field GLOBEFLAG.SEVGLB.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2a669e00443f963546fdbe05a1eb0084"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GLOBAL_BackgroundInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const&#160;</td>
          <td class="paramname"><em>global_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___v_a_d_c.html#ga5df621dbf8385ce88a2fbe632a75d02d">XMC_VADC_BACKGROUND_CONFIG_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_ptr</td><td>Pointer to the VADC module </td></tr>
    <tr><td class="paramname">config</td><td>Pointer to initialization data structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Description:</dt><dd>Initializes the Background scan functional block.<br />
<br />
The BACKGROUND SCAN request source functional block converts channels of all VADC groups that have not been assigned as a priority channel (priority channels can be converted only by queue and scan). Background Scan request source converts the unprioritized channels. Unprioritized channels however can also be used with queue and scan. But a channel which is prioritized can not be used with background request source.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga63f7baff861c509eeb73f7794eff890a">XMC_VADC_GROUP_BackgroundEnableArbitrationSlot()</a><br />
 <a class="el" href="group___v_a_d_c.html#ga3058d26882687fd994756615eb7b5b3d">XMC_VADC_GROUP_BackgroundDisableArbitrationSlot()</a><br />
 <a class="el" href="group___v_a_d_c.html#ga1dc24406fa9e95d845a8095728dcbce4">XMC_VADC_GLOBAL_BackgroundSelectTrigger()</a><br />
 <a class="el" href="group___v_a_d_c.html#gacba7a4847be06bb2e71493eabf9bbb69">XMC_VADC_GLOBAL_BackgroundSelectGating()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="gad6e756229d4b42d79c942f594895e880"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_VADC_GLOBAL_BackgroundIsChannelPending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const&#160;</td>
          <td class="paramname"><em>global_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>grp_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>ch_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_ptr</td><td>Pointer to the VADC module </td></tr>
    <tr><td class="paramname">grp_num</td><td>ID of the VADC group whose unprioritized channels have been assigned to background scan RS </td></tr>
    <tr><td class="paramname">ch_num</td><td>The channel being audited for completion of conversion <br />
Range: [0x0 to 0x7] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool returns true if the channel is pending conversion else returns false</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Determine if the channel is pending.<br />
<br />
This API will check if the Channel in question is awaiting conversion in the current arbitration round. When a load event occurs the scan sequence is pushed to a pending conversion register. From the pending register the channels are taken up by the converter. This API would return true if the channel is found in the pending register (BRSPND[<b>grp_num</b>]).</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga424f2cfadf7566780a290be6b34a63cd">XMC_VADC_GLOBAL_BackgroundGetNumChannelsPending()</a><br />
 </dd></dl>

<p>References <a class="el" href="group___v_a_d_c.html#ga5493b6e76383802d08a3a1b8198e566e">XMC_VADC_NUM_CHANNELS_PER_GROUP</a>.</p>

</div>
</div>
<a class="anchor" id="gacba7a4847be06bb2e71493eabf9bbb69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GLOBAL_BackgroundSelectGating </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const&#160;</td>
          <td class="paramname"><em>global_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>input_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_ptr</td><td>Pointer to the VADC module </td></tr>
    <tr><td class="paramname">input_num</td><td>Module input signal meant to be selected as gating input Accepts enum <a class="el" href="group___v_a_d_c.html#gaa16f1136a4a4efddcd67ebd5fc69bc9f">XMC_VADC_GATE_INPUT_SELECT_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Select Gating signal for Background request source.<br />
<br />
Passage of the trigger input to the request source can be controlled via a gating signal. Any one of the 16 input lines can be chosen as a gating signal. Trigger signal can be given to the Background request source only when the gating signal's active level is detected. Additionally the GxBRSMR.ENGT has to be configured for the gating signal's active level. A call to this API would configure the register bit field BRSCTRL.GTSEL.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga1dc24406fa9e95d845a8095728dcbce4">XMC_VADC_GLOBAL_BackgroundSelectTrigger()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga1dc24406fa9e95d845a8095728dcbce4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GLOBAL_BackgroundSelectTrigger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const&#160;</td>
          <td class="paramname"><em>global_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>input_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_ptr</td><td>Pointer to the VADC module </td></tr>
    <tr><td class="paramname">input_num</td><td>Choice of the input earmarked as a trigger line Accepts enum <a class="el" href="group___v_a_d_c.html#gab71bdae1d928ee308430626a761eab97">XMC_VADC_TRIGGER_INPUT_SELECT_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Select Trigger signal for Background request source.<br />
<br />
A Background request source will raise conversion request only if there were either a request from application or occurrence of a hardware trigger. This API selects one of the 16 input lines as a trigger line. This is needed when a hardware trigger is needed for the conversion of the Background request source. Refer to the reference manual to determine the signal that needs to be connected. A call to this API would configure the register bit field BRSCTRL.XTSEL.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#gacba7a4847be06bb2e71493eabf9bbb69">XMC_VADC_GLOBAL_BackgroundSelectGating()</a><br />
 <a class="el" href="group___v_a_d_c.html#gad94ac8b683df176e39944d0d2aff7501">XMC_VADC_GLOBAL_BackgroundEnableExternalTrigger()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga8c8708cf159e5c190926e0873f4055ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GLOBAL_BackgroundSetGatingMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const&#160;</td>
          <td class="paramname"><em>global_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga4db02e3b835b8cad941ab60ae288f8c8">XMC_VADC_GATEMODE_t</a>&#160;</td>
          <td class="paramname"><em>mode_sel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
    <tr><td class="paramname">mode_sel</td><td>Select how the gating is applied to the background scan request source </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p><b>Details of function</b><br />
 Selects the gating mode of background request source.<br />
<br />
Passage of the trigger input to the request source can be controlled via a gating signal. This API determines how the gating signal behaves, either active low or active high. If gating signal needs to ignored XMC_VADC_GATEMODE_IGNORE should be used as the <em>mode_sel</em>. A call to this API would configure the register bit field BRSMR.ENGT.</p>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#gacba7a4847be06bb2e71493eabf9bbb69">XMC_VADC_GLOBAL_BackgroundSelectGating()</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="ga7f53b56af0d025239dbbcd80af5a5481"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GLOBAL_BackgroundSetReqSrcEventInterruptNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const&#160;</td>
          <td class="paramname"><em>global_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#gab518b0c522cae78b7434dfa327a540b1">XMC_VADC_SR_t</a>&#160;</td>
          <td class="paramname"><em>sr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_ptr</td><td>Constant pointer to the VADC module </td></tr>
    <tr><td class="paramname">sr</td><td>The service request to which the global request source event is connected. Refer <a class="el" href="group___v_a_d_c.html#gab518b0c522cae78b7434dfa327a540b1">XMC_VADC_SR_t</a> enum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Binds the background request source event to one of the 4 shared service requests.<br />
<br />
 This API binds the background request source event to one of the 4 module wide shared service requests. Sets GLOBEVNP register with the corresponding <em>sr</em> line.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#gaa9738610187d2b11716c5faa07e214c7">XMC_VADC_GLOBAL_SetResultEventInterruptNode()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga599af86b8424e4e378f20dc1952b4cba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GLOBAL_BackgroundTriggerConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const&#160;</td>
          <td class="paramname"><em>global_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_ptr</td><td>Pointer to the VADC module </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Generates conversion request (Software initiated conversion).<br />
<br />
A conversion request can be raised either upon detection of a hardware trigger, or by software. This API forces the scan unit to generate a conversion request to the analog converter. It is assumed that the background scan has already been filled up with entries. A call to this API would set the register bit field BRSMR.LDEV.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0fdfbc995a8b763c210c044d2d979814"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GLOBAL_BackgroundTriggerReqSrcEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const&#160;</td>
          <td class="paramname"><em>global_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_ptr</td><td>Pointer to the VADC module </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Manually asserts the conversion complete request source event.<br />
<br />
This API will set the request source event for background scan. This will trigger a interrupt if the service node pointer for the scan has been configured. A call to this API would configure the register bit field GLOBEFLAG.SEVGLB.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2b17cb1350c5d568783f96f721348928"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GLOBAL_BindGroupToEMux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const&#160;</td>
          <td class="paramname"><em>global_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>emuxif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_ptr</td><td>Constant pointer to the VADC module </td></tr>
    <tr><td class="paramname">emuxif</td><td>The EMUX interface<br />
Range[0x0 - 0x1] </td></tr>
    <tr><td class="paramname">group</td><td>The VADC group which must be bound to the desired emux</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Binds a VADC <em>group</em> to an EMUX interface specified in <em>emuxif</em>.<br />
<br />
Selects which group's scan request source will control the EMUX interface (set of control select lines for the EMUX). By passing <b>group</b> it would configure that group's scan request source to control the EMUX select lines of the set <b>emuxif</b>.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gae6a4d9c2ba0621bef3d077e899754bd9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GLOBAL_ClearEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const&#160;</td>
          <td class="paramname"><em>global_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>event_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_ptr</td><td>Constant pointer to the VADC module </td></tr>
    <tr><td class="paramname">event_type</td><td>Event that must be acknowledged Use the enum <a class="el" href="group___v_a_d_c.html#gaa69659f0a647c58e6a0c434759a5f358">XMC_VADC_GLOBAL_EVENT_t</a> to create a mask to be used with this argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Acknowledges an event that has been asserted manually or automatically.<br />
<br />
 This API acknowledges the requested event by clearing GLOBEFLAG sticky flag.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gaf5ec0ac1eedfeedd49e8f84e0e1147fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GLOBAL_ClockInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const&#160;</td>
          <td class="paramname"><em>global_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___v_a_d_c___g_l_o_b_a_l___c_l_o_c_k__t.html">XMC_VADC_GLOBAL_CLOCK_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_ptr</td><td>Constant pointer to the VADC module. </td></tr>
    <tr><td class="paramname">config</td><td>Pointer to the data structure containing clock configuration data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configures the VADC clock.<br />
<br />
Sets up the clock configuration of the VADC module using the config structure pointed by <em>config</em>. The clock to the analog converter and to the request source arbiter is configured by setting the GLOBCFG register.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gaa02b1286238761c5d6c1a42f552463df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GLOBAL_DisableModule </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables the VADC module.<br />
<br />
This API would gate the clock to the VADC module (if applicable). Also this API would put the VADC module into the reset state(if applicable) by asserting the appropriate registers. This API would invoke <a class="el" href="group___s_c_u.html#gab0af70f90b9a1f24d3a0a4764543d833">XMC_SCU_CLOCK_GatePeripheralClock()</a> and XMC_SCU_RESET_AssertPeripheralReset() if needed.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga9751f6e7d01d01dcd69f939cc7acfc48">XMC_VADC_GLOBAL_EnableModule()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaeada77d79207d448a245c39960cdc048"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GLOBAL_DisableModuleClock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const&#160;</td>
          <td class="paramname"><em>global_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_ptr</td><td>Constant pointer to the VADC module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables the VADC module clock.<br />
<br />
 After this API call, no conversion will occur. Call <a class="el" href="group___v_a_d_c.html#ga70fe4b872487d7243db7622c3f9b5359">XMC_VADC_GLOBAL_EnableModuleClock()</a> to enable the VADC module later in the program.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga3a03902554eb8c9ff9fdfb6f3e76dc2c">XMC_VADC_GLOBAL_Init()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga91a285da9e41bf4ef81bec9eef95be57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GLOBAL_DisablePostCalibration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const&#160;</td>
          <td class="paramname"><em>global_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>group_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_ptr</td><td>Constant pointer to the VADC module </td></tr>
    <tr><td class="paramname">group_number</td><td>group number whose post calibration feature is to be disabled. <br />
 Range[0x0 to 0x3] Accepts the enum <a class="el" href="group___v_a_d_c.html#ga2a37056c647c7622f8102dae982336eb">XMC_VADC_GROUP_INDEX_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables the post calibration for a particular group specified as <em>group_number</em>.<br />
<br />
 It configures the DPCAL0 bit of GLOBCFG register to disable the post calibration feature. Call XMC_VADC_GLOBAL_Enable() and <a class="el" href="group___v_a_d_c.html#gaf5ec0ac1eedfeedd49e8f84e0e1147fa">XMC_VADC_GLOBAL_ClockInit()</a> before calling this API in sequence. Calling the API <a class="el" href="group___v_a_d_c.html#ga10affbd1419c11a15022f6cf6cfc1f64">XMC_VADC_GLOBAL_EnablePostCalibration()</a> can enable back the calibration feature at runtime.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>XMC_VADC_GLOBAL_Enable()<br />
 <a class="el" href="group___v_a_d_c.html#gaf5ec0ac1eedfeedd49e8f84e0e1147fa">XMC_VADC_GLOBAL_ClockInit()</a><br />
 <a class="el" href="group___v_a_d_c.html#ga91a285da9e41bf4ef81bec9eef95be57">XMC_VADC_GLOBAL_DisablePostCalibration()</a><br />
 None </dd></dl>

</div>
</div>
<a class="anchor" id="ga3fdc0facec70f34cd38d018caca13141"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GLOBAL_DisableSleepMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const&#160;</td>
          <td class="paramname"><em>global_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_ptr</td><td>Constant pointer to the VADC module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Ignores the sleep mode request for the VADC.<br />
<br />
With the sleep feature enabled, the module will respond to sleep requests by going into a low power mode. It resets the EDIS bit of CLC register for enabling the sleep mode.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga3693d7ff09be4b5594ca160dafb28064">XMC_VADC_GLOBAL_EnableSleepMode()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8413b5d67494882776c5500b765424d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GLOBAL_DisableStartupCalibration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const&#160;</td>
          <td class="paramname"><em>global_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_ptr</td><td>Constant pointer to the VADC module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables the startup calibration feature of the VADC module.<br />
<br />
 It configures the SUCAL bit of GLOBCFG register to disable the startup calibration feature. Calling the API XMC_VADC_GLOBAL_EnsableStartupCalibration() can enable the calibration feature at runtime.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga9751f6e7d01d01dcd69f939cc7acfc48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GLOBAL_EnableModule </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables the VADC module.<br />
<br />
This API would ungate the clock to the VADC module (if applicable). Also this API would bring the VADC module out of reset state(if applicable), by asserting the appropriate registers. This API would invoke <a class="el" href="group___s_c_u.html#ga702904d10b6e6c6a55db381763fd322f">XMC_SCU_CLOCK_UngatePeripheralClock()</a> and XMC_SCU_RESET_DeassertPeripheralReset() if needed. Directly accessed register is COMPARATOR.ORCCTRL (Refer to the errata for XMC1100).</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#gaa02b1286238761c5d6c1a42f552463df">XMC_VADC_GLOBAL_DisableModule()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga70fe4b872487d7243db7622c3f9b5359"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GLOBAL_EnableModuleClock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const&#160;</td>
          <td class="paramname"><em>global_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_ptr</td><td>Constant pointer to the VADC module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables the VADC module clock.<br />
<br />
 Call this API before any further configuration of VADC. It sets the DISR bit of CLC register to enable.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga3a03902554eb8c9ff9fdfb6f3e76dc2c">XMC_VADC_GLOBAL_Init()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga10affbd1419c11a15022f6cf6cfc1f64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GLOBAL_EnablePostCalibration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const&#160;</td>
          <td class="paramname"><em>global_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>group_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_ptr</td><td>Constant pointer to the VADC module </td></tr>
    <tr><td class="paramname">group_number</td><td>group number whose post calibration feature is to be enabled. <br />
 Range[0x0 to 0x3] Accepts the enum <a class="el" href="group___v_a_d_c.html#ga2a37056c647c7622f8102dae982336eb">XMC_VADC_GROUP_INDEX_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables the post calibration for a particular group specified as <em>group_number</em>.<br />
<br />
 It configures the DPCAL0 bit of GLOBCFG register to enable the post calibration feature. Calling the API <a class="el" href="group___v_a_d_c.html#ga91a285da9e41bf4ef81bec9eef95be57">XMC_VADC_GLOBAL_DisablePostCalibration()</a> can disable the calibration feature at runtime.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga91a285da9e41bf4ef81bec9eef95be57">XMC_VADC_GLOBAL_DisablePostCalibration()</a><br />
 None </dd></dl>

</div>
</div>
<a class="anchor" id="ga3693d7ff09be4b5594ca160dafb28064"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GLOBAL_EnableSleepMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const&#160;</td>
          <td class="paramname"><em>global_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_ptr</td><td>Constant pointer to the VADC module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables VADC module to sleep if a sleep request comes.<br />
<br />
It resets the EDIS bit of CLC register for enabling the sleep mode.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga3fdc0facec70f34cd38d018caca13141">XMC_VADC_GLOBAL_DisableSleepMode()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2e6a5c936529f8bf35c81f662e5a57c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___v_a_d_c.html#ga42e972915a3d2ac3b46847a4d5228c64">XMC_VADC_FAST_COMPARE_t</a> XMC_VADC_GLOBAL_GetCompareResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const&#160;</td>
          <td class="paramname"><em>global_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_ptr</td><td>Constant pointer to the VADC module </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>compare high or low. Refer <a class="el" href="group___v_a_d_c.html#ga42e972915a3d2ac3b46847a4d5228c64">XMC_VADC_FAST_COMPARE_t</a> enum</dd>
<dd>
None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Determines the result of fast compare operation.<br />
<br />
 This API returns the result of fast compare operation provided the valid flag in the global result register GLOBRES is set.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga7ae7ddbf6a4e2bc626ada83bcf72b56a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_VADC_GLOBAL_GetDetailedResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const&#160;</td>
          <td class="paramname"><em>global_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_ptr</td><td>Constant pointer to the VADC module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t Complete global result register value GLOBRES</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Retrieves the complete result from the global result register associated with the <em>global_ptr</em>.<br />
<br />
 This API audits the result register GLOBRES for the validity of the data. If the validity is assured, data is first read the global result register, cached locally next and subsequently returned to the caller.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga13f09c6935ff21f3c034199fd3bfe825">XMC_VADC_GLOBAL_GetResult()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga13f09c6935ff21f3c034199fd3bfe825"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___v_a_d_c.html#gadb07d5ea1ef8b662d9550d22944825d4">XMC_VADC_RESULT_SIZE_t</a> XMC_VADC_GLOBAL_GetResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const&#160;</td>
          <td class="paramname"><em>global_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_ptr</td><td>Constant pointer to the VADC module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XMC_VADC_RESULT_SIZE_t 16 bit result register value.<br />
 Range[0x0 - 0X0FFF]</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Retrieves the conversion result from the global result register associated with the <em>global_ptr</em>.<br />
<br />
 This is a lightweight version of <a class="el" href="group___v_a_d_c.html#ga7ae7ddbf6a4e2bc626ada83bcf72b56a">XMC_VADC_GLOBAL_GetDetailedResult()</a>. The behavior is exactly the same, just that it is only the 16 bit numeric result returned back to the application instead of the complete GLOBRES register value.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga7ae7ddbf6a4e2bc626ada83bcf72b56a">XMC_VADC_GLOBAL_GetDetailedResult()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3a03902554eb8c9ff9fdfb6f3e76dc2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GLOBAL_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const&#160;</td>
          <td class="paramname"><em>global_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___v_a_d_c___g_l_o_b_a_l___c_o_n_f_i_g__t.html">XMC_VADC_GLOBAL_CONFIG_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_ptr</td><td>Constant pointer to the VADC module. </td></tr>
    <tr><td class="paramname">config</td><td>Pointer to initialization data structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Initializes the VADC global module with the associated configuration structure pointed by <em>config</em>.<br />
<br />
 It enables the global access to registers by configuring reset and clock un-gating for selected devices. It initializes global class, boundary , result resources by setting GLOBICLASS,GLOBBOUND,GLOBRCR registers. It also configures the global analog and digital clock dividers by setting GLOBCFG register. Refer related API's to change the configurations later in the program.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#gaf5ec0ac1eedfeedd49e8f84e0e1147fa">XMC_VADC_GLOBAL_ClockInit()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga2e65df86680f0bce4057ea37a495445d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GLOBAL_InputClassInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const&#160;</td>
          <td class="paramname"><em>global_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___v_a_d_c___g_l_o_b_a_l___c_l_a_s_s__t.html">XMC_VADC_GLOBAL_CLASS_t</a>&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___v_a_d_c.html#gadf393a8c811d7ee6601688797e616646">XMC_VADC_GROUP_CONV_t</a>&#160;</td>
          <td class="paramname"><em>conv_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>set_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_ptr</td><td>Constant pointer to the VADC module. </td></tr>
    <tr><td class="paramname">config</td><td>Conversion class parameter structure </td></tr>
    <tr><td class="paramname">conv_type</td><td>configure the input call for either standard conversion or EMUX related conversion. </td></tr>
    <tr><td class="paramname">set_num</td><td>Conversion class set<br />
 Range: [0x0, 0x1]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Description:</dt><dd>Configures the ADC conversion settings like sample time and resolution.<br />
<br />
Sets up the conversion settings for vadc global resource associated with <em>config</em> structure. It configures the conversion class properties like sampling time and resolution for selected <em>conv_type</em> channels. It initializes the GLOBALICLASS register specified by <em>set_num</em> with the required settings.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gaa30f659438385897376765d156118654"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GLOBAL_ResultInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const&#160;</td>
          <td class="paramname"><em>global_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___v_a_d_c___r_e_s_u_l_t___c_o_n_f_i_g__t.html">XMC_VADC_RESULT_CONFIG_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_ptr</td><td>Constant pointer to the VADC global module </td></tr>
    <tr><td class="paramname">config</td><td>Pointer to result configuration data structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Initializes global result register.<br />
<br />
Initializes Global Result Register with specified settings configured in the <em>config</em> structure.<br />
<br />
 This API results in configuration of GLOBRCR register. This helps in configuring the Data reduction mode, global result event , wait for read mode on the GLOBRES register.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gae55dd1c7a50cabe7d188e56e79319dc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GLOBAL_SetBoundaries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const&#160;</td>
          <td class="paramname"><em>global_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>boundary0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>boundary1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_ptr</td><td>Constant pointer to the VADC module. </td></tr>
    <tr><td class="paramname">boundary0</td><td>Boundary-0 Value<br />
Range[0 - 4095] </td></tr>
    <tr><td class="paramname">boundary1</td><td>Boundary-1 Value<br />
Range[0 - 4095]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Programs the boundaries with <em>boundary0</em> and boundary1 for result comparison.<br />
<br />
 These two boundaries can serve as absolute boundaries. They defines a range against which the result of a conversion can be compared. In the fast compare mode, the two boundaries provide hysteresis capability to a compare value. In any case, these boundary values entered here form a boundary pallete. There are dedicated upper and lower boundary registers GLOBBOUND0 and GLOBBOUND1 who will derive their values from this palette.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gac239d3389baab5175eca043b6ac606b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GLOBAL_SetCompareValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const&#160;</td>
          <td class="paramname"><em>global_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___v_a_d_c.html#gadb07d5ea1ef8b662d9550d22944825d4">XMC_VADC_RESULT_SIZE_t</a>&#160;</td>
          <td class="paramname"><em>compare_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_ptr</td><td>Constant pointer to the VADC module </td></tr>
    <tr><td class="paramname">compare_val</td><td>Compare value which the result of a conversion will be compared against. <br />
Range[0x0 - 0X0FFF]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Set compare value in the global result register for fast compare mode.<br />
<br />
 The result of a conversion will directly be compared to the compare value entered as part of <em>compare_val</em>. The prerequisite is that the channel associated with this global register must select an ICLASS which has the conversion mode configured as fast compare mode. Call <a class="el" href="group___v_a_d_c.html#ga2e6a5c936529f8bf35c81f662e5a57c9">XMC_VADC_GLOBAL_GetCompareResult()</a> after this API to</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gaa9738610187d2b11716c5faa07e214c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GLOBAL_SetResultEventInterruptNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const&#160;</td>
          <td class="paramname"><em>global_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#gab518b0c522cae78b7434dfa327a540b1">XMC_VADC_SR_t</a>&#160;</td>
          <td class="paramname"><em>sr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_ptr</td><td>Constant pointer to the VADC module </td></tr>
    <tr><td class="paramname">sr</td><td>The service request to which the global result event is connected. Refer <a class="el" href="group___v_a_d_c.html#gab518b0c522cae78b7434dfa327a540b1">XMC_VADC_SR_t</a> enum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Binds the global result event to one of the 4 shared service requests.<br />
<br />
 This API binds the global result event to one of the 4 module wide shared service requests .Sets GLOBEVNP register with the corresponding <em>sr</em> line.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga7f53b56af0d025239dbbcd80af5a5481">XMC_VADC_GLOBAL_BackgroundSetReqSrcEventInterruptNode()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9cdce2c0d6b53beb6312c43ccbaee499"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GLOBAL_SHS_EnableAcceleratedMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga11a8b12d7d98d3a9b81c95f9d5c671c4">XMC_VADC_GLOBAL_SHS_t</a> *const&#160;</td>
          <td class="paramname"><em>shs_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga2a37056c647c7622f8102dae982336eb">XMC_VADC_GROUP_INDEX_t</a>&#160;</td>
          <td class="paramname"><em>group_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shs_ptr</td><td>Constant pointer to the VADC Sample and hold module </td></tr>
    <tr><td class="paramname">group_num</td><td>group number for which the accelerated mode needs to be enabled.<br />
Range: [0x0 to 0x1]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables the Accelerated timing mode.<br />
<br />
This API is needed when a switch from compatible mode to accelerated mode of conversion is needed. In this mode the ADC module will convert the input depending on the value stored in the SST bit of the SHS0_TIMCFGx. This API would configure the accelerated mode in the SHS0_TIMCFG0 and SHS0_TIMCFG1 registers.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gac97ed253a1995c6a76a03653d267e130"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GLOBAL_SHS_SetClockDivider </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga11a8b12d7d98d3a9b81c95f9d5c671c4">XMC_VADC_GLOBAL_SHS_t</a> *const&#160;</td>
          <td class="paramname"><em>shs_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>divs_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shs_ptr</td><td>Constant pointer to the VADC Sample and hold module </td></tr>
    <tr><td class="paramname">divs_value</td><td>The clock divider value that is possible <br />
Range:[0x0 to 0xF] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configure Sample and hold clock divider value.<br />
<br />
API would initialize the clock divider configuration. This determines the frequency of conversion of the Sample and hold converter.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6b3ce19bc8632b14e43be44b92d79539"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GLOBAL_SHS_SetShortSampleTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga11a8b12d7d98d3a9b81c95f9d5c671c4">XMC_VADC_GLOBAL_SHS_t</a> *const&#160;</td>
          <td class="paramname"><em>shs_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga2a37056c647c7622f8102dae982336eb">XMC_VADC_GROUP_INDEX_t</a>&#160;</td>
          <td class="paramname"><em>group_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sst_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shs_ptr</td><td>Constant pointer to the VADC Sample and hold module </td></tr>
    <tr><td class="paramname">group_num</td><td>group number for which the accelerated mode needs to be enabled.<br />
Range: [0x0 to 0x1] </td></tr>
    <tr><td class="paramname">sst_value</td><td>Value of short sample time that needs to be configured.<br />
 Range: [0x0 to 0x3F]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configures the Accelerated timing mode sample time.<br />
<br />
This API is needed when a switch from compatible mode to accelerated mode of conversion is needed. In Accelerated mode the ADC module will convert the input depending on the value stored in the SST bit of the SHS0_TIMCFGx. This API would configure the shot sample time either in SHS0_TIMCFG0.SST or SHS0_TIMCFG1.SST .</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8c267fe37fbdf8654d14f46acf2d3b86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GLOBAL_StartupCalibration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const&#160;</td>
          <td class="paramname"><em>global_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_ptr</td><td>Constant pointer to the VADC module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables the startup calibration feature of the VADC module.<br />
<br />
 It configures the SUCAL bit of GLOBCFG register to enable the startup calibration feature. After turning it on, it loops until all active groups finish calibration. Call XMC_VADC_GLOBAL_Enable() and <a class="el" href="group___v_a_d_c.html#gaf5ec0ac1eedfeedd49e8f84e0e1147fa">XMC_VADC_GLOBAL_ClockInit()</a> before calling this API in sequence. Calling the API <a class="el" href="group___v_a_d_c.html#ga8413b5d67494882776c5500b765424d6">XMC_VADC_GLOBAL_DisableStartupCalibration()</a> can disable the calibration feature at runtime.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>XMC_VADC_GLOBAL_Enable()<br />
 <a class="el" href="group___v_a_d_c.html#gaf5ec0ac1eedfeedd49e8f84e0e1147fa">XMC_VADC_GLOBAL_ClockInit()</a><br />
 None </dd></dl>

</div>
</div>
<a class="anchor" id="gaa4880cd1755d46ad1b0bd775d4e0ac49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GLOBAL_TriggerEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga8cc559b855e4da85ee2f48bcd98405cb">XMC_VADC_GLOBAL_t</a> *const&#160;</td>
          <td class="paramname"><em>global_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>event_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_ptr</td><td>Constant pointer to the VADC module </td></tr>
    <tr><td class="paramname">event_type</td><td>Desired event that must be manually asserted Use the enum <a class="el" href="group___v_a_d_c.html#gaa69659f0a647c58e6a0c434759a5f358">XMC_VADC_GLOBAL_EVENT_t</a> to create a mask to be used with this argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Manually asserts an event that can lead to an interrupt.<br />
<br />
 This API manually asserts the requested event (Background request source event or a global result event) by setting the GLOBEVFLAG register with the specified <em>event_type</em>.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gaf2c5118b682ff5c4820400ea362b3cc7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_AddResultToFifo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>res_reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
    <tr><td class="paramname">res_reg</td><td>Register which is required to be a part of results FIFO <br />
Range: [0x0 to 0xF] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Adds result register to Result FIFO.<br />
<br />
Sometimes, the rate of consumption of results by application software may not match the rate at which the results are produced. A Result FIFO thus helps a slow consumer to read out results without loss of data. When a result register is added to fifo, it is in fact chained to its higher numbered neighbor. For example, if Result Register-5 is to be added to FIFO, it gets chained to Result Register-6. Results are written to Register-6 while the same can be read out of Register-5 leisurely by software. A call to this API would configure the register bit field GxRCR.FEN.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>The FIFO is always read by the software with the lowest numbered result register. The hardware will write the results from the highest numbered result register.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3058d26882687fd994756615eb7b5b3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_BackgroundDisableArbitrationSlot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group which may receive a conversion request from background request source </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables arbitration slot of the Background request source.<br />
<br />
If the Background request source must have its conversion request considered by the arbiter, it must participate in the arbitration rounds. Even if a load event occurs the Background channel can only be converted when the arbiter comes to the Background slot.A call to this API will lead to all conversions request by Background to be blocked. A call to this API would configure the register bit field GxARBPR.ASEN2</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga63f7baff861c509eeb73f7794eff890a">XMC_VADC_GROUP_BackgroundEnableArbitrationSlot()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga63f7baff861c509eeb73f7794eff890a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_BackgroundEnableArbitrationSlot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group which may receive a conversion request from background request source</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables arbitration slot of the Background request source.<br />
<br />
If the Background request source must have its conversion request considered by the arbiter, it must participate in the arbitration rounds. Even if a load event occurs the Background channel can only be converted when the arbiter comes to the Background slot. Thus this must be enabled if any conversion need to take place. A call to this API would configure the register bit field GxARBPR.ASEN2.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga3058d26882687fd994756615eb7b5b3d">XMC_VADC_GROUP_BackgroundDisableArbitrationSlot()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga76846cba41d6ea170992e6b5ea61d957"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_ChannelClearEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>ch_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
    <tr><td class="paramname">ch_num</td><td>Channel whose channel event is to be acknowledged <br />
Range: [0x0 to 0x7] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Acknowledges a Channel event.<br />
<br />
When a channel event is raised after the conversion of that channel, it has to be cleared. This API would clear the Channel event of a particular channel if it has occurred. A call to this API would configure the register bit fields of GxCEFCLR.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga495788bc643c2c9d51444edddcb0d3cb">XMC_VADC_GROUP_ChannelTriggerEvent()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="gae5c0071a3d6728dad1f4ddcb06f6bed8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t XMC_VADC_GROUP_ChannelGetResultRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>ch_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
    <tr><td class="paramname">ch_num</td><td>Channel whose associated result register is to be found <br />
Range: [0x0 to 0x7] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint8_t returns the Group result register to which it is linked to. <br />
Range: [0x0 to 0xF]</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Returns the result register associated with this channel.<br />
<br />
 There are upto 16 result registers which a channel can choose from to store the results of conversion. This returns only the group related result registers. A call to this API would access the register bit field GxCHCTR.RESREG.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga88e0f4deb5ddd8a85c786a6291327fa6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_ChannelInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>ch_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___v_a_d_c___c_h_a_n_n_e_l___c_o_n_f_i_g__t.html">XMC_VADC_CHANNEL_CONFIG_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
    <tr><td class="paramname">ch_num</td><td>The channel being initialized <br />
Range: [0x0 to 0x7] </td></tr>
    <tr><td class="paramname">config</td><td>Pointer to initialization data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Initializes the ADC channel for conversion.<br />
<br />
This API will do the channel related initializations. This includes configuration of the CHCTR settings and boundary flag settings. This must be called in the application in order to enable the conversion of a channel. After a request source has been initialized this API has to be called for each channel that has to be converted. A call to this API would configure the registers GxCHCTR GxBFL GxALIAS GxCHASS GxBFLC(depending on device) in order to configure the channel.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf864b20c64882d1c78712892dbeae965"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_VADC_GROUP_ChannelIsResultOutOfBounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>ch_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
    <tr><td class="paramname">ch_num</td><td>Channel whose input was converted <br />
Range: [0x0 to 0x7] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool Returns true if there was violation w.r.t the specified boundaries.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Determines if the result of the channel confines with the specified boundaries.<br />
<br />
An application may not necessarily always need to know the exact value of the converted result, but merely an indication if the generated result is within stipulated boundaries. Generation of Channel event can be subject to channel event generation criteria (Generate always, Never generate, Generate if result is out of bounds, Generate if result is within bounds). When interrupts are not enabled, this API can be used to determine the nature of the result. A call to this API would access the registers GxCHCTR and GxCEFLAG in order to determine if a violation has occured.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga8b2d0baaf1e9113c61ef28c7d45e9feb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_ChannelSetEventInterruptNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>ch_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___v_a_d_c.html#gab518b0c522cae78b7434dfa327a540b1">XMC_VADC_SR_t</a>&#160;</td>
          <td class="paramname"><em>sr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
    <tr><td class="paramname">ch_num</td><td>Channel whose channel event is to be connected to a service request line <br />
Range: [0x0 to 0x7] </td></tr>
    <tr><td class="paramname">sr</td><td>The service request line to which the channel event is to be connected </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Binds a channel event to a requested Service Request line.<br />
<br />
The channel event is connected to a service request line. For an event to result in an interrupt, this service request line must be enabled in VADC and the NVIC node which this service request line is connected to must have interrupt generation enabled. A call to this API would configure the register bit fields of GxCEVNP0.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga495788bc643c2c9d51444edddcb0d3cb">XMC_VADC_GROUP_ChannelTriggerEvent()</a><br />
 <a class="el" href="group___v_a_d_c.html#ga76846cba41d6ea170992e6b5ea61d957">XMC_VADC_GROUP_ChannelClearEvent()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga02ef37668d4c2692d73b9b028202a923"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_ChannelSetInputReference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>ch_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___v_a_d_c.html#gab0c1eb7f8d8743b6b98ebfe8acd14e28">XMC_VADC_CHANNEL_REF_t</a>&#160;</td>
          <td class="paramname"><em>ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
    <tr><td class="paramname">ch_num</td><td>Channel whose input is to be converted <br />
Range: [0x0 to 0x7] </td></tr>
    <tr><td class="paramname">ref</td><td>Reference voltage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Selects the reference voltage for conversion.<br />
<br />
An internal voltage reference (VARef) or an external voltage reference fed to Ch-0 can serve as a voltage reference for conversions. A call to this API would configure the register bit field GxCHCTR.REFSEL.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6db93a7e9cdeb07b7e9ef1d2f34defd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_ChannelSetResultRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>ch_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>result_reg_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
    <tr><td class="paramname">ch_num</td><td>Channel whose i/p is to be converted <br />
Range: [0x0 to 0x7] </td></tr>
    <tr><td class="paramname">result_reg_num</td><td>Result Register associated with this channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Selects the target result register.<br />
<br />
There are upto 16 result registers which a channel can choose from to store the results of conversion. This selects only the group related result registers. A call to this API would configure the register bit field GxCHCTR.RESREG.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga495788bc643c2c9d51444edddcb0d3cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_ChannelTriggerEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>ch_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
    <tr><td class="paramname">ch_num</td><td>Channel whose channel event is to be asserted <br />
Range: [0x0 to 0x7] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Manually asserts a Channel event.<br />
<br />
It is merely the channel event which is asserted. For this asserted event to lead to an interrupt, it must have been bound to an SR and that SR must have been enabled. It can potentially lead to an interrupt if the SR line is connected to an NVIC node. A call to this API would configure the register bit fields of GxCEFLAG.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga76846cba41d6ea170992e6b5ea61d957">XMC_VADC_GROUP_ChannelClearEvent()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2a6ebe138cbedaba37f2333ccfb068a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_ChannelTriggerEventGenCriteria </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>ch_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___v_a_d_c.html#ga1b6bf4c15562eef67deac95cb36a48d6">XMC_VADC_CHANNEL_EVGEN_t</a>&#160;</td>
          <td class="paramname"><em>criteria</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
    <tr><td class="paramname">ch_num</td><td>Channel whose channel event is being configured <br />
Range: [0x0 to 0x7] </td></tr>
    <tr><td class="paramname">criteria</td><td>The condition under which the channel may assert its channel event </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Defines the conditions under which a channel may assert its channel event.<br />
<br />
The channel event can be generated under the following conditions - Always, Never, Result Out of bounds and Result inside the boundaries. A call to this API would configure the register bit field GxCHCTR.CHEVMODE.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga495788bc643c2c9d51444edddcb0d3cb">XMC_VADC_GROUP_ChannelTriggerEvent()</a><br />
 <a class="el" href="group___v_a_d_c.html#ga76846cba41d6ea170992e6b5ea61d957">XMC_VADC_GROUP_ChannelClearEvent()</a><br />
 <a class="el" href="group___v_a_d_c.html#ga8b2d0baaf1e9113c61ef28c7d45e9feb">XMC_VADC_GROUP_ChannelSetEventInterruptNode()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga22b85c7c9fc777c05d74f1ae2a7cc9ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_CheckSlaveReadiness </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>slave_group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Pointer to the master VADC Group </td></tr>
    <tr><td class="paramname">slave_group</td><td>The slave VADC Group number <br />
Range: [0x0 to 0x3] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configures the ready signal for master group.<br />
<br />
This API would read the <b>slave_group</b> number and determine which EVAL configuration to apply for the given master slave set. Checks the readiness of slaves in synchronized conversions. Conversion of identically numbered channels across groups can be synchronized. For example, when the trigger to convert CH-1 of Group-2 is received, it is possible to simultaneously request conversion of CH-1 of Group-0 and Group-3. Group-2 in this example is therefore the master group while Groups-0 and 3 are the slave groups. Before the master can request its slaves for synchronized conversion, it has the option of checking the readiness of the slaves.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga8e04b2a4deb50a629b3e80bcfeafa14d">XMC_VADC_GROUP_IgnoreSlaveReadiness()</a><br />
 <a class="el" href="group___v_a_d_c.html#gae1406cd26c69119e3a181b38f9d1fd26">XMC_VADC_GROUP_SetSyncMaster()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf4178ad4431b23112dbc89e8e258bc22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_ClearResultEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>res_reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
    <tr><td class="paramname">res_reg</td><td>Result Register for which the result event is being acknowledged <br />
Range: [0x0 to 0xF] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Acknowledges a Result event.<br />
<br />
When a Result event is raised after the conversion of that associated channel has produced a result and it has to be cleared. This API would clear the Channel event of a particular channel if it has occurred. A call to this API would access the register bit fields of GxREFCLR.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga495788bc643c2c9d51444edddcb0d3cb">XMC_VADC_GROUP_ChannelTriggerEvent()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2b5c2e50ccf150e33028b51577c57749"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_DisableChannelSyncRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>ch_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Pointer to the master VADC Group </td></tr>
    <tr><td class="paramname">ch_num</td><td>Channel whose conversion triggers conversion in slave groups </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disable the synchronization request for the particular channel specified as ch_num. To enable the synchronization call the API <a class="el" href="group___v_a_d_c.html#gadb698bad87dcbc3fdf6ce8d6df1ecbb4">XMC_VADC_GROUP_EnableChannelSyncRequest()</a>.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga356e5be65b3abe1ac62e58adfda17529"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_DisableResultEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>res_reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
    <tr><td class="paramname">res_reg</td><td>Result Register for which event generation is to be disabled <br />
Range: [0x0 to 0xF] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disable result event generation.<br />
<br />
This would just disable the event. It would not alter anything w.r.t the SR line if it was configured. A call to this API would configure the register bit field GxRCR.SRGEN.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#gae1fa1ad973c5ab02b6a6a9ece61e1045">XMC_VADC_GROUP_EnableResultEvent()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="gadb698bad87dcbc3fdf6ce8d6df1ecbb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_EnableChannelSyncRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>ch_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the master VADC Group </td></tr>
    <tr><td class="paramname">ch_num</td><td>Channel whose conversion triggers conversion in slave groups </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets up a channel for synchronized conversion.<br />
<br />
 Conversion of identically numbered channels across groups can be synchronized. For example, when the trigger to convert CH-1 of Group-2 is received, it is possible to simultaneously request conversion of CH-1 of Group-0 and Group-3. Group-2 in this example is therefore the master group while Groups-0 and 3 are the slave groups.<br />
 Before the master can request its slaves for synchronized conversion, it has the option of checking the readiness of the slaves.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gae1fa1ad973c5ab02b6a6a9ece61e1045"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_EnableResultEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>res_reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
    <tr><td class="paramname">res_reg</td><td>Result Register for which event generation is to be enabled <br />
Range: [0x0 to 0xF] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables result event generation.<br />
<br />
Once the results of conversion are available, the result event (which is being enabled in this function) if connected to a service request line(Group or Shared service request) can lead to an interrupt. It is therefore not only necessary to enable the event, but also to connect it to a service request line. The service request generation capability must also be enabled and so should the corresponding NVIC node. A call to this API would configure the register bit field GxRCR.SRGEN.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga701140b8237cba836cbd4f1cd3393330">XMC_VADC_GROUP_SetResultInterruptNode()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga71ab6e09e78d8cca7fda70210d5d9d0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_ExternalMuxControlInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___v_a_d_c___g_r_o_u_p___e_m_u_x_c_f_g__t.html">XMC_VADC_GROUP_EMUXCFG_t</a>&#160;</td>
          <td class="paramname"><em>emux_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
    <tr><td class="paramname">emux_cfg</td><td>EMUX configuration structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configures group EMUX parameters associated with the <em>emux_cfg</em> configuration structure.<br />
<br />
 An external emux interface allows additional channels to be connected to a VADC group. The conversion properties of such channels can be different from the standard channels which are directly connected to the VADC group. This API configures conversion properties of channels connected via EMUX interface.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga38c817eb225c4a684c4bbf5495981b2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_VADC_GROUP_GetDetailedResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>res_reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
    <tr><td class="paramname">res_reg</td><td>Result Register from which the result of conversion is to be read out <br />
Range: [0x0 to 0xF] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t returns the complete result register GxRESy.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Returns the result register completely (result of conversion as well as other info).<br />
<br />
The Result register will have information regarding the channel that is requesting the conversion, if the result is valid, if the fast compare bit, Data Reduction Counter, and the request source information. All these information will be returned back. And if the user is polling for the result he can use the result if the valid bit is set. A call to this API would return the complete register GxRES.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#gad190eca993528847f048cb3791bb1484">XMC_VADC_GROUP_GetResult()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga74c556f6be3e4ad892ad04afedf1f566"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___v_a_d_c.html#ga42e972915a3d2ac3b46847a4d5228c64">XMC_VADC_FAST_COMPARE_t</a> XMC_VADC_GROUP_GetFastCompareResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>res_reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
    <tr><td class="paramname">res_reg</td><td>Result Register for which the compare value is being set <br />
Range: [0x0 to 0xF] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>::XMC_VADC_FAST_COMPARE If the input is greater or lower than the compare value returns the appropriate enum. if the valid flag was not set then it would return XMC_VADC_FAST_COMPARE_UNKNOWN.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Determines the input is greater/lower than the compare value.<br />
<br />
This API determines if the input is greater/lower than the preset compare value. A call to this API would access the register bit field GxRES.FCM.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga151403257b63a3307631979702dee524">XMC_VADC_GROUP_SetResultFastCompareValue()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="gad190eca993528847f048cb3791bb1484"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___v_a_d_c.html#gadb07d5ea1ef8b662d9550d22944825d4">XMC_VADC_RESULT_SIZE_t</a> XMC_VADC_GROUP_GetResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>res_reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
    <tr><td class="paramname">res_reg</td><td>Result Register from which the result of conversion is to be read out <br />
Range: [0x0 to 0xF] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XMC_VADC_RESULT_SIZE_t Result register values. <br />
Range:<a href="Result of single conversion. Accumulated results not considered for range">0x0 to 0xFFF</a></dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Returns the result of the conversion.<br />
<br />
This API will only return the result of the conversion and will strip out the other information that is present in the result register. A call to this API would access the register bit field GxRES.RESULT.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga38c817eb225c4a684c4bbf5495981b2b">XMC_VADC_GROUP_GetDetailedResult()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga902952b0e1027e6fecbd5743229f595c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_VADC_GROUP_GetResultFifoHead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>res_reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
    <tr><td class="paramname">res_reg</td><td>Result Register which forms a part of fifo <br />
Range: [0x0 to 0xF] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t returns the Result register number which is the head of the FIFO,<b>res_reg</b> is apart of this FIFO.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Returns the the FIFO head (register to which the results are written by H/W).<br />
<br />
The analog converter writes to the head of the FIFO. It is the head of the FIFO which is bound to the channel. Applications read the result from the tail of the FIFO. This API would just return the head of the FIFO from where the results are being added to the FIFO. A call to this API would access the register bit field GxRCR.FEN.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga902952b0e1027e6fecbd5743229f595c">XMC_VADC_GROUP_GetResultFifoHead()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga233d039edab60b343aa4efef57d79cca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_VADC_GROUP_GetResultFifoTail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>res_reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
    <tr><td class="paramname">res_reg</td><td>Result Register which forms a part of FIFO <br />
Range: [0x0 to 0xF] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t returns the Result register number which is the tail of the FIFO,<b>res_reg</b> is apart of this FIFO.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Returns the the FIFO tail (register from where to read the results).<br />
<br />
The analog converter writes to the head of the FIFO. It is the head of the FIFO which is bound to the channel. Applications read the result from the tail of the FIFO. This API would return the result register from where a user can call the API <a class="el" href="group___v_a_d_c.html#gad190eca993528847f048cb3791bb1484">XMC_VADC_GROUP_GetResult()</a> to read the result stored in the FIFO. A call to this API would access the register bit field GxRCR.FEN.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga902952b0e1027e6fecbd5743229f595c">XMC_VADC_GROUP_GetResultFifoHead()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga8e04b2a4deb50a629b3e80bcfeafa14d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_IgnoreSlaveReadiness </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>slave_group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant Pointer to the master VADC Group </td></tr>
    <tr><td class="paramname">slave_group</td><td>The slave VADC Group number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Clears the ready signal for master group.<br />
<br />
Ignores the readiness of slaves in synchronized conversions.This API would read the <b>slave_group</b> number and determine which EVAL configuration to apply for the given master slave set. Then clears the configuration if present. This API is called when the master should issue the conversion request without waiting for the slave to assert a ready signal. The ready signal is asserted by the slave group(s) when the conversion is completed in these channels.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga22b85c7c9fc777c05d74f1ae2a7cc9ac">XMC_VADC_GROUP_CheckSlaveReadiness()</a><br />
 <a class="el" href="group___v_a_d_c.html#gae1406cd26c69119e3a181b38f9d1fd26">XMC_VADC_GROUP_SetSyncMaster()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="gac147b4cbfd00c81b136425fc8e70215d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___v_a_d_c___g_r_o_u_p___c_o_n_f_i_g__t.html">XMC_VADC_GROUP_CONFIG_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group. </td></tr>
    <tr><td class="paramname">config</td><td>Pointer to the initialization data structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Initializes the VADC group module with the associated configuration structure pointed by <em>config</em>.<br />
<br />
 It initializes the group specified as part of the . It initializes group conversion class, arbiter configuration , boundary configuration by setting GxICLASS,GxARBCFG,GxBOUND, registers. It also configures the EMUX control register if applicable. Refer related API's to change the configurations later in the program.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#gaa7a2bbb2f627f186c23ae8b93ebf34fc">XMC_VADC_GROUP_InputClassInit()</a><br />
 <a class="el" href="group___v_a_d_c.html#gae435b6b66cac1abc05d17fd17d5caca6">XMC_VADC_GROUP_SetPowerMode()</a><br />
 <a class="el" href="group___v_a_d_c.html#ga5f2cda270ffbbc2dcf6879d66ddb94b8">XMC_VADC_GROUP_SetBoundaries()</a><br />
 <a class="el" href="group___v_a_d_c.html#ga71ab6e09e78d8cca7fda70210d5d9d0b">XMC_VADC_GROUP_ExternalMuxControlInit()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="gaa7a2bbb2f627f186c23ae8b93ebf34fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_InputClassInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___v_a_d_c___g_r_o_u_p___c_l_a_s_s__t.html">XMC_VADC_GROUP_CLASS_t</a>&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___v_a_d_c.html#gadf393a8c811d7ee6601688797e616646">XMC_VADC_GROUP_CONV_t</a>&#160;</td>
          <td class="paramname"><em>conv_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>set_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group. </td></tr>
    <tr><td class="paramname">config</td><td>group related conversion class parameter structure </td></tr>
    <tr><td class="paramname">conv_type</td><td>Use direct channels or EMUX channels. Refer <a class="el" href="group___v_a_d_c.html#gadf393a8c811d7ee6601688797e616646">XMC_VADC_GROUP_CONV_t</a> enum </td></tr>
    <tr><td class="paramname">set_num</td><td>Conversion class set<br />
 Range[0x0, 0x1]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets up the conversion settings for vadc group resource associated with <em>config</em> structure. It configures the conversion class properties like sampling time and resolution for selected <em>conv_type</em> channels. It initializes the G_ICLASS register specified by <em>set_num</em> with the required settings.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#gac147b4cbfd00c81b136425fc8e70215d">XMC_VADC_GROUP_Init()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8e70ce6dfa38cee7c48004720aac8aeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___v_a_d_c.html#ga4effb949346537c7a515c4f2ff542df5">XMC_VADC_GROUP_STATE_t</a> XMC_VADC_GROUP_IsConverterBusy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retuns IDLE if converter is free else returns busy. Refer <a class="el" href="group___v_a_d_c.html#ga4effb949346537c7a515c4f2ff542df5">XMC_VADC_GROUP_STATE_t</a> enum</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Checks the live status of the analog to digital converter. The converter can either idle doing nothing or busy sampling + converting.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga4fb1c3e933690c2e106823950c6fe06d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_VADC_GROUP_IsResultRegisterFifoHead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>res_reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
    <tr><td class="paramname">res_reg</td><td>Result Register in question <br />
Range: [0x0 to 0xF] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool returns true if the <b>res_reg</b> is the FIFO head.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Determines if the requested register is the head of a FIFO.<br />
<br />
The analog converter writes to the head of the FIFO. It is the head of the FIFO which is bound to the channel. Applications read the result from the tail of the FIFO. A call to this API would access the register bit field GxRCR.FEN.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga902952b0e1027e6fecbd5743229f595c">XMC_VADC_GROUP_GetResultFifoHead()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="gae1b61fdad9ee903b23e944e787843e46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_VADC_GROUP_IsResultRegisterInFifo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>res_reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
    <tr><td class="paramname">res_reg</td><td>Result Register number<br />
 <br />
Range: [0x0 to 0xF] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool returns true if the <b>res_reg</b> is the FIFO member, else false.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Determines whether the specified register is a FIFO member or not.<br />
<br />
The analog converter writes to the head of the FIFO. It is the head of the FIFO which is bound to the channel. Applications read the result from the tail of the FIFO. A call to this API would access the register bit field GxRCR.FEN. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9bfd983c7c4dc403ed40eabe3920c9db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_QueueAbortSequence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Aborts an ongoing conversion by flushing the queue.<br />
<br />
This API will flush the queue buffer. Ongoing conversion of the Queue request source will not be effected by this API. This would clear all the contents that are present in the queue buffer. A call to this API would configure the registers GxQCTRL0, GxQMR0, GxARBPR in order to abort the queue sequence.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga19b2912cd17132e6a10f818023fa0745">XMC_VADC_GROUP_QueueRemoveChannel()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga165449401f44c76bafa98f119569ffdc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_QueueClearReqSrcEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Acknowledges the conversion complete request source event.<br />
<br />
This API will clear the request source event that occurred. This will clear a interrupt if it was raised. A call to this API would configure the register bit field GxSEFCLR.SEV0.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga51bc955e0976c66affb8b660261cdf82">XMC_VADC_GROUP_QueueTriggerReqSrcEvent()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="gaa8d19efeb6b04913e91406eaccff72ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_QueueDisableArbitrationSlot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables arbitration slot of the queue request source.<br />
<br />
If the QUEUE request source must have its conversion request considered by the arbiter, it must participate in the arbitration rounds. Even if a load event occurs the queue channel can only be converted when the arbiter comes to the queue slot.A call to this API will lead to all conversions request by queue to be blocked. A call to this API would configure the register bit field GxARBPR.ASEN0.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#gaf3c728f97550bccd474f79befc017365">XMC_VADC_GROUP_QueueEnableArbitrationSlot()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="gacdb123380f2ec61225fd8c7ed70c4c8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_QueueDisableExternalTrigger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables the trigger for queue request source.<br />
 By using this API the trigger will be deactivated for the queue request source. This will just deactivate the H/W trigger for the queue request source. If any configuration was done to select the trigger input in GxQCTRL0 will be not be effected. A call to this API would configure the register bit field GxQMR0.ENTR</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga67769f0c1fba40f3fdd1026936ed50b9">XMC_VADC_GROUP_QueueEnableExternalTrigger()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="gaf3c728f97550bccd474f79befc017365"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_QueueEnableArbitrationSlot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables arbitration slot of the queue request source.<br />
<br />
If the QUEUE request source must have its conversion request considered by the arbiter, it must participate in the arbitration rounds. Even if a load event occurs the queue channel can only be converted when the arbiter comes to the queue slot. Thus this must be enabled if any conversion need to take place. A call to this API would configure the register bit field GxARBPR.ASEN0.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#gaa8d19efeb6b04913e91406eaccff72ed">XMC_VADC_GROUP_QueueDisableArbitrationSlot()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga67769f0c1fba40f3fdd1026936ed50b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_QueueEnableExternalTrigger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables the trigger for queue request source.<br />
<br />
By using this API the trigger will be activated for the queue request source. The trigger signal and trigger edge will be selected from the QCTRL register. The Selection of a input will be done by <a class="el" href="group___v_a_d_c.html#ga921d0b59c5a88d92bdc7017d7be2765f">XMC_VADC_GROUP_QueueSelectTrigger()</a>. A call to this API would configure the register bit field GxQMR0.ENTR</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga921d0b59c5a88d92bdc7017d7be2765f">XMC_VADC_GROUP_QueueSelectTrigger()</a><br />
 <a class="el" href="group___v_a_d_c.html#gacdb123380f2ec61225fd8c7ed70c4c8b">XMC_VADC_GROUP_QueueDisableExternalTrigger()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga8ed5e69a5c33fd5b3acea763bdf957b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t XMC_VADC_GROUP_QueueGetInterruptedChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t Returns -1 if there is no channel that have been interrupted. Else would return the channel that is interrupted. <br />
Range: [0x0 to 0x8]</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Identifies the channel whose conversion was suspended.<br />
<br />
When using cancel inject repeat mode the canceled conversion will be placed in the backup register. This API will return the valid queue channel number from the backup register. This happens when ever there is a high priority conversion interrupts the conversion of queue request source. This forces the channel to goto the backup register. A call to this API would access the register GxQBUR0 to determine the interrupted channel.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gab733f165ccdd37704dc50f5ec5801134"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_VADC_GROUP_QueueGetLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t returns the total number of channels. <br />
Range: [0x0 to 0x8]</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Returns the number of channels present in the queue.<br />
<br />
This API will return the queue buffer size. This buffer will be consisting of valid queue entries which will be converted when a trigger event occurs. All the entries that are loaded onto the GxQINR0 will be added to the queue buffer. Hence if an application needs to get the number of valid queue entries this API would provide the interface. A call to this API would access the registers GxQBUR0, GxQSR0 in order to determine the queue length.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga26dff19d499748825e53019d060a675a">XMC_VADC_GROUP_QueueInsertChannel()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga305e60b302a668a2d2c35b96208cdea7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t XMC_VADC_GROUP_QueueGetNextChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t Returns -1 if there are no channels for conversion Else would return the next valid channel for conversion. <br />
Range: [0x0 to 0x8]</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Returns the next entry in the queue request source for conversion.<br />
<br />
Identifies the channel in the queue lined up for conversion next. API will return a valid queue entry from the queue buffer. First checks for the valid channel entry in the backup register and returns if present. If the valid entry has not been found in the backup register then the queue buffer is searched for a valid entry. A call to this API would access the registers GxQ0R0, GxQBUR0 to determine the next channel.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga19b2912cd17132e6a10f818023fa0745">XMC_VADC_GROUP_QueueRemoveChannel()</a><br />
 <a class="el" href="group___v_a_d_c.html#ga26dff19d499748825e53019d060a675a">XMC_VADC_GROUP_QueueInsertChannel()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="gaaf5dae90963d3decfcc07d961b2cfdaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_VADC_GROUP_QueueGetReqSrcEventStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool returns true if the service request event is raised. returns false if the service request event was not raised.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Determines if the request source event is asserted.<br />
 This API will get the status of the queue request source event. Will return a true if the event has occurred for queue. A call to this API would acces the register bit field GxSEFLAG.SEV0.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga881c16d2f992825869d02005d91ddc09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_QueueInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___v_a_d_c___q_u_e_u_e___c_o_n_f_i_g__t.html">XMC_VADC_QUEUE_CONFIG_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Pointer to the VADC group </td></tr>
    <tr><td class="paramname">config</td><td>Pointer to initialization data structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Initializes VADC QUEUE functional block.<br />
<br />
The QUEUE request source functional block converts channels stored in a queue. The first channel entered into the queue is converted first. A channel once converted, can be placed back into the queue if desired(refill). A call to this API will first disable the arbitration slot for queue (<a class="el" href="group___v_a_d_c.html#gaf3c728f97550bccd474f79befc017365">XMC_VADC_GROUP_QueueEnableArbitrationSlot()</a>) and then it would configure all the related registers with the required configuration values. The arbitration slot is re-enabled at the end of init by invoking <a class="el" href="group___v_a_d_c.html#gaa8d19efeb6b04913e91406eaccff72ed">XMC_VADC_GROUP_QueueDisableArbitrationSlot()</a>. A call to this API would configure the registers GxARBPR, GxQCTRL0, GxQMR0 to configure the queue request source.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#gaf3c728f97550bccd474f79befc017365">XMC_VADC_GROUP_QueueEnableArbitrationSlot()</a><br />
 <a class="el" href="group___v_a_d_c.html#gaa8d19efeb6b04913e91406eaccff72ed">XMC_VADC_GROUP_QueueDisableArbitrationSlot()</a><br />
 <a class="el" href="group___v_a_d_c.html#ga921d0b59c5a88d92bdc7017d7be2765f">XMC_VADC_GROUP_QueueSelectTrigger()</a><br />
 <a class="el" href="group___v_a_d_c.html#ga1962d86a697f244d19a4127580efd099">XMC_VADC_GROUP_QueueSelectGating()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga26dff19d499748825e53019d060a675a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_QueueInsertChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___v_a_d_c___q_u_e_u_e___e_n_t_r_y__t.html">XMC_VADC_QUEUE_ENTRY_t</a>&#160;</td>
          <td class="paramname"><em>entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
    <tr><td class="paramname">entry</td><td>Details of the node being added </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Inserts a queue entry to the tail of the queue buffer.<br />
<br />
This API will insert a new channel into the queue buffer. The Queue will start conversion of the channels from the head of the buffer. This Insert will place the entry after the last valid entry. If no valid entries are present then this API will place the Queue entry at the head of the buffer. Then the successive call to the insert will place the new entry after the last entry. A call to this API would configure the register GxQINR0 for a single queue entry.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga19b2912cd17132e6a10f818023fa0745">XMC_VADC_GROUP_QueueRemoveChannel()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga19b2912cd17132e6a10f818023fa0745"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_QueueRemoveChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Clears the next valid channel in the queue buffer.<br />
<br />
A queue entry lined up for conversion can be removed and replaced by its successor. The call to this API will first check if a valid queue entry is present in the queue backup register if present would clear its valid flag. If no valid queue entries are present in the backup then the first channel present in the queue buffer would be cleared. A call to this API would configure the registers GxQCTRL0, GxQMR0, GxARBPR in order to clear a channel from the queue.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga26dff19d499748825e53019d060a675a">XMC_VADC_GROUP_QueueInsertChannel()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga1962d86a697f244d19a4127580efd099"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_QueueSelectGating </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___v_a_d_c.html#gaa16f1136a4a4efddcd67ebd5fc69bc9f">XMC_VADC_GATE_INPUT_SELECT_t</a>&#160;</td>
          <td class="paramname"><em>input_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
    <tr><td class="paramname">input_num</td><td>Choice of the input earmarked as the gating line </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Select Gating signal for queue request source.<br />
<br />
Passage of the trigger input to the request source can be controlled via a gating signal. Any one of the 16 input lines can be chosen as a gating signal. Trigger signal can be given to the queue request source only when the gating signal's active level is detected. Additionally the GxQMR0.ENGT has to be configured for the gating signal's active level. A call to this API would configure the register bit field GxQCTRL0.GTSEL.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga921d0b59c5a88d92bdc7017d7be2765f">XMC_VADC_GROUP_QueueSelectTrigger()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga921d0b59c5a88d92bdc7017d7be2765f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_QueueSelectTrigger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___v_a_d_c.html#gab71bdae1d928ee308430626a761eab97">XMC_VADC_TRIGGER_INPUT_SELECT_t</a>&#160;</td>
          <td class="paramname"><em>input_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
    <tr><td class="paramname">input_num</td><td>Choice of the input earmarked as a trigger line </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Select Trigger signal for queue request source.<br />
<br />
A queue request source will raise conversion request only if there were either a request from application or occurrence of a hardware trigger. This API selects one of the 16 input lines as a trigger line. This is needed when a hardware trigger is needed for the conversion of the queue request source. Refer to the reference manual to determine the signal that needs to be connected. A call to this API would configure the register bit field GxQCTRL0.XTSEL.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga1962d86a697f244d19a4127580efd099">XMC_VADC_GROUP_QueueSelectGating()</a><br />
 <a class="el" href="group___v_a_d_c.html#ga67769f0c1fba40f3fdd1026936ed50b9">XMC_VADC_GROUP_QueueEnableExternalTrigger()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="gaaf9874010e5073415ab846b4ef46955e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_QueueSetGatingMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga4db02e3b835b8cad941ab60ae288f8c8">XMC_VADC_GATEMODE_t</a>&#160;</td>
          <td class="paramname"><em>mode_sel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
    <tr><td class="paramname">mode_sel</td><td>Select how the gating is applied to the queue request source </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p><b>Details of function</b><br />
 Selects the gating mode of queue request source.<br />
<br />
Passage of the trigger input to the request source can be controlled via a gating signal. This API determines how the gating signal behaves, either active low or active high. If gating signal needs to ignored XMC_VADC_GATEMODE_IGNORE should be used as the <em>mode_sel</em>. A call to this API would configure the register bit field GxQMR0.ENGT.</p>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga1962d86a697f244d19a4127580efd099">XMC_VADC_GROUP_QueueSelectGating()</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="gabf8bc9e2f7207523e5fb6d6b360ea663"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_QueueSetReqSrcEventInterruptNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___v_a_d_c.html#gab518b0c522cae78b7434dfa327a540b1">XMC_VADC_SR_t</a>&#160;</td>
          <td class="paramname"><em>sr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
    <tr><td class="paramname">sr</td><td>The service request line (Common SR lines, Group specific SR lines) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Connects the event to the SR line of VADC.<br />
<br />
This API will connect a Service Request line(SR) to a queue request source event. Hence to get a interrupt on this Service request line one has to enable the required NVIC node. A call to this API would configure the register bit field GxSEVNP.SEVNP0.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gabf7bf44150a8541ab60d12889f367053"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_QueueTriggerConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Generates conversion request (Software initiated conversion).<br />
 A conversion request can be raised either upon detection of a hardware trigger, or by software. This API forces the queue unit to generate a conversion request to the analog converter. It is assumed that the queue has already been filled up with entries. A call to this API would configure the register bit field GxQMR0.TREV.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>The conversion of queue entry will start immediately after the entry has been loaded into GxQINR0. This happens only if the queue entry has been loaded into the register without the need for the H/W trigger.<br />
If a H/W Trigger is selected while loading the entry, the conversion will occur in one of the 2 ways.  The H/W generates a trigger needed for the queue request source.  The Conversion is triggered manually by calling this API.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga26dff19d499748825e53019d060a675a">XMC_VADC_GROUP_QueueInsertChannel()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga51bc955e0976c66affb8b660261cdf82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_QueueTriggerReqSrcEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Manually asserts the conversion complete request source event.<br />
<br />
This API will set the request source event for queue. This will trigger a interrupt if the service node pointer for the scan has been configured. A call to this API would configure the register bit field GxSEFLAG.SEV0.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga165449401f44c76bafa98f119569ffdc">XMC_VADC_GROUP_QueueClearReqSrcEvent()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga1a5f41454d3e42d5505db9e3acf5177f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_ResultInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>res_reg_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___v_a_d_c___r_e_s_u_l_t___c_o_n_f_i_g__t.html">XMC_VADC_RESULT_CONFIG_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
    <tr><td class="paramname">res_reg_num</td><td>Result register which is intended to be initialized <br />
Range: [0x0 to 0xF] </td></tr>
    <tr><td class="paramname">config</td><td>Pointer to initialization data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Initializes a Group Result Register.<br />
 Various options needed for the working of the result result will be configured with this API. This would determine the result handling of the group registers. This API must be called after the channel Init (<a class="el" href="group___v_a_d_c.html#ga88e0f4deb5ddd8a85c786a6291327fa6">XMC_VADC_GROUP_ChannelInit()</a>)to initialize the result register that is selected for the channel. This API would also determine if the result register that is being configured has to a part of a FIFO buffer. In this API one can also configure the various result handling options line FIR/IIR filters and it order. Also configures the Data reduction to accumulate 2/3/4 results need to be done. This API will also configure the result event generation. A call to this API would configure the register GxRCR with the <b>config</b> .</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#gaf2c5118b682ff5c4820400ea362b3cc7">XMC_VADC_GROUP_AddResultToFifo()</a><br />
 <a class="el" href="group___v_a_d_c.html#gae1fa1ad973c5ab02b6a6a9ece61e1045">XMC_VADC_GROUP_EnableResultEvent()</a><br />
 <a class="el" href="group___v_a_d_c.html#ga356e5be65b3abe1ac62e58adfda17529">XMC_VADC_GROUP_DisableResultEvent()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="gab72f743031df5ebe062fe8a28275888b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_ScanAddChannelToSequence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>ch_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
    <tr><td class="paramname">ch_num</td><td>The channel meant to be added to scan sequence <br />
Range: [0x0 to 0x7] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Adds a channel to the scan sequence.<br />
<br />
Call this API to insert a new single channel into the scan request source. This will be added to the scan sequence. The added channel will be part of the conversion sequence when the next load event occurs. A call to this API would configure the register bit fields of GxASSEL.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga51f598fc7306207185177af62858ac65">XMC_VADC_GROUP_ScanAddMultipleChannels()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga51f598fc7306207185177af62858ac65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_ScanAddMultipleChannels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>ch_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
    <tr><td class="paramname">ch_mask</td><td>Mask word indicating channels which form part of scan conversion sequence Bit location 0/1/2/3/4/5/6/7 represents channels-0/1/2/3/4/5/6/7 respectively. To Add the channel to the scan sequence enable the respective bit. Passing a 0x0 will clear all the selected channels <br />
Range: [0x0 to 0xFF] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Adds multiple channels to the scan sequence.<br />
<br />
Call this API to insert a multiple channels into the scan request source. This will be added to a scan sequence. The added channels will be a part of the conversion sequence when the next load event occurs. A call to this API would configure the register bit fields of GxASSEL.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#gab72f743031df5ebe062fe8a28275888b">XMC_VADC_GROUP_ScanAddChannelToSequence()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga02dca0332550c23db82bbdd3750d5670"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_ScanClearReqSrcEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Acknowledges the scan conversion complete request source event.<br />
<br />
This API will clear the request source event that occurred. This will clear a interrupt if it was raised. A call to this API would configure the register bit field GxSEFLAG.SEV1.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#gacf7d930e6e633e535725c13eaf444afc">XMC_VADC_GROUP_ScanTriggerReqSrcEvent()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga4d1f77cf454d509dfaff575717a8693f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_ScanDisableArbitrationSlot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables arbitration slot of the scan request source.<br />
<br />
If the scan request source must have its conversion request considered by the arbiter, it must participate in the arbitration rounds. Even if a load event occurs the scan channel can only be converted when the arbiter comes to the scan slot.A call to this API will lead to all conversions request by scan to be blocked. A call to this API would configure the register bit field GxARBPR.ASEN1.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga916530591113892be436af6238ead6ea">XMC_VADC_GROUP_ScanEnableArbitrationSlot()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga1aa7cb076e7e2b56f330d0bb14645494"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_ScanDisableContinuousMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables continuous conversion mode.<br />
<br />
Typically for a scan request source to generate conversion request, either a hardware trigger or a software request is a pre-requisite. Using autoscan feature it is possible to start the conversion once and allow the sequence to repeat without any further triggers. Once all channels belonging to a scan request source have been converted, a request source completion event is generated. Generation of this event can restart the scan sequence. By invoking this feature the Autoscan mode of operations is disabled. A call to this API would configure the register bit field GxASMR.SCAN.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga4fa59213861735578dff28c02d961120">XMC_VADC_GROUP_ScanEnableContinuousMode()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga7a558bd413ed6540b84d350728d57eec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_ScanDisableExternalTrigger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables the trigger for scan request source.<br />
 By using this API the trigger will be deactivated for the scan request source. This will just deactivate the H/W trigger for the scan request source. If any configuration were done to select the trigger input in GxASCTRL, it will be not be effected by this API. A call to this API would configure the register bit field GxASMR.ENTR.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#gaa08eef43607d1b9a39aaab3fae84e7f3">XMC_VADC_GROUP_ScanEnableExternalTrigger()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga916530591113892be436af6238ead6ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_ScanEnableArbitrationSlot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables arbitration slot of the scan request source.<br />
<br />
If the scan request source must have its conversion request considered by the arbiter, it must participate in the arbitration rounds. Even if a load event occurs the scan channel can only be converted when the arbiter comes to the scan slot. Thus this must be enabled if any conversion need to take place. A call to this API would configure the register bit field GxARBPR.ASEN1.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga4d1f77cf454d509dfaff575717a8693f">XMC_VADC_GROUP_ScanDisableArbitrationSlot()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga4fa59213861735578dff28c02d961120"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_ScanEnableContinuousMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables continuous conversion mode.<br />
<br />
Typically for a scan request source to generate conversion request, either a hardware trigger or a software request is a pre-requisite. Using autoscan feature it is possible to start the conversion once and allow the sequence to repeat without any further triggers. Once all channels belonging to a scan request source have been converted, a request source completion event is generated. Generation of this event can restart the scan sequence. Every request source event will cause a load event to occur. A call to this API would configure the register bit field GxASMR.SCAN.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga1aa7cb076e7e2b56f330d0bb14645494">XMC_VADC_GROUP_ScanDisableContinuousMode()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="gaa08eef43607d1b9a39aaab3fae84e7f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_ScanEnableExternalTrigger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables the trigger for scan request source.<br />
<br />
By using this API, the trigger signal will be activated for the scan request source. The trigger signal and trigger edge will be selected from the ASCTRL register. The Selection of a input will be done by <a class="el" href="group___v_a_d_c.html#ga4d29e840f790e5c763c1f00bbcf1e131">XMC_VADC_GROUP_ScanSelectTrigger()</a>. A call to this API would configure the register bit field GxASMR.ENTR.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga4d29e840f790e5c763c1f00bbcf1e131">XMC_VADC_GROUP_ScanSelectTrigger()</a><br />
 <a class="el" href="group___v_a_d_c.html#ga7a558bd413ed6540b84d350728d57eec">XMC_VADC_GROUP_ScanDisableExternalTrigger()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga723bda6902bb2b8b0641a0e60b1da61a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_VADC_GROUP_ScanGetNumChannelsPending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 uint32_t Returns the total channels pending for conversion. <br />
Range: [0x0 to 0x8]</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Returns the total number of pending channels.<br />
<br />
This API will read the pending channels register and will return the number of channels that are awaiting conversion. When a load event occurs the scan sequence is pushed to a pending conversion register. From the pending register the channels are taken up by the converter. When the API is called it would return the total number of channels pending (GxASPND).</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga4ea5f62893afbb468820cb612f09e3d1">XMC_VADC_GROUP_ScanIsChannelPending()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="gad08132ae30e2e73e5f71d2fb5b3b1c7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_VADC_GROUP_ScanGetReqSrcEventStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool returns true if the service request event is raised. returns false if the service request event was not raised.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Determines if the request source event is asserted.<br />
 This API will get the status of the scan request source event. Will return a true if the event has occurred for scan. A call to this API would access the register bit field GxSEFLAG.SEV1.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0baf952034feb3eaa81736e9761cf48f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_ScanInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___v_a_d_c___s_c_a_n___c_o_n_f_i_g__t.html">XMC_VADC_SCAN_CONFIG_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Pointer to the VADC group </td></tr>
    <tr><td class="paramname">config</td><td>Pointer to Scan configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Initializes the VADC SCAN functional block.<br />
<br />
The GROUP SCAN request source functional block converts channels sequentially starting with the highest numbered channel to the lowest. Channels must register themselves as being part of the the scan sequence. A call to this API will first disable the arbitration slot for queue (<a class="el" href="group___v_a_d_c.html#ga916530591113892be436af6238ead6ea">XMC_VADC_GROUP_ScanEnableArbitrationSlot()</a>) and then it would configure all the related registers with the required configuration values. The arbitration slot is re-enabled at the end of init by invoking <a class="el" href="group___v_a_d_c.html#ga4d1f77cf454d509dfaff575717a8693f">XMC_VADC_GROUP_ScanDisableArbitrationSlot()</a>. A call to this API would configure the registers GxARBPR, GxASCTRL, GxASMR needed scan request source.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga916530591113892be436af6238ead6ea">XMC_VADC_GROUP_ScanEnableArbitrationSlot()</a><br />
 <a class="el" href="group___v_a_d_c.html#ga4d1f77cf454d509dfaff575717a8693f">XMC_VADC_GROUP_ScanDisableArbitrationSlot()</a><br />
 <a class="el" href="group___v_a_d_c.html#ga4d29e840f790e5c763c1f00bbcf1e131">XMC_VADC_GROUP_ScanSelectTrigger()</a><br />
 <a class="el" href="group___v_a_d_c.html#gab637f1591586c7dfb8593fb394104887">XMC_VADC_GROUP_ScanSelectGating()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga4ea5f62893afbb468820cb612f09e3d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_VADC_GROUP_ScanIsChannelPending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>ch_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
    <tr><td class="paramname">ch_num</td><td>The channel being audited for completion of conversion <br />
Range: [0x0 to 0x7] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool returns true if the channel is pending conversion else returns false</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Determine if the channel is pending for conversion.<br />
<br />
This API will check if the Channel in question is awaiting conversion in the current arbitration round. When a load event occurs the scan sequence is pushed to a pending conversion register. From the pending register the channels are taken up by the converter. This API would return true if the channel is found in the pending register (GxASPND).</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga723bda6902bb2b8b0641a0e60b1da61a">XMC_VADC_GROUP_ScanGetNumChannelsPending()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="gab637f1591586c7dfb8593fb394104887"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_ScanSelectGating </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#gaa16f1136a4a4efddcd67ebd5fc69bc9f">XMC_VADC_GATE_INPUT_SELECT_t</a>&#160;</td>
          <td class="paramname"><em>gating_input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
    <tr><td class="paramname">gating_input</td><td>Module input signal meant to be selected as gating input </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Select Gating signal for scan request source.<br />
<br />
Passage of the trigger input to the request source can be controlled via a gating signal. Any one of the 16 input lines can be chosen as a gating signal. Trigger signal can be given to the scan request source only when the gating signal's active level is detected. Additionally the GxASMR.ENGT has to be configured for the gating signal's active level. A call to this API would configure the register bit field GxASCTRL.GTSEL.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga4d29e840f790e5c763c1f00bbcf1e131">XMC_VADC_GROUP_ScanSelectTrigger()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga4d29e840f790e5c763c1f00bbcf1e131"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_ScanSelectTrigger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#gab71bdae1d928ee308430626a761eab97">XMC_VADC_TRIGGER_INPUT_SELECT_t</a>&#160;</td>
          <td class="paramname"><em>trigger_input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
    <tr><td class="paramname">trigger_input</td><td>Choice of the input earmarked as a trigger line </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Select Trigger signal for scan request source.<br />
<br />
A scan request source will raise conversion request only if there were either a request from application or occurrence of a hardware trigger. This API selects one of the 16 input lines as a trigger line. This is needed when a hardware trigger is needed for the conversion of the scan request source. Refer to the reference manual to determine the signal that needs to be connected. A call to this API would configure the register bit field GxASCTRL.XTSEL.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#gab637f1591586c7dfb8593fb394104887">XMC_VADC_GROUP_ScanSelectGating()</a><br />
 <a class="el" href="group___v_a_d_c.html#gaa08eef43607d1b9a39aaab3fae84e7f3">XMC_VADC_GROUP_ScanEnableExternalTrigger()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga4963004f5c5f5bfd255b51d79d62e143"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_ScanSequenceAbort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Aborts an ongoing scan sequence conversion.<br />
<br />
An ongoing sequence can be aborted at any time. The scan unit picks the pending channels one by one from a pending register and requests for their conversion. This API essentially clears the channel pending register thus creating an illusion that there are no more channels left in the sequence. A call to this API would configure the registers GxASMR, GxASCTRL, GxARBPR to achieve the sequence abort.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5db8e4e617a0df8234d948ed26d7d9a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_ScanSetGatingMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga4db02e3b835b8cad941ab60ae288f8c8">XMC_VADC_GATEMODE_t</a>&#160;</td>
          <td class="paramname"><em>mode_sel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
    <tr><td class="paramname">mode_sel</td><td>Select how the gating is applied to the scan request source </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Selects the gating mode of scan request source.<br />
<br />
Passage of the trigger input to the request source can be controlled via a gating signal. This API determines how the gating signal behaves, either active low or active high. If gating signal needs to ignored XMC_VADC_GATEMODE_IGNORE should be used as the <em>mode_sel</em>.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#gab637f1591586c7dfb8593fb394104887">XMC_VADC_GROUP_ScanSelectGating()</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="ga3c309bf576995893d65adc4cd362a321"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_ScanSetReqSrcEventInterruptNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___v_a_d_c.html#gab518b0c522cae78b7434dfa327a540b1">XMC_VADC_SR_t</a>&#160;</td>
          <td class="paramname"><em>sr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptrConstant</td><td>pointer to the VADC group </td></tr>
    <tr><td class="paramname">sr</td><td>Service Request Id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Connects the scan request source event to the SR line of VADC.<br />
<br />
This API will connect a Service Request line(SR) to a scan request source event. Hence to get a interrupt on this Service request line one has to enable the required NVIC node. A call to this API would configure the register bit field GxSEVNP.SEV1NP .</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga013308f793d25106e935c6f1bdbd95a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_ScanTriggerConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Generates conversion request (Software initiated conversion).<br />
<br />
A conversion request can be raised either upon detection of a hardware trigger, or by software. This API forces the scan unit to generate a conversion request to the analog converter. It is assumed that the scan has already been filled up with entries. A call to this API would configure the register bit field GxASMR.LDEV.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gacf7d930e6e633e535725c13eaf444afc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_ScanTriggerReqSrcEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Manually asserts the conversion complete request source event.<br />
<br />
This API will set the request source event for scan. This will trigger a interrupt if the service node pointer for the scan has been configured. A call to this API would configure the register bit field GxSEFLAG.SEV1.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5f2cda270ffbbc2dcf6879d66ddb94b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_SetBoundaries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>boundary0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>boundary1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group whose global boundary registers are to be programmed </td></tr>
    <tr><td class="paramname">boundary0</td><td>Boundary-0 Value<br />
 Range: [0x0 - 0x0FFF] </td></tr>
    <tr><td class="paramname">boundary1</td><td>Boundary-1 Value<br />
 Range: [0x0 - 0x0FFF]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Programs the boundaries with <em>boundary0</em> and boundary1 for result comparison.<br />
<br />
 These two boundaries can serve as absolute boundaries. They defines a range against which the result of a conversion can be compared. In the fast compare mode, the two boundaries provide hysteresis capability to a compare value. In any case, these boundary values entered here form a boundary pallete. There are dedicated upper and lower boundary registers G_BOUND0 and G_BOUND1 who will derive their values from this palette.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gaa9a9864939239099c1de61555e12d223"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_SetChannelAlias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>src_ch_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>alias_ch_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
    <tr><td class="paramname">src_ch_num</td><td>Channel which will be converted by <b>alias_ch_num</b>, when called by the request source. <br />
Range:[0x0 to 0x7] </td></tr>
    <tr><td class="paramname">alias_ch_num</td><td>This is the alias channel (Ch-0 or Ch-1) <br />
Range:[0x0, 0x1] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets the Alias channel(<b>alias_ch_num</b>) to convert from the source channel(<b>src_ch_num</b>).<br />
<br />
When a alias configuration takes place the request source(queue/scan/background) will not call channel <b>src_ch_num</b>. The Request sources will call the channel <b>alias_ch_num</b> , this would invoke the conversion of the pin associated with <b>src_ch_num</b>. The configuration of the alias channel (<b>alias_ch_num</b>) will be used for the conversion.<br />
When an alias channel (Ch-0 or Ch-1) receives a trigger, it converts the aliased channel (<b>src_ch_num</b>). The properties of Ch-0 or Ch-1 (as indicated in <b>alias_ch_num</b> ) apply when <b>src_ch_num</b> is converted. A call to this API would configure the register GxALIAS.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>Alias Channel (<b>alias_ch_num</b>) and the source channel (<b>src_ch_num</b>) cannot be the same. If they are, that alias feature is not used for the conversion. In order to Reset the alias feature that was previously selected this method can be used.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gae435b6b66cac1abc05d17fd17d5caca6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_SetPowerMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___v_a_d_c.html#ga7226349aef79a52f614eb5e75e3f55d9">XMC_VADC_GROUP_POWERMODE_t</a>&#160;</td>
          <td class="paramname"><em>power_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC Group. </td></tr>
    <tr><td class="paramname">power_mode</td><td>Desired power mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configures the power mode of a VADC group.<br />
<br />
 For a VADC group to actually convert an analog signal, its analog converter must be turned on.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga151403257b63a3307631979702dee524"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_SetResultFastCompareValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>res_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___v_a_d_c.html#gadb07d5ea1ef8b662d9550d22944825d4">XMC_VADC_RESULT_SIZE_t</a>&#160;</td>
          <td class="paramname"><em>compare_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
    <tr><td class="paramname">res_reg</td><td>Result Register for which the compare value is being set <br />
Range: [0x0 to 0xF] </td></tr>
    <tr><td class="paramname">compare_val</td><td>The compare value itself <br />
Range: [0x0 to 0xFFF] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configures the compare value (relevant to the Fast Compare Mode).<br />
<br />
A channel input can be converted and its value stored in its result register. Alternatively, the channel input can be converted and compared against a compare value. This is the fast compare mode typically utilized by applications that are not interested in absolute converted value of an analog input, but rather a binary decision on how the input fares against a preset compare value. The channel should have had already chosen the correct ICLASS with the fast compare mode enabled. <b>compare_val</b> would be the compare value on which FCM bit in the result register will be set. The FCM bit will be set if the analog voltage is greater than the compare value. A call to this API would configure the register bit field GxRES.RESULT.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#ga74c556f6be3e4ad892ad04afedf1f566">XMC_VADC_GROUP_GetFastCompareResult()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga701140b8237cba836cbd4f1cd3393330"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_SetResultInterruptNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>res_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___v_a_d_c.html#gab518b0c522cae78b7434dfa327a540b1">XMC_VADC_SR_t</a>&#160;</td>
          <td class="paramname"><em>sr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
    <tr><td class="paramname">res_reg</td><td>Result Register for which the result event is being asserted <br />
Range: [0x0 to 0xF] </td></tr>
    <tr><td class="paramname">sr</td><td>The SR line to which the result event must be connected </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Binds a result event to a requested Service Request line.<br />
<br />
The result event is connected to a service request line. For an event to result in an interrupt, this service request line must be enabled in VADC and the NVIC node which this service request line is connected to must have interrupt generation enabled. A call to this API would access the registers GxREVNP0 GxREVNP1.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#gadd781581d9749d4f79c9d8a2b6570596">XMC_VADC_GROUP_TriggerResultEvent()</a><br />
 <a class="el" href="group___v_a_d_c.html#gaf4178ad4431b23112dbc89e8e258bc22">XMC_VADC_GROUP_ClearResultEvent()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae1406cd26c69119e3a181b38f9d1fd26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_SetSyncMaster </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configures a VADC Group as a master group.<br />
<br />
Conversion of identically numbered channels across groups can be synchronized. For example, when the trigger to convert CH-1 of Group-2 is received, it is possible to simultaneously request conversion of CH-1 of Group-0 and Group-3. Group-2 in this example is therefore the master group while Groups-0 and 3 are the slave groups.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gac1469b90543473edcd8bfd1253166cc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_SetSyncSlave </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>master_grp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>slave_group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC Group which must be set as a slave </td></tr>
    <tr><td class="paramname">master_grp</td><td>The master group number<br />
 Range: [0x0 - 0x3] </td></tr>
    <tr><td class="paramname">slave_group</td><td>The slave group number<br />
 Range: [0x0 - 0x3]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configures a VADC Group as a slave group.<br />
<br />
 Conversion of identically numbered channels across groups can be synchronized. For example, when the trigger to convert CH-1 of Group-2 is received, it is possible to simultaneously request conversion of CH-1 of Group-0 and Group-3. Group-2 in this example is therefore the master group while Groups-0 and 3 are the slave groups. It uses the SYNCCTR register for the configuration settings.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#gae1406cd26c69119e3a181b38f9d1fd26">XMC_VADC_GROUP_SetSyncMaster()</a><br />
 <a class="el" href="group___v_a_d_c.html#ga22b85c7c9fc777c05d74f1ae2a7cc9ac">XMC_VADC_GROUP_CheckSlaveReadiness()</a><br />
 <a class="el" href="group___v_a_d_c.html#gadb698bad87dcbc3fdf6ce8d6df1ecbb4">XMC_VADC_GROUP_EnableChannelSyncRequest()</a><br />
 </dd></dl>

</div>
</div>
<a class="anchor" id="gadd781581d9749d4f79c9d8a2b6570596"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_TriggerResultEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>res_reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
    <tr><td class="paramname">res_reg</td><td>Result Register for which the result event is being asserted <br />
Range: [0x0 to 0xF] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Manually asserts the result event.<br />
<br />
The result event must necessarily be connected to a SR line. The SR in turn must have been enabled along with the corresponding NVIC node. Only then will the assertion of RES event lead to an interrupt. A call to this API would access the register bit fieldS OF GxREFLAG.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___v_a_d_c.html#gaf4178ad4431b23112dbc89e8e258bc22">XMC_VADC_GROUP_ClearResultEvent()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1723512610fb75b8092cab99d15997ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_VADC_GROUP_TriggerServiceRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___v_a_d_c.html#ga1cab39abba3ecb096d57ab19b5774800">XMC_VADC_GROUP_t</a> *const&#160;</td>
          <td class="paramname"><em>group_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>sr_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___v_a_d_c.html#ga14a1cbb73bf2a92a3321aea14488f354">XMC_VADC_GROUP_IRQ_t</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_ptr</td><td>Constant pointer to the VADC group </td></tr>
    <tr><td class="paramname">sr_num</td><td>The service request number (0 through 3) </td></tr>
    <tr><td class="paramname">type</td><td>IRQ type (Kernel specific interrupt vs Module wide shared interrupt ) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Activates a Service Request line(manually trigger).<br />
<br />
VADC provides few SR lines for each group and a few more which is shared across all the groups. These SR lines can be connected to an NVIC node which in-turn would generate an interrupt. This API would manually trigger the given SR line. Could be used for evaluation and testing purposes.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Feb 27 2015 10:51:57 for XMC Peripheral Library for XMC1000 Family by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
