<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>XMC Peripheral Library for XMC1000 Family: FLASH</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="IFX_LOGO_4C_medium.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">XMC Peripheral Library for XMC1000 Family
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">FLASH<div class="ingroups"><a class="el" href="group___x_m_clib.html">XMC Peripheral Library</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga04349ce03dfa72d4f921e26fab7bb908"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga04349ce03dfa72d4f921e26fab7bb908">XMC_FLASH_BASE</a>&#160;&#160;&#160;(0x10001000U)</td></tr>
<tr class="separator:ga04349ce03dfa72d4f921e26fab7bb908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e9511c59c7236d5adfd24eccb00acf9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga4e9511c59c7236d5adfd24eccb00acf9">XMC_FLASH_BLOCKS_PER_PAGE</a>&#160;&#160;&#160;(16U)</td></tr>
<tr class="separator:ga4e9511c59c7236d5adfd24eccb00acf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga264df7592f637691b17fda2a74f8e8b9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga264df7592f637691b17fda2a74f8e8b9">XMC_FLASH_BYTES_PER_BLOCK</a>&#160;&#160;&#160;(16U)</td></tr>
<tr class="separator:ga264df7592f637691b17fda2a74f8e8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00b2a643c63a3ce66dc6fd2fb9ba5508"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga00b2a643c63a3ce66dc6fd2fb9ba5508">XMC_FLASH_BYTES_PER_PAGE</a>&#160;&#160;&#160;(256U)</td></tr>
<tr class="separator:ga00b2a643c63a3ce66dc6fd2fb9ba5508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c8a7688649dce67701e362968ed8b71"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga3c8a7688649dce67701e362968ed8b71">XMC_FLASH_BYTES_PER_SECTOR</a>&#160;&#160;&#160;(4096U)</td></tr>
<tr class="separator:ga3c8a7688649dce67701e362968ed8b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8584083372a19b432a102433550f2505"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga8584083372a19b432a102433550f2505">XMC_FLASH_MAJOR_VERSION</a>&#160;&#160;&#160;(1U)</td></tr>
<tr class="separator:ga8584083372a19b432a102433550f2505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29b37072f3bf2562af8317555e0e641f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga29b37072f3bf2562af8317555e0e641f">XMC_FLASH_MINOR_VERSION</a>&#160;&#160;&#160;(0U)</td></tr>
<tr class="separator:ga29b37072f3bf2562af8317555e0e641f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4af65ad5452c6e96162582b28dc012f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#gae4af65ad5452c6e96162582b28dc012f">XMC_FLASH_PAGES_PER_SECTOR</a>&#160;&#160;&#160;(16U)</td></tr>
<tr class="separator:gae4af65ad5452c6e96162582b28dc012f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08f03d5830ed81c60ac22b9389a1c6d7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga08f03d5830ed81c60ac22b9389a1c6d7">XMC_FLASH_PATCH_VERSION</a>&#160;&#160;&#160;(2U)</td></tr>
<tr class="separator:ga08f03d5830ed81c60ac22b9389a1c6d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3630a52ad62064d7ec32acb9f6e0ada"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#gad3630a52ad62064d7ec32acb9f6e0ada">XMC_FLASH_WORDS_PER_BLOCK</a>&#160;&#160;&#160;(4U)</td></tr>
<tr class="separator:gad3630a52ad62064d7ec32acb9f6e0ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8baf803359cd0c484bed4123ea4d8446"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga8baf803359cd0c484bed4123ea4d8446">XMC_FLASH_WORDS_PER_PAGE</a>&#160;&#160;&#160;(64U)</td></tr>
<tr class="separator:ga8baf803359cd0c484bed4123ea4d8446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26910796f9c90bb2c88060381bc45ff6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga26910796f9c90bb2c88060381bc45ff6">XMC_FLASH_WORDS_PER_SECTOR</a>&#160;&#160;&#160;(1024U)</td></tr>
<tr class="separator:ga26910796f9c90bb2c88060381bc45ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga1ef5e96ac5c0fd9dd006a9c3aead2a9d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga1ef5e96ac5c0fd9dd006a9c3aead2a9d">XMC_FLASH_EVENT_t</a> { <a class="el" href="group___f_l_a_s_h.html#gga1ef5e96ac5c0fd9dd006a9c3aead2a9dac7785d858af40ee0b8897931f58f1add">XMC_FLASH_EVENT_READY</a> = NVM_NVMCONF_INT_ON_Msk
 }</td></tr>
<tr class="separator:ga1ef5e96ac5c0fd9dd006a9c3aead2a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0c36057e8d3848002e1bad7221badf9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#gab0c36057e8d3848002e1bad7221badf9">XMC_FLASH_HARDREAD_LEVEL_t</a> { <br />
&#160;&#160;<a class="el" href="group___f_l_a_s_h.html#ggab0c36057e8d3848002e1bad7221badf9a35f5a67f64daf0ee5a278816750ec2a8">XMC_FLASH_HARDREAD_LEVEL_NORMAL</a> = (uint16_t)0x0, 
<br />
&#160;&#160;<a class="el" href="group___f_l_a_s_h.html#ggab0c36057e8d3848002e1bad7221badf9a2566fede36c5e94f1d0024869a69d3dd">XMC_FLASH_HARDREAD_LEVEL_WRITTEN</a> = (uint16_t)0x1, 
<br />
&#160;&#160;<a class="el" href="group___f_l_a_s_h.html#ggab0c36057e8d3848002e1bad7221badf9a576df2bd0dcf62e147fb2eba3e1770dd">XMC_FLASH_HARDREAD_LEVEL_ERASED</a> = (uint16_t)0x2
<br />
 }</td></tr>
<tr class="separator:gab0c36057e8d3848002e1bad7221badf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec69607b9daecffb4215faca73d02ebc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#gaec69607b9daecffb4215faca73d02ebc">XMC_FLASH_STATUS_t</a> { <br />
&#160;&#160;<a class="el" href="group___f_l_a_s_h.html#ggaec69607b9daecffb4215faca73d02ebca083aba939fe424ed79247a2c2ae27807">XMC_FLASH_STATUS_OK</a> = 0U, 
<br />
&#160;&#160;<a class="el" href="group___f_l_a_s_h.html#ggaec69607b9daecffb4215faca73d02ebcaf9f87eda000da5d7cb50aed5d8d58835">XMC_FLASH_STATUS_BUSY</a> = NVM_NVMSTATUS_BUSY_Msk, 
<br />
&#160;&#160;<a class="el" href="group___f_l_a_s_h.html#ggaec69607b9daecffb4215faca73d02ebcaac366f040e019a43084cac0959b51ce1">XMC_FLASH_STATUS_SLEEP_MODE</a> = NVM_NVMSTATUS_SLEEP_Msk, 
<br />
&#160;&#160;<a class="el" href="group___f_l_a_s_h.html#ggaec69607b9daecffb4215faca73d02ebca1bb4dde4b92f4e55b5f4ca9c8a7066f0">XMC_FLASH_STATUS_VERIFY_ERROR</a> = NVM_NVMSTATUS_VERR_Msk, 
<br />
&#160;&#160;<a class="el" href="group___f_l_a_s_h.html#ggaec69607b9daecffb4215faca73d02ebca8f630d2de1490fad7c5177ab40ba526a">XMC_FLASH_STATUS_ECC1_READ_ERROR</a> = NVM_NVMSTATUS_ECC1READ_Msk, 
<br />
&#160;&#160;<a class="el" href="group___f_l_a_s_h.html#ggaec69607b9daecffb4215faca73d02ebcaa617dbe3ef66c6652ce6f14c0809ab21">XMC_FLASH_STATUS_ECC2_READ_ERROR</a> = NVM_NVMSTATUS_ECC2READ_Msk, 
<br />
&#160;&#160;<a class="el" href="group___f_l_a_s_h.html#ggaec69607b9daecffb4215faca73d02ebcae985a7ab48f1505274690d83dffb1319">XMC_FLASH_STATUS_WRITE_PROTOCOL_ERROR</a> = NVM_NVMSTATUS_WRPERR_Msk
<br />
 }</td></tr>
<tr class="separator:gaec69607b9daecffb4215faca73d02ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab3972a9f18acaa900499351a4843ff38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#gab3972a9f18acaa900499351a4843ff38">XMC_FLASH_ClearStatus</a> (void)</td></tr>
<tr class="separator:gab3972a9f18acaa900499351a4843ff38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga162346fadd0c8caacda1738259da404e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga162346fadd0c8caacda1738259da404e">XMC_FLASH_DisableEvent</a> (const uint32_t event_msk)</td></tr>
<tr class="separator:ga162346fadd0c8caacda1738259da404e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dae70005cbc3265b504a7232cc72b86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga2dae70005cbc3265b504a7232cc72b86">XMC_FLASH_EnableEvent</a> (const uint32_t event_msk)</td></tr>
<tr class="separator:ga2dae70005cbc3265b504a7232cc72b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0073bec84d093e51c76769d076d8df7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#gae0073bec84d093e51c76769d076d8df7">XMC_FLASH_EnterSleepMode</a> (void)</td></tr>
<tr class="separator:gae0073bec84d093e51c76769d076d8df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67657cf59910eb6b738116e5488abeae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga67657cf59910eb6b738116e5488abeae">XMC_FLASH_ErasePage</a> (uint32_t *address)</td></tr>
<tr class="separator:ga67657cf59910eb6b738116e5488abeae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dd74f472cacfe30c189362522657699"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga9dd74f472cacfe30c189362522657699">XMC_FLASH_ErasePages</a> (uint32_t *address, uint32_t num_pages)</td></tr>
<tr class="separator:ga9dd74f472cacfe30c189362522657699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29bb5d4f245ae9ed8d1655dff2dd8ec6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga29bb5d4f245ae9ed8d1655dff2dd8ec6">XMC_FLASH_EraseSector</a> (uint32_t *address)</td></tr>
<tr class="separator:ga29bb5d4f245ae9ed8d1655dff2dd8ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga032a6acea8c8b125cde1da5941f89c30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga032a6acea8c8b125cde1da5941f89c30">XMC_FLASH_ExitSleepMode</a> (void)</td></tr>
<tr class="separator:ga032a6acea8c8b125cde1da5941f89c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf893b420d0166d0a3a320dee9101928d"><td class="memItemLeft" align="right" valign="top">XMC_DRIVER_VERSION_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#gaf893b420d0166d0a3a320dee9101928d">XMC_FLASH_GetDriverVersion</a> (void)</td></tr>
<tr class="separator:gaf893b420d0166d0a3a320dee9101928d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc93e46f19331fe15be8cd0f2a8fa28b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#gabc93e46f19331fe15be8cd0f2a8fa28b">XMC_FLASH_GetSectorAddress</a> (uint32_t sector)</td></tr>
<tr class="separator:gabc93e46f19331fe15be8cd0f2a8fa28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50275a88263d4fdfb85261d352eac1d5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga50275a88263d4fdfb85261d352eac1d5">XMC_FLASH_GetStatus</a> (void)</td></tr>
<tr class="separator:ga50275a88263d4fdfb85261d352eac1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d687d0d1d5bdc9173d96c7619172cd8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga7d687d0d1d5bdc9173d96c7619172cd8">XMC_FLASH_IsBusy</a> (void)</td></tr>
<tr class="separator:ga7d687d0d1d5bdc9173d96c7619172cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ba9c9992649eb6d84b03d2260efbe31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga7ba9c9992649eb6d84b03d2260efbe31">XMC_FLASH_ProgramPage</a> (uint32_t *address, const uint32_t *data)</td></tr>
<tr class="separator:ga7ba9c9992649eb6d84b03d2260efbe31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f8453790d968512e6a25da531140179"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga3f8453790d968512e6a25da531140179">XMC_FLASH_ProgramVerifyPage</a> (uint32_t *address, const uint32_t *data)</td></tr>
<tr class="separator:ga3f8453790d968512e6a25da531140179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90cec357405f2edafa4aa96cc3e1de1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga90cec357405f2edafa4aa96cc3e1de1d">XMC_FLASH_ReadBlocks</a> (uint32_t *address, uint32_t *data, uint32_t num_blocks)</td></tr>
<tr class="separator:ga90cec357405f2edafa4aa96cc3e1de1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dc344064838670ac3b0d7b4c2c9a0fb"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga4dc344064838670ac3b0d7b4c2c9a0fb">XMC_FLASH_ReadWord</a> (const uint32_t *const address)</td></tr>
<tr class="separator:ga4dc344064838670ac3b0d7b4c2c9a0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab71e15fdc8ded3ce14f2f697f6ff3027"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#gab71e15fdc8ded3ce14f2f697f6ff3027">XMC_FLASH_SetHardReadLevel</a> (<a class="el" href="group___f_l_a_s_h.html#gab0c36057e8d3848002e1bad7221badf9">XMC_FLASH_HARDREAD_LEVEL_t</a> level)</td></tr>
<tr class="separator:gab71e15fdc8ded3ce14f2f697f6ff3027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab05fe59c132f2f7d9e5b8a5896aa4796"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#gab05fe59c132f2f7d9e5b8a5896aa4796">XMC_FLASH_SetSectorProtection</a> (uint32_t num_sectors)</td></tr>
<tr class="separator:gab05fe59c132f2f7d9e5b8a5896aa4796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7159be439f872a52db4b20f74477e75d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga7159be439f872a52db4b20f74477e75d">XMC_FLASH_VerifyBlocks</a> (uint32_t *address, const uint32_t *data, uint32_t num_blocks)</td></tr>
<tr class="separator:ga7159be439f872a52db4b20f74477e75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d23629533ee3a703972649db4372ebe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga9d23629533ee3a703972649db4372ebe">XMC_FLASH_WriteBlocks</a> (uint32_t *address, const uint32_t *data, uint32_t num_blocks, bool verify)</td></tr>
<tr class="separator:ga9d23629533ee3a703972649db4372ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Flash is a non volatile memory module used to store instruction code or constant data. The flash low level driver provides support to the following functionalities of flash memory.<br />
 </p><ol>
<li>
Provides functions to program and verify pages. ( <a class="el" href="group___f_l_a_s_h.html#ga7ba9c9992649eb6d84b03d2260efbe31">XMC_FLASH_ProgramPage()</a>, XMC_FLASH_ProgramPages() <a class="el" href="group___f_l_a_s_h.html#ga3f8453790d968512e6a25da531140179">XMC_FLASH_ProgramVerifyPage()</a> )<br />
 </li>
<li>
Provides functions to write and verify blocks. ( <a class="el" href="group___f_l_a_s_h.html#ga9d23629533ee3a703972649db4372ebe">XMC_FLASH_WriteBlocks()</a>, <a class="el" href="group___f_l_a_s_h.html#ga7159be439f872a52db4b20f74477e75d">XMC_FLASH_VerifyBlocks()</a> )<br />
 </li>
<li>
Provides functions to read data in terms of word and blocks. ( <a class="el" href="group___f_l_a_s_h.html#ga90cec357405f2edafa4aa96cc3e1de1d">XMC_FLASH_ReadBlocks()</a>, <a class="el" href="group___f_l_a_s_h.html#ga4dc344064838670ac3b0d7b4c2c9a0fb">XMC_FLASH_ReadWord()</a> ) <br />
 </li>
<li>
Provides function to erase page. ( <a class="el" href="group___f_l_a_s_h.html#ga67657cf59910eb6b738116e5488abeae">XMC_FLASH_ErasePage()</a> ) <br />
 </li>
</ol>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga04349ce03dfa72d4f921e26fab7bb908"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_BASE&#160;&#160;&#160;(0x10001000U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starting address of flash for XMC1 family of microcontrollers </p>

</div>
</div>
<a class="anchor" id="ga4e9511c59c7236d5adfd24eccb00acf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_BLOCKS_PER_PAGE&#160;&#160;&#160;(16U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of blocks in a page. A block consists of 4 words(16 bytes). </p>

</div>
</div>
<a class="anchor" id="ga264df7592f637691b17fda2a74f8e8b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_BYTES_PER_BLOCK&#160;&#160;&#160;(16U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of bytes in a block. (128 bits = 16 bytes) </p>

</div>
</div>
<a class="anchor" id="ga00b2a643c63a3ce66dc6fd2fb9ba5508"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_BYTES_PER_PAGE&#160;&#160;&#160;(256U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of bytes in a page. (16 blocks * 16 bytes = 256 bytes) </p>

</div>
</div>
<a class="anchor" id="ga3c8a7688649dce67701e362968ed8b71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_BYTES_PER_SECTOR&#160;&#160;&#160;(4096U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of bytes in a sector. (16 pages * 256 bytes = 4096 bytes) </p>

</div>
</div>
<a class="anchor" id="ga8584083372a19b432a102433550f2505"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_MAJOR_VERSION&#160;&#160;&#160;(1U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Major number of the driver version, which is, &lt;major.&lt;minor&gt;.&lt;patch&gt; </p>

</div>
</div>
<a class="anchor" id="ga29b37072f3bf2562af8317555e0e641f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_MINOR_VERSION&#160;&#160;&#160;(0U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Minor number of the driver version, which is, &lt;major.&lt;minor&gt;.&lt;patch&gt; </p>

</div>
</div>
<a class="anchor" id="gae4af65ad5452c6e96162582b28dc012f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_PAGES_PER_SECTOR&#160;&#160;&#160;(16U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of pages in a sector. A page consists of 16 blocks. </p>

</div>
</div>
<a class="anchor" id="ga08f03d5830ed81c60ac22b9389a1c6d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_PATCH_VERSION&#160;&#160;&#160;(2U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Minor number of the driver version, which is, &lt;major.&lt;minor&gt;.&lt;patch&gt; </p>

</div>
</div>
<a class="anchor" id="gad3630a52ad62064d7ec32acb9f6e0ada"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_WORDS_PER_BLOCK&#160;&#160;&#160;(4U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of words in a block. (128 bit / 32 bit = 4 words) </p>

</div>
</div>
<a class="anchor" id="ga8baf803359cd0c484bed4123ea4d8446"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_WORDS_PER_PAGE&#160;&#160;&#160;(64U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of words in a page. (16 blocks * 4 words = 64 words) </p>

</div>
</div>
<a class="anchor" id="ga26910796f9c90bb2c88060381bc45ff6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_WORDS_PER_SECTOR&#160;&#160;&#160;(1024U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of words in a sector. (16 pages * 64 words = 1024 words) </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga1ef5e96ac5c0fd9dd006a9c3aead2a9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___f_l_a_s_h.html#ga1ef5e96ac5c0fd9dd006a9c3aead2a9d">XMC_FLASH_EVENT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines NVM ready interrupt event. Use type <em>XMC_FLASH_EVENT_t</em> for this enum. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga1ef5e96ac5c0fd9dd006a9c3aead2a9dac7785d858af40ee0b8897931f58f1add"></a>XMC_FLASH_EVENT_READY&#160;</td><td class="fielddoc">
<p>Generates the NVM ready interrupts on flash sequence completion </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gab0c36057e8d3848002e1bad7221badf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___f_l_a_s_h.html#gab0c36057e8d3848002e1bad7221badf9">XMC_FLASH_HARDREAD_LEVEL_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines hard read levels for strict data verification. Use type <em>XMC_FLASH_HARDREAD_LEVEL_t</em> for this enum. These <em>hardread</em> levels provide some margin to ensure that the data is really programmed with suitably distinct levels for written and erased bits. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggab0c36057e8d3848002e1bad7221badf9a35f5a67f64daf0ee5a278816750ec2a8"></a>XMC_FLASH_HARDREAD_LEVEL_NORMAL&#160;</td><td class="fielddoc">
<p>No <em>hardread</em> level verification enabled (Normal read) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab0c36057e8d3848002e1bad7221badf9a2566fede36c5e94f1d0024869a69d3dd"></a>XMC_FLASH_HARDREAD_LEVEL_WRITTEN&#160;</td><td class="fielddoc">
<p>Enables strict margin compare for written data cells </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab0c36057e8d3848002e1bad7221badf9a576df2bd0dcf62e147fb2eba3e1770dd"></a>XMC_FLASH_HARDREAD_LEVEL_ERASED&#160;</td><td class="fielddoc">
<p>Enables strict margin compare for erased data cells </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gaec69607b9daecffb4215faca73d02ebc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___f_l_a_s_h.html#gaec69607b9daecffb4215faca73d02ebc">XMC_FLASH_STATUS_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the status of flash, to verify the flash related API calls. Use type <em>XMC_FLASH_STATUS_t</em> for this enum. The members defines the respective masked status bits of <em>NVMSTATUS</em> register. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaec69607b9daecffb4215faca73d02ebca083aba939fe424ed79247a2c2ae27807"></a>XMC_FLASH_STATUS_OK&#160;</td><td class="fielddoc">
<p>Flash related operation was successfully completed </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaec69607b9daecffb4215faca73d02ebcaf9f87eda000da5d7cb50aed5d8d58835"></a>XMC_FLASH_STATUS_BUSY&#160;</td><td class="fielddoc">
<p>Cannot execute the flash request because another operation is in progress </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaec69607b9daecffb4215faca73d02ebcaac366f040e019a43084cac0959b51ce1"></a>XMC_FLASH_STATUS_SLEEP_MODE&#160;</td><td class="fielddoc">
<p>Flash is in sleep mode </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaec69607b9daecffb4215faca73d02ebca1bb4dde4b92f4e55b5f4ca9c8a7066f0"></a>XMC_FLASH_STATUS_VERIFY_ERROR&#160;</td><td class="fielddoc">
<p>Flash reported a verification failure </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaec69607b9daecffb4215faca73d02ebca8f630d2de1490fad7c5177ab40ba526a"></a>XMC_FLASH_STATUS_ECC1_READ_ERROR&#160;</td><td class="fielddoc">
<p>Flash reports a single bit failure, and it is automatically corrected. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaec69607b9daecffb4215faca73d02ebcaa617dbe3ef66c6652ce6f14c0809ab21"></a>XMC_FLASH_STATUS_ECC2_READ_ERROR&#160;</td><td class="fielddoc">
<p>Flash reported at least two bit failure </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaec69607b9daecffb4215faca73d02ebcae985a7ab48f1505274690d83dffb1319"></a>XMC_FLASH_STATUS_WRITE_PROTOCOL_ERROR&#160;</td><td class="fielddoc">
<p>Write/Verify operation on a block is failed due to protocol violations or write protected sectors </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gab3972a9f18acaa900499351a4843ff38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_FLASH_ClearStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Clears the previous error status by reseting the ECC and VERR error status bits of NVMSTATUS register.<br />
<br />
Call this API before starting any flash programming / erase related APIs to ensure all previous errors are cleared.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga162346fadd0c8caacda1738259da404e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_FLASH_DisableEvent </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>event_msk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uint32_t</td><td>ORed values of <a class="el" href="group___f_l_a_s_h.html#ga1ef5e96ac5c0fd9dd006a9c3aead2a9d">XMC_FLASH_EVENT_t</a> enumeration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables the particular flash events as specified in the input parameter.<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___f_l_a_s_h.html#ga2dae70005cbc3265b504a7232cc72b86">XMC_FLASH_EnableEvent()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga2dae70005cbc3265b504a7232cc72b86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_FLASH_EnableEvent </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>event_msk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uint32_t</td><td>ORed values of <a class="el" href="group___f_l_a_s_h.html#ga1ef5e96ac5c0fd9dd006a9c3aead2a9d">XMC_FLASH_EVENT_t</a> enumeration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables the particular flash events as specified in the input parameter.<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___f_l_a_s_h.html#ga162346fadd0c8caacda1738259da404e">XMC_FLASH_DisableEvent()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gae0073bec84d093e51c76769d076d8df7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_FLASH_EnterSleepMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables the flash to enter into sleep mode by resetting the NVMCONF register NVM_ON bit.<br />
<br />
 Flash can wake up from sleep mode on any flash operation completion ready event trigger. To disable the sleep mode any time during execution call the API <a class="el" href="group___f_l_a_s_h.html#ga032a6acea8c8b125cde1da5941f89c30">XMC_FLASH_ExitSleepMode()</a>.<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___f_l_a_s_h.html#ga032a6acea8c8b125cde1da5941f89c30">XMC_FLASH_ExitSleepMode()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga67657cf59910eb6b738116e5488abeae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_FLASH_ErasePage </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>Pointer to the starting address of the page to be erased</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Erases a single flash page associated to the specified <em>address</em>.<br />
<br />
 XMC1000 Flash can be erased with granularity of one page = 16 blocks of 16 Bytes = 256 Bytes using this API. It internally calls the Flash Firmware routine <em>XMC1000_NvmErasePage(unsigned long pageAddr)</em> to perform the erase operation. Refer XMC1000 reference manual for more details on flash firmware routines (Section 25.3). Call <a class="el" href="group___f_l_a_s_h.html#ga50275a88263d4fdfb85261d352eac1d5">XMC_FLASH_GetStatus()</a> API after calling this API, to verify the erase operation.<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___f_l_a_s_h.html#ga9dd74f472cacfe30c189362522657699">XMC_FLASH_ErasePages()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga9dd74f472cacfe30c189362522657699"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_FLASH_ErasePages </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_pages</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>Pointer to the starting address of the flash page from where the erase starts </td></tr>
    <tr><td class="paramname">num_pages</td><td>Number of pages to be erased.<br />
 Range: [1 to (flash size / 256)]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Erases a set of flash memory pages.<br />
<br />
 Erase starts from the specified <em>address</em>. It erases a maximum number of <em>num_pages</em> flash pages. The maximum erasable pages are limited to microcontroller flash size. It sets NVMPROG register to continuous page erase mode before erase and resets it action back to normal state on completion. Call <a class="el" href="group___f_l_a_s_h.html#ga50275a88263d4fdfb85261d352eac1d5">XMC_FLASH_GetStatus()</a> after calling this API to verify the erase operation.<br />
 </dd></dl>
<dl class="section user"><dt>Note:</dt><dd>Flash will be in busy state during erase operation. Hence no operations on flash are allowed until it completes.<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___f_l_a_s_h.html#ga29bb5d4f245ae9ed8d1655dff2dd8ec6">XMC_FLASH_EraseSector()</a>, <a class="el" href="group___f_l_a_s_h.html#ga67657cf59910eb6b738116e5488abeae">XMC_FLASH_ErasePage()</a> <br />
<br />
<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga29bb5d4f245ae9ed8d1655dff2dd8ec6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_FLASH_EraseSector </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>Pointer to the starting address of the page to be erased.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Erases a complete sector starting from the <em>address</em> specified.<br />
<br />
 XMC1000 Flash can be erased with granularity of one page = 16 blocks of 16 Bytes = 256 Bytes using this API. It internally calls XMC_FLASH_ErasePages API 16 times starting from the first page of the sector.. Call <a class="el" href="group___f_l_a_s_h.html#ga50275a88263d4fdfb85261d352eac1d5">XMC_FLASH_GetStatus()</a> API after calling this API, to verify the erase operation.<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___f_l_a_s_h.html#ga9dd74f472cacfe30c189362522657699">XMC_FLASH_ErasePages()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga032a6acea8c8b125cde1da5941f89c30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_FLASH_ExitSleepMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables the flash to exit from sleep mode by setting the NVMCONF register NVM_ON bit.<br />
<br />
 Calling the API <a class="el" href="group___f_l_a_s_h.html#gae0073bec84d093e51c76769d076d8df7">XMC_FLASH_EnterSleepMode()</a> allows the flash to renter into sleep mode.<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___f_l_a_s_h.html#gae0073bec84d093e51c76769d076d8df7">XMC_FLASH_EnterSleepMode()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gaf893b420d0166d0a3a320dee9101928d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XMC_DRIVER_VERSION_t XMC_FLASH_GetDriverVersion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Data structure XMC_DRIVER_VERSION_t storing driver version</dd></dl>
<dl class="section user"><dt>Description: </dt><dd>Return the version of the low level driver <br />
</dd></dl>
<dl class="section user"><dt></dt><dd>The function can be used to check application software compatibility with a specific version of the low level driver.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gabc93e46f19331fe15be8cd0f2a8fa28b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_FLASH_GetSectorAddress </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sector</td><td>Flash sector number for which the address extraction is needed<br />
 Range: [0 to 51]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t Starting address of the sector specified<br />
 Range: [0x10001000 to 0x10032000]</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Finds the starting address of the specified <em>sector</em> number.<br />
<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>
<p>&lt; Starting address of flash for XMC1 family of microcontrollers</p>
<p>&lt; Number of bytes in a sector. (16 pages * 256 bytes = 4096 bytes) </p>

</div>
</div>
<a class="anchor" id="ga50275a88263d4fdfb85261d352eac1d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_FLASH_GetStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t Status of the previous flash operation.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Informs the status of flash by reading the NVMSTATUS register.<br />
<br />
 It indicates the ECC, VERR(verification error), WRPERR (Write protocol error) errors as well as the current flash state. After calling the flash read/write/erase operation related APIs, call this API to get the verification status. The return value of this API shall be checked against the members of <a class="el" href="group___f_l_a_s_h.html#gaec69607b9daecffb4215faca73d02ebc">XMC_FLASH_STATUS_t</a> enumeration to get the relevant status.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

<p>Referenced by <a class="el" href="group___f_l_a_s_h.html#ga7d687d0d1d5bdc9173d96c7619172cd8">XMC_FLASH_IsBusy()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7d687d0d1d5bdc9173d96c7619172cd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_FLASH_IsBusy </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if flash is in busy state else returns <em>false</em>.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Checks whether flash is in busy state or not.<br />
<br />
 It is checked by calling the <a class="el" href="group___f_l_a_s_h.html#ga50275a88263d4fdfb85261d352eac1d5">XMC_FLASH_GetStatus()</a> API internally. Refer <a class="el" href="group___f_l_a_s_h.html#ga50275a88263d4fdfb85261d352eac1d5">XMC_FLASH_GetStatus()</a> for more details.<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___f_l_a_s_h.html#ga50275a88263d4fdfb85261d352eac1d5">XMC_FLASH_GetStatus()</a><br />
<br />
<br />
</dd></dl>

<p>References <a class="el" href="group___f_l_a_s_h.html#ga50275a88263d4fdfb85261d352eac1d5">XMC_FLASH_GetStatus()</a>, and <a class="el" href="group___f_l_a_s_h.html#ggaec69607b9daecffb4215faca73d02ebcaf9f87eda000da5d7cb50aed5d8d58835">XMC_FLASH_STATUS_BUSY</a>.</p>

</div>
</div>
<a class="anchor" id="ga7ba9c9992649eb6d84b03d2260efbe31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_FLASH_ProgramPage </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>Pointer to the starting address of flash page from where the programming starts. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the source address where targeted data is located.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Programs a single flash page associated with the specified <em>address</em>.<br />
<br />
 XMC1000 Flash can be programmed with one page (256 bytes) using this API. It calls the Flash Firmware routine <em>XMC1000_NvmProgVerify(unsigned long pageAddr)</em> to perform the programming. Refer XMC1000 reference manual of for more details on flash firmware routines (Section 25.3). Call <a class="el" href="group___f_l_a_s_h.html#ga50275a88263d4fdfb85261d352eac1d5">XMC_FLASH_GetStatus()</a> API after calling this API, to verify the erase operation.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>Flash will be busy state during write is ongoing, hence no operations allowed until it completes.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga3f8453790d968512e6a25da531140179"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_FLASH_ProgramVerifyPage </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>Pointer to the starting address of flash page from where the programming starts. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the source address where targeted data blocks are located.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Erases, programs and verifies a single flash page starting from the <em>address</em> specified.<br />
<br />
 XMC1000 Flash can be programmed with granularity of one page = 16 blocks of 16 Bytes = 256 Bytes using this API. It internally calls the Flash Firmware routine <em>XMC1000_NvmProgVerify(unsigned long pageAddr)</em> to perform the programming. Refer XMC1000 reference manual of for more details on flash firmware routines (Section 25.3). Call <a class="el" href="group___f_l_a_s_h.html#ga50275a88263d4fdfb85261d352eac1d5">XMC_FLASH_GetStatus()</a> API after calling this API, to verify the erase operation.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga90cec357405f2edafa4aa96cc3e1de1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_FLASH_ReadBlocks </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_blocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>Pointer to the starting address of flash block from where the read starts. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the destination address, where the read data blocks to be stored. </td></tr>
    <tr><td class="paramname">num_blocks</td><td>Number of blocks to be read.<br />
 Range: [1 to (flash size / 16)]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Reads multiple blocks from flash in one shot, starting from the <em>address</em> specified.<br />
<br />
 The read blocks are stored into the locations starting from the <em>data</em> address. Calling <a class="el" href="group___f_l_a_s_h.html#ga50275a88263d4fdfb85261d352eac1d5">XMC_FLASH_GetStatus()</a> API after calling this API verifies the read operation.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga4dc344064838670ac3b0d7b4c2c9a0fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_FLASH_ReadWord </td>
          <td>(</td>
          <td class="paramtype">const uint32_t *const&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>Pointer to the flash word address from where the read is expected</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 a 32bit data word stored in the specified <em>address</em>.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Reads a single word from the specified flash<em>address</em>.<br />
<br />
 Calling <a class="el" href="group___f_l_a_s_h.html#ga50275a88263d4fdfb85261d352eac1d5">XMC_FLASH_GetStatus()</a> API after calling this API returns the read status.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___f_l_a_s_h.html#ga90cec357405f2edafa4aa96cc3e1de1d">XMC_FLASH_ReadBlocks()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab71e15fdc8ded3ce14f2f697f6ff3027"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_FLASH_SetHardReadLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___f_l_a_s_h.html#gab0c36057e8d3848002e1bad7221badf9">XMC_FLASH_HARDREAD_LEVEL_t</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>Hard read levels specified in <em>XMC_FLASH_HARDREAD_LEVEL_t</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets the hard read level for verification process.<br />
<br />
 It insists the flash to do a strict margin compare with the written/erased data against the internal buffer. Sets the NVMCONF register HRLEV field with <em>level</em> value. This hardread level is used until the end of the verification sequence and, may not be changed in between.<br />
<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gab05fe59c132f2f7d9e5b8a5896aa4796"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_FLASH_SetSectorProtection </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_sectors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_sectors</td><td>Number of sectors to be protected<br />
 Range: [0 to 51]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Protect the flash sectors starting from 0th sector to the specified <em>num_sectors</em>.<br />
<br />
 It sets the NVMCONF register SECPROT field with the value specified in <em>num_sectors</em>. Changing the protection limit can be achieved by calling this API at runtime with a different value of <em>num_sectors</em>.<br />
<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga7159be439f872a52db4b20f74477e75d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_FLASH_VerifyBlocks </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_blocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>Pointer to the starting address of flash block from where the verification starts. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the source address where targeted data blocks are located. </td></tr>
    <tr><td class="paramname">num_blocks</td><td>Maximum number of flash blocks writes needed.<br />
 Range: [1 to (flash size / 16)]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Performs verification of written data blocks.<br />
<br />
 After calling <a class="el" href="group___f_l_a_s_h.html#ga9d23629533ee3a703972649db4372ebe">XMC_FLASH_WriteBlocks()</a> API, calling this API will verify the correctness of written blocks. It sets the <em>NVMPROG</em> register into continuous block write mode before write and resets it action back to normal state on completion. It reads back the written data blocks from the flash and verify the values against the internal buffer values. Calling <a class="el" href="group___f_l_a_s_h.html#ga50275a88263d4fdfb85261d352eac1d5">XMC_FLASH_GetStatus()</a> API after calling this API validates the result of verification.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga9d23629533ee3a703972649db4372ebe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_FLASH_WriteBlocks </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verify</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>Pointer to the starting address of flash block from where the write starts. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the source address where targeted data blocks are located. </td></tr>
    <tr><td class="paramname">num_blocks</td><td>Maximum number of flash block writes needed.<br />
 Range: [1 to (flash size / 16)] </td></tr>
    <tr><td class="paramname">verify</td><td>If <em>true</em>, hardware verification after block write is enabled else disabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Writes a set of data blocks into the flash.<br />
<br />
 Minimum possible writable area is 16 byte block. It sets the NVMPROG register to continuous block write mode before write and resets it action back to normal state on completion. Call <a class="el" href="group___f_l_a_s_h.html#ga50275a88263d4fdfb85261d352eac1d5">XMC_FLASH_GetStatus()</a> API after calling this API to verify the erase operation.</dd></dl>
<dl class="section user"><dt>Note</dt><dd>Flash will be busy state during write is ongoing, hence no operations allowed until it completes.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Feb 27 2015 10:51:56 for XMC Peripheral Library for XMC1000 Family by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
