<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>XMC Peripheral Library for XMC1000 Family: SPI</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="IFX_LOGO_4C_medium.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">XMC Peripheral Library for XMC1000 Family
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">SPI<div class="ingroups"><a class="el" href="group___x_m_clib.html">XMC Peripheral Library</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___s_p_i___c_h___c_o_n_f_i_g__t.html">XMC_SPI_CH_CONFIG_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gac1ec1ff1047497f1d39737dd5ea87680"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gac1ec1ff1047497f1d39737dd5ea87680">XMC_SPI_MAJOR_VERSION</a>&#160;&#160;&#160;(1U)</td></tr>
<tr class="separator:gac1ec1ff1047497f1d39737dd5ea87680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01802ee68b402e38cb4bcd7fe8ee3408"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga01802ee68b402e38cb4bcd7fe8ee3408">XMC_SPI_MINOR_VERSION</a>&#160;&#160;&#160;(0U)</td></tr>
<tr class="separator:ga01802ee68b402e38cb4bcd7fe8ee3408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf063056256428693d695a820eb13dc44"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gaf063056256428693d695a820eb13dc44">XMC_SPI_PATCH_VERSION</a>&#160;&#160;&#160;(2U)</td></tr>
<tr class="separator:gaf063056256428693d695a820eb13dc44"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaf703b28cb6fe62eec40258bbb4b2381e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gaf703b28cb6fe62eec40258bbb4b2381e">XMC_SPI_CH_BRG_SHIFT_CLOCK_OUTPUT_t</a> { <br />
&#160;&#160;<a class="el" href="group___s_p_i.html#ggaf703b28cb6fe62eec40258bbb4b2381eae57defba0e28b37387753485a740acf2">XMC_SPI_CH_BRG_SHIFT_CLOCK_OUTPUT_SCLK</a> = XMC_USIC_CH_BRG_SHIFT_CLOCK_OUTPUT_SCLK, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#ggaf703b28cb6fe62eec40258bbb4b2381eae8aea9225b3233a8cf60f426bb0368f8">XMC_SPI_CH_BRG_SHIFT_CLOCK_OUTPUT_DX1</a> = XMC_USIC_CH_BRG_SHIFT_CLOCK_OUTPUT_DX1
<br />
 }</td></tr>
<tr class="separator:gaf703b28cb6fe62eec40258bbb4b2381e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad62a419e5f01dc507f3f731995873fe4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gad62a419e5f01dc507f3f731995873fe4">XMC_SPI_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_t</a> { <br />
&#160;&#160;<a class="el" href="group___s_p_i.html#ggad62a419e5f01dc507f3f731995873fe4a60da59e367df81e02204c193307c7543">XMC_SPI_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_0_DELAY_DISABLED</a> = XMC_USIC_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_0_DELAY_DISABLED, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#ggad62a419e5f01dc507f3f731995873fe4adba7c97cc13e382c36fb79a927ba779d">XMC_SPI_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_1_DELAY_DISABLED</a> = XMC_USIC_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_1_DELAY_DISABLED, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#ggad62a419e5f01dc507f3f731995873fe4a5d8efe2fd3be3cbb88685afcfc7f4e04">XMC_SPI_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_0_DELAY_ENABLED</a> = XMC_USIC_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_0_DELAY_ENABLED
<br />
 }</td></tr>
<tr class="separator:gad62a419e5f01dc507f3f731995873fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf40703e598cf0bd196246cc048dda10"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gaaf40703e598cf0bd196246cc048dda10">XMC_SPI_CH_BUS_MODE_t</a> { <br />
&#160;&#160;<a class="el" href="group___s_p_i.html#ggaaf40703e598cf0bd196246cc048dda10a6535e33ac253d974dbdade07b9bdc6d5">XMC_SPI_CH_BUS_MODE_MASTER</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#ggaaf40703e598cf0bd196246cc048dda10a6ded2d0050c88da873e2cfc0167d3e54">XMC_SPI_CH_BUS_MODE_SLAVE</a>
<br />
 }</td></tr>
<tr class="separator:gaaf40703e598cf0bd196246cc048dda10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d2e9e07d36e47a2840855c7761f3d2f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga3d2e9e07d36e47a2840855c7761f3d2f">XMC_SPI_CH_DATA_POLARITY_t</a> { <br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga3d2e9e07d36e47a2840855c7761f3d2fa07561a103212e36eb152fad4c6e0bc09">XMC_SPI_CH_DATA_POLARITY_DIRECT</a> = 0x0UL, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga3d2e9e07d36e47a2840855c7761f3d2fad4dced7ef4a2819a36fabb92a24a160b">XMC_SPI_CH_DATA_POLARITY_INVERT</a> = 0x1UL &lt;&lt; USIC_CH_DX2CR_DPOL_Pos
<br />
 }</td></tr>
<tr class="separator:ga3d2e9e07d36e47a2840855c7761f3d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cf84a07d3e3970c1b09369fcf3c12db"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga7cf84a07d3e3970c1b09369fcf3c12db">XMC_SPI_CH_EVENT_t</a> { <br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga7cf84a07d3e3970c1b09369fcf3c12dba4b9fc48875e84294585b5b62cd5faea3">XMC_SPI_CH_EVENT_RECEIVE_START</a> = (int32_t)(0x80000000U | USIC_CH_CCR_RSIEN_Msk), 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga7cf84a07d3e3970c1b09369fcf3c12dba45328c5bfb41c4fa0d7fc47e51640c6d">XMC_SPI_CH_EVENT_DATA_LOST</a> = (int32_t)(0x80000000U | USIC_CH_CCR_DLIEN_Msk), 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga7cf84a07d3e3970c1b09369fcf3c12dbadd8d1e2334f16528a036b045c0c9eefc">XMC_SPI_CH_EVENT_TRANSMIT_SHIFT</a> = (int32_t)(0x80000000U | USIC_CH_CCR_TSIEN_Msk), 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga7cf84a07d3e3970c1b09369fcf3c12dbaf08fec199ecb9705918d10cdb24ed446">XMC_SPI_CH_EVENT_TRANSMIT_BUFFER</a> = (int32_t)(0x80000000U | USIC_CH_CCR_TBIEN_Msk), 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga7cf84a07d3e3970c1b09369fcf3c12dba0accbca5448646b799940028bd294fe8">XMC_SPI_CH_EVENT_STANDARD_RECEIVE</a> = (int32_t)(0x80000000U | USIC_CH_CCR_RIEN_Msk), 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga7cf84a07d3e3970c1b09369fcf3c12dba1b751bd9beb2fcbcaaf6afd59ced9b94">XMC_SPI_CH_EVENT_ALTERNATIVE_RECEIVE</a> = (int32_t)(0x80000000U | USIC_CH_CCR_AIEN_Msk), 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga7cf84a07d3e3970c1b09369fcf3c12dba33d6fbed5535423f89e0413eb7f0ff34">XMC_SPI_CH_EVENT_BAUD_RATE_GENERATOR</a> = (int32_t)(0x80000000U | USIC_CH_CCR_BRGIEN_Msk), 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga7cf84a07d3e3970c1b09369fcf3c12dbaeccd57639b56f8276d0cf3d4ff23285e">XMC_SPI_CH_EVENT_PARITY_ERROR</a> = USIC_CH_PCR_SSCMode_PARIEN_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga7cf84a07d3e3970c1b09369fcf3c12dba9957b6f9ec5e89ec4fe744ca9b85cb9a">XMC_SPI_CH_EVENT_MSLS_CHANGE</a> = USIC_CH_PCR_SSCMode_MSLSIEN_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga7cf84a07d3e3970c1b09369fcf3c12dbab0ccd895a632344bf17ad5003af08965">XMC_SPI_CH_EVENT_DX2TIEN_ACTIVATED</a> = USIC_CH_PCR_SSCMode_DX2TIEN_Msk
<br />
 }</td></tr>
<tr class="separator:ga7cf84a07d3e3970c1b09369fcf3c12db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52dd53cd4c107af8f6d72c6c6a011886"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga52dd53cd4c107af8f6d72c6c6a011886">XMC_SPI_CH_INPUT_FREQ_SLAVE_SELECT_DELAY_t</a> { <br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga52dd53cd4c107af8f6d72c6c6a011886a58b64a73bcb7179ea3154579254725c2">XMC_SPI_CH_INPUT_FREQ_SLAVE_SELECT_DELAY_FPDIV</a> = 0x0UL, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga52dd53cd4c107af8f6d72c6c6a011886aae8eded70ac9defd6fa10321482aecda">XMC_SPI_CH_INPUT_FREQ_SLAVE_SELECT_DELAY_FPPP</a> = 0x1UL &lt;&lt; USIC_CH_PCR_SSCMode_CTQSEL1_Pos, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga52dd53cd4c107af8f6d72c6c6a011886a0c2051effe9ccca3dcd9f959874c4d36">XMC_SPI_CH_INPUT_FREQ_SLAVE_SELECT_DELAY_FSCLK</a> = 0x2UL &lt;&lt; USIC_CH_PCR_SSCMode_CTQSEL1_Pos, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga52dd53cd4c107af8f6d72c6c6a011886ad52df965918f9e56f530f872ed792d02">XMC_SPI_CH_INPUT_FREQ_SLAVE_SELECT_DELAY_FMCLK</a> = 0x3UL &lt;&lt; USIC_CH_PCR_SSCMode_CTQSEL1_Pos
<br />
 }</td></tr>
<tr class="separator:ga52dd53cd4c107af8f6d72c6c6a011886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e1e7ef1aea059d58462c59b0fd75f8f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga5e1e7ef1aea059d58462c59b0fd75f8f">XMC_SPI_CH_INPUT_t</a> { <br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga5e1e7ef1aea059d58462c59b0fd75f8fa3730321c216c06c0ae39693e68786d4c">XMC_SPI_CH_INPUT_DIN0</a> = 0UL, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga5e1e7ef1aea059d58462c59b0fd75f8fa5b0aed31501650341a5710a8db35b40a">XMC_SPI_CH_INPUT_SLAVE_SCLKIN</a> = 1UL, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga5e1e7ef1aea059d58462c59b0fd75f8fa96fe102aaf89df811f501ca34f3967a0">XMC_SPI_CH_INPUT_SLAVE_SELIN</a> = 2UL, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga5e1e7ef1aea059d58462c59b0fd75f8fa32f593df13abbed01017df7ea1cd9b11">XMC_SPI_CH_INPUT_DIN1</a> = 3UL, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga5e1e7ef1aea059d58462c59b0fd75f8fad7d757c2e37f1d9678ee76c5ac58cd9b">XMC_SPI_CH_INPUT_DIN2</a> = 4UL, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga5e1e7ef1aea059d58462c59b0fd75f8fadce039080e9a2e2795af411defb8a17e">XMC_SPI_CH_INPUT_DIN3</a> = 5UL
<br />
 }</td></tr>
<tr class="separator:ga5e1e7ef1aea059d58462c59b0fd75f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dabbd3f51646f95b0719bf82c69c38f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga9dabbd3f51646f95b0719bf82c69c38f">XMC_SPI_CH_MODE_t</a> { <br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga9dabbd3f51646f95b0719bf82c69c38fa7ed5131d8a7ba77370debe459420e79a">XMC_SPI_CH_MODE_STANDARD</a> = 0UL, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga9dabbd3f51646f95b0719bf82c69c38fa17c7eb1a23dd44233a32bc40e1d91d7b">XMC_SPI_CH_MODE_STANDARD_HALFDUPLEX</a> = 4UL, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga9dabbd3f51646f95b0719bf82c69c38fa4c0d92f4303e350e8f221bd870ea5855">XMC_SPI_CH_MODE_DUAL</a> = 6UL, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga9dabbd3f51646f95b0719bf82c69c38fa3e0c7cf3a25d8091075bafaac56109b2">XMC_SPI_CH_MODE_QUAD</a> = 7UL
<br />
 }</td></tr>
<tr class="separator:ga9dabbd3f51646f95b0719bf82c69c38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01a43390cf6218a5f16976f0b6027096"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga01a43390cf6218a5f16976f0b6027096">XMC_SPI_CH_SLAVE_SEL_MSLS_INV_t</a> { <br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga01a43390cf6218a5f16976f0b6027096a2d4df93fa0c9ae9bb7bc2050372d4150">XMC_SPI_CH_SLAVE_SEL_SAME_AS_MSLS</a> = 0x0UL, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga01a43390cf6218a5f16976f0b6027096aa7c8920fcfd744c9236533eba2e87391">XMC_SPI_CH_SLAVE_SEL_INV_TO_MSLS</a> = 0x1UL &lt;&lt; USIC_CH_PCR_SSCMode_SELINV_Pos
<br />
 }</td></tr>
<tr class="separator:ga01a43390cf6218a5f16976f0b6027096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga770391e79549c7df020fdd0f3864a808"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga770391e79549c7df020fdd0f3864a808">XMC_SPI_CH_SLAVE_SELECT_t</a> { <br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga770391e79549c7df020fdd0f3864a808a00be0d2c599ae2957bd0fed44fb88855">XMC_SPI_CH_SLAVE_SELECT_0</a> = 1UL &lt;&lt; USIC_CH_PCR_SSCMode_SELO_Pos, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga770391e79549c7df020fdd0f3864a808a2690a4c89d59b73f382c5139ee3c7536">XMC_SPI_CH_SLAVE_SELECT_1</a> = 2UL &lt;&lt; USIC_CH_PCR_SSCMode_SELO_Pos, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga770391e79549c7df020fdd0f3864a808af0bcf851c8a1b519dbc76693489288df">XMC_SPI_CH_SLAVE_SELECT_2</a> = 4UL &lt;&lt; USIC_CH_PCR_SSCMode_SELO_Pos, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga770391e79549c7df020fdd0f3864a808a6db85b62c5780f013bab00d3cf3e01a3">XMC_SPI_CH_SLAVE_SELECT_3</a> = 8UL &lt;&lt; USIC_CH_PCR_SSCMode_SELO_Pos, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga770391e79549c7df020fdd0f3864a808a1c8340b08676a487e080a6f9af45a548">XMC_SPI_CH_SLAVE_SELECT_4</a> = 16UL &lt;&lt; USIC_CH_PCR_SSCMode_SELO_Pos, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga770391e79549c7df020fdd0f3864a808a53320f8b59200bf61ced7b50266e11f4">XMC_SPI_CH_SLAVE_SELECT_5</a> = 32UL &lt;&lt; USIC_CH_PCR_SSCMode_SELO_Pos, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga770391e79549c7df020fdd0f3864a808a9c659e80688ec34014de2a9bcbb2a879">XMC_SPI_CH_SLAVE_SELECT_6</a> = 64UL &lt;&lt; USIC_CH_PCR_SSCMode_SELO_Pos, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga770391e79549c7df020fdd0f3864a808a13b1ba1e6096ae777c0e0bd6428ba4fa">XMC_SPI_CH_SLAVE_SELECT_7</a> = 128UL &lt;&lt; USIC_CH_PCR_SSCMode_SELO_Pos
<br />
 }</td></tr>
<tr class="separator:ga770391e79549c7df020fdd0f3864a808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c2761994b910b3e09b6373448a90762"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga7c2761994b910b3e09b6373448a90762">XMC_SPI_CH_STATUS_FLAG_t</a> { <br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga7c2761994b910b3e09b6373448a90762a8eca08cb355c692a598c0dae8c8dc9f1">XMC_SPI_CH_STATUS_FLAG_MSLS</a> = USIC_CH_PSR_SSCMode_MSLS_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga7c2761994b910b3e09b6373448a90762a2a5bf5f0e3d29181560104b7d1ede1ad">XMC_SPI_CH_STATUS_FLAG_DX2S</a> = USIC_CH_PSR_SSCMode_DX2S_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga7c2761994b910b3e09b6373448a90762aa64256e3a419a6e5e78af40b13b06c07">XMC_SPI_CH_STATUS_FLAG_MSLS_EVENT_DETECTED</a> = USIC_CH_PSR_SSCMode_MSLSEV_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga7c2761994b910b3e09b6373448a90762a6f535a37e10de454228ad80aa61186be">XMC_SPI_CH_STATUS_FLAG_DX2T_EVENT_DETECTED</a> = USIC_CH_PSR_SSCMode_DX2TEV_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga7c2761994b910b3e09b6373448a90762a5f02c5c437155e4305b61e31e858767f">XMC_SPI_CH_STATUS_FLAG_PARITY_ERROR_EVENT_DETECTED</a> = USIC_CH_PSR_SSCMode_PARERR_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga7c2761994b910b3e09b6373448a90762aebb0f539334bf93e7956a471bfbd13af">XMC_SPI_CH_STATUS_FLAG_RECEIVER_START_INDICATION</a> = USIC_CH_PSR_SSCMode_RSIF_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga7c2761994b910b3e09b6373448a90762a08c7ad534bb131f741d313d7ea28cbe3">XMC_SPI_CH_STATUS_FLAG_DATA_LOST_INDICATION</a> = USIC_CH_PSR_SSCMode_DLIF_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga7c2761994b910b3e09b6373448a90762af609b97f1e6ea2c118c0b4d3682090d0">XMC_SPI_CH_STATUS_FLAG_TRANSMIT_SHIFT_INDICATION</a> = USIC_CH_PSR_SSCMode_TSIF_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga7c2761994b910b3e09b6373448a90762a7054d7d1cc298711c1dd27b6ddc5c2f5">XMC_SPI_CH_STATUS_FLAG_TRANSMIT_BUFFER_INDICATION</a> = USIC_CH_PSR_SSCMode_TBIF_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga7c2761994b910b3e09b6373448a90762aebbab80c5922351320b1e1948633c27a">XMC_SPI_CH_STATUS_FLAG_RECEIVE_INDICATION</a> = USIC_CH_PSR_SSCMode_RIF_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga7c2761994b910b3e09b6373448a90762a1d9c5c5eb3ac18540acb5c58fb8b126a">XMC_SPI_CH_STATUS_FLAG_ALTERNATIVE_RECEIVE_INDICATION</a> = USIC_CH_PSR_SSCMode_AIF_Msk, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga7c2761994b910b3e09b6373448a90762a8cece74a4527cac93aa69b958bb81309">XMC_SPI_CH_STATUS_FLAG_BAUD_RATE_GENERATOR_INDICATION</a> = USIC_CH_PSR_SSCMode_BRGIF_Msk
<br />
 }</td></tr>
<tr class="separator:ga7c2761994b910b3e09b6373448a90762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f497bc1a5457fddd4f5e57f30c3531d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga3f497bc1a5457fddd4f5e57f30c3531d">XMC_SPI_CH_STATUS_t</a> { <br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga3f497bc1a5457fddd4f5e57f30c3531dad6241ca094413611b4054d3222e58339">XMC_SPI_CH_STATUS_OK</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga3f497bc1a5457fddd4f5e57f30c3531da9d3531bfa6a78a7e74c58be3decf9440">XMC_SPI_CH_STATUS_ERROR</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_p_i.html#gga3f497bc1a5457fddd4f5e57f30c3531dac122b8021103d9d5807eaa51bb63b876">XMC_SPI_CH_STATUS_BUSY</a>
<br />
 }</td></tr>
<tr class="separator:ga3f497bc1a5457fddd4f5e57f30c3531d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2a54f046194eee8c765c8c4ff4af73ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga2a54f046194eee8c765c8c4ff4af73ed">XMC_SPI_CH_ClearStatusFlag</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint32_t flag)</td></tr>
<tr class="separator:ga2a54f046194eee8c765c8c4ff4af73ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadaf15fe97c6fc0b78ac661e923521ee3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gadaf15fe97c6fc0b78ac661e923521ee3">XMC_SPI_CH_ConfigureShiftClockOutput</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___s_p_i.html#gad62a419e5f01dc507f3f731995873fe4">XMC_SPI_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_t</a> passive_level, const <a class="el" href="group___s_p_i.html#gaf703b28cb6fe62eec40258bbb4b2381e">XMC_SPI_CH_BRG_SHIFT_CLOCK_OUTPUT_t</a> clock_output)</td></tr>
<tr class="separator:gadaf15fe97c6fc0b78ac661e923521ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb24e63f6664b519405dd75ca9d856fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gaeb24e63f6664b519405dd75ca9d856fc">XMC_SPI_CH_DisableEOF</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:gaeb24e63f6664b519405dd75ca9d856fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f3bb2759c5dc83f4df9674bc7521dfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga8f3bb2759c5dc83f4df9674bc7521dfa">XMC_SPI_CH_DisableEvent</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint32_t event)</td></tr>
<tr class="separator:ga8f3bb2759c5dc83f4df9674bc7521dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76bad04e2d660078ce675baa6320f1b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga76bad04e2d660078ce675baa6320f1b7">XMC_SPI_CH_DisableFEM</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga76bad04e2d660078ce675baa6320f1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf00d5c823846ca5c13f627baa541663"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gadf00d5c823846ca5c13f627baa541663">XMC_SPI_CH_DisableInputInversion</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___s_p_i.html#ga5e1e7ef1aea059d58462c59b0fd75f8f">XMC_SPI_CH_INPUT_t</a> input)</td></tr>
<tr class="separator:gadf00d5c823846ca5c13f627baa541663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb85102d1ba6a3387e578819de6ccb9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gaeb85102d1ba6a3387e578819de6ccb9d">XMC_SPI_CH_DisableInterwordDelay</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:gaeb85102d1ba6a3387e578819de6ccb9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7bd8be53e17d3285fd8fc87ec2a50bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gac7bd8be53e17d3285fd8fc87ec2a50bd">XMC_SPI_CH_DisableMasterClock</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:gac7bd8be53e17d3285fd8fc87ec2a50bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b2480876aa7c3b1c9646156d015e398"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga5b2480876aa7c3b1c9646156d015e398">XMC_SPI_CH_DisableSlaveSelect</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga5b2480876aa7c3b1c9646156d015e398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0243074b234e51bebab42c98a194a63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gac0243074b234e51bebab42c98a194a63">XMC_SPI_CH_DisableSOF</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:gac0243074b234e51bebab42c98a194a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae37ff42efc15af1807458ff0a47053ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gae37ff42efc15af1807458ff0a47053ea">XMC_SPI_CH_EnableEOF</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:gae37ff42efc15af1807458ff0a47053ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91fef97e4d595f37fbfb60a4fd5624e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga91fef97e4d595f37fbfb60a4fd5624e4">XMC_SPI_CH_EnableEvent</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint32_t event)</td></tr>
<tr class="separator:ga91fef97e4d595f37fbfb60a4fd5624e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50f619649550b90af1adfecb924ce0df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga50f619649550b90af1adfecb924ce0df">XMC_SPI_CH_EnableFEM</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga50f619649550b90af1adfecb924ce0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68c629a48d4d82c08c1017a9c822deeb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga68c629a48d4d82c08c1017a9c822deeb">XMC_SPI_CH_EnableInputInversion</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___s_p_i.html#ga5e1e7ef1aea059d58462c59b0fd75f8f">XMC_SPI_CH_INPUT_t</a> input)</td></tr>
<tr class="separator:ga68c629a48d4d82c08c1017a9c822deeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7b042f05c42e05efd3ba52df303f1d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gad7b042f05c42e05efd3ba52df303f1d6">XMC_SPI_CH_EnableInterwordDelay</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:gad7b042f05c42e05efd3ba52df303f1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1bf70c8e262bdf3727e7bc2d21b578b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gaf1bf70c8e262bdf3727e7bc2d21b578b">XMC_SPI_CH_EnableMasterClock</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:gaf1bf70c8e262bdf3727e7bc2d21b578b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga065897e36db1bbcffe141ad992cea9ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga065897e36db1bbcffe141ad992cea9ce">XMC_SPI_CH_EnableSlaveSelect</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___s_p_i.html#ga770391e79549c7df020fdd0f3864a808">XMC_SPI_CH_SLAVE_SELECT_t</a> slave)</td></tr>
<tr class="separator:ga065897e36db1bbcffe141ad992cea9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad11bb01cc21d11bf8f7cfa0a1a2b8a46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gad11bb01cc21d11bf8f7cfa0a1a2b8a46">XMC_SPI_CH_EnableSOF</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:gad11bb01cc21d11bf8f7cfa0a1a2b8a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55ae75a9f812ee0ed92303074e990f97"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga55ae75a9f812ee0ed92303074e990f97">XMC_SPI_CH_GetReceivedData</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga55ae75a9f812ee0ed92303074e990f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16747654a19c5dcef00d7f7e61d14f48"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga16747654a19c5dcef00d7f7e61d14f48">XMC_SPI_CH_GetStatusFlag</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga16747654a19c5dcef00d7f7e61d14f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b16f43a349603e746885a6d0d00b312"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga8b16f43a349603e746885a6d0d00b312">XMC_SPI_CH_Init</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="struct_x_m_c___s_p_i___c_h___c_o_n_f_i_g__t.html">XMC_SPI_CH_CONFIG_t</a> *const config)</td></tr>
<tr class="separator:ga8b16f43a349603e746885a6d0d00b312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae797c93243d5ab6ad7c5b1de311d6a3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gae797c93243d5ab6ad7c5b1de311d6a3c">XMC_SPI_CH_Receive</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___s_p_i.html#ga9dabbd3f51646f95b0719bf82c69c38f">XMC_SPI_CH_MODE_t</a> mode)</td></tr>
<tr class="separator:gae797c93243d5ab6ad7c5b1de311d6a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41fd386bd95f41b0274c4fd162b1a539"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___s_p_i.html#ga3f497bc1a5457fddd4f5e57f30c3531d">XMC_SPI_CH_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga41fd386bd95f41b0274c4fd162b1a539">XMC_SPI_CH_SetBaudrate</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint32_t rate)</td></tr>
<tr class="separator:ga41fd386bd95f41b0274c4fd162b1a539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72ca69c5bc68803067ff496538ff5f02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga72ca69c5bc68803067ff496538ff5f02">XMC_SPI_CH_SetBitOrderLsbFirst</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga72ca69c5bc68803067ff496538ff5f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f4bbed2c9583c7a454951c83acbe646"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga8f4bbed2c9583c7a454951c83acbe646">XMC_SPI_CH_SetBitOrderMsbFirst</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga8f4bbed2c9583c7a454951c83acbe646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedb545863be3b85d6b2ec51503926432"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gaedb545863be3b85d6b2ec51503926432">XMC_SPI_CH_SetFrameLength</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint8_t frame_length)</td></tr>
<tr class="separator:gaedb545863be3b85d6b2ec51503926432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5800f69155c1ecadedf587fd567e2b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#gab5800f69155c1ecadedf587fd567e2b3">XMC_SPI_CH_SetInputSource</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___s_p_i.html#ga5e1e7ef1aea059d58462c59b0fd75f8f">XMC_SPI_CH_INPUT_t</a> input, const uint8_t source)</td></tr>
<tr class="separator:gab5800f69155c1ecadedf587fd567e2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14b1f10c37e326b76cd214f7c006add2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga14b1f10c37e326b76cd214f7c006add2">XMC_SPI_CH_SetInterruptNodePointer</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint8_t service_request)</td></tr>
<tr class="separator:ga14b1f10c37e326b76cd214f7c006add2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3902d15aaff83cbce1d0d9b252183ef5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga3902d15aaff83cbce1d0d9b252183ef5">XMC_SPI_CH_SetInterwordDelay</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, uint32_t tinterword_delay_ns)</td></tr>
<tr class="separator:ga3902d15aaff83cbce1d0d9b252183ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c327beee42bdb3d24865f1bc19376d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga6c327beee42bdb3d24865f1bc19376d8">XMC_SPI_CH_SetSlaveSelectPolarity</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___s_p_i.html#ga01a43390cf6218a5f16976f0b6027096">XMC_SPI_CH_SLAVE_SEL_MSLS_INV_t</a> selo_inversion)</td></tr>
<tr class="separator:ga6c327beee42bdb3d24865f1bc19376d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga874157094bd9b28c5a5493eee577df72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga874157094bd9b28c5a5493eee577df72">XMC_SPI_CH_SetWordLength</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint8_t word_length)</td></tr>
<tr class="separator:ga874157094bd9b28c5a5493eee577df72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e3869696f61ef196fd2ea66a667bb0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga4e3869696f61ef196fd2ea66a667bb0e">XMC_SPI_CH_Start</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga4e3869696f61ef196fd2ea66a667bb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fd532dae41a2b9d754aa3de0f412a8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___s_p_i.html#ga3f497bc1a5457fddd4f5e57f30c3531d">XMC_SPI_CH_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga7fd532dae41a2b9d754aa3de0f412a8d">XMC_SPI_CH_Stop</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga7fd532dae41a2b9d754aa3de0f412a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga273573d7d388e93ff9018ff87abe9dc0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga273573d7d388e93ff9018ff87abe9dc0">XMC_SPI_CH_Transmit</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint16_t data, const <a class="el" href="group___s_p_i.html#ga9dabbd3f51646f95b0719bf82c69c38f">XMC_SPI_CH_MODE_t</a> mode)</td></tr>
<tr class="separator:ga273573d7d388e93ff9018ff87abe9dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64bac76e587d62fe0089b813397eb8ec"><td class="memItemLeft" align="right" valign="top">XMC_DRIVER_VERSION_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i.html#ga64bac76e587d62fe0089b813397eb8ec">XMC_SPI_GetDriverVersion</a> (void)</td></tr>
<tr class="separator:ga64bac76e587d62fe0089b813397eb8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The SPI driver uses Universal Serial Interface Channel(USIC) module. The USIC module supports multiple data lines for SPI communication. <br />
</p><ol type="1">
<li>Full duplex communication with 2 separate lines for transmission and reception.</li>
<li>Half duplex communication with 1 common line shared for transmission and reception.</li>
<li>Dual mode communication with 2 common lines shared for transmission and reception.</li>
<li>Quad mode communication with 4 common lines shared for transmission and reception.<br />
<br />
</li>
</ol>
<p>SPI driver provides structures, enumerations and APIs for configuring the USIC channel for SPI communication and also for data transaction.<br />
 SPI driver features:</p><ol type="1">
<li>Configuration structure <a class="el" href="struct_x_m_c___s_p_i___c_h___c_o_n_f_i_g__t.html">XMC_SPI_CH_CONFIG_t</a> and SPI initialization function <a class="el" href="group___s_p_i.html#ga8b16f43a349603e746885a6d0d00b312">XMC_SPI_CH_Init()</a></li>
<li>Allows configuration of protocol word and frame length using <a class="el" href="group___s_p_i.html#ga874157094bd9b28c5a5493eee577df72">XMC_SPI_CH_SetWordLength()</a>, <a class="el" href="group___s_p_i.html#gaedb545863be3b85d6b2ec51503926432">XMC_SPI_CH_SetFrameLength()</a></li>
<li>Allows manipulation of data frame at runtime using <a class="el" href="group___s_p_i.html#gad11bb01cc21d11bf8f7cfa0a1a2b8a46">XMC_SPI_CH_EnableSOF()</a>, <a class="el" href="group___s_p_i.html#gae37ff42efc15af1807458ff0a47053ea">XMC_SPI_CH_EnableEOF()</a>, <a class="el" href="group___s_p_i.html#ga065897e36db1bbcffe141ad992cea9ce">XMC_SPI_CH_EnableSlaveSelect()</a>, <a class="el" href="group___s_p_i.html#ga5b2480876aa7c3b1c9646156d015e398">XMC_SPI_CH_DisableSlaveSelect()</a></li>
<li>Provides APIs for transmitting data and receiving data using <a class="el" href="group___s_p_i.html#ga273573d7d388e93ff9018ff87abe9dc0">XMC_SPI_CH_Transmit()</a>, <a class="el" href="group___s_p_i.html#gae797c93243d5ab6ad7c5b1de311d6a3c">XMC_SPI_CH_Receive()</a>, <a class="el" href="group___s_p_i.html#ga55ae75a9f812ee0ed92303074e990f97">XMC_SPI_CH_GetReceivedData()</a></li>
<li>Allows configuration of shift clock using <a class="el" href="group___s_p_i.html#gadaf15fe97c6fc0b78ac661e923521ee3">XMC_SPI_CH_ConfigureShiftClockOutput()</a></li>
<li>Provides enumeration of SPI protocol events using <a class="el" href="group___s_p_i.html#ga7c2761994b910b3e09b6373448a90762">XMC_SPI_CH_STATUS_FLAG_t</a> </li>
</ol>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gac1ec1ff1047497f1d39737dd5ea87680"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SPI_MAJOR_VERSION&#160;&#160;&#160;(1U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Major number of the driver version(&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;) e.g. 1.2.3. </p>

</div>
</div>
<a class="anchor" id="ga01802ee68b402e38cb4bcd7fe8ee3408"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SPI_MINOR_VERSION&#160;&#160;&#160;(0U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Minor number of the driver version(&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;) e.g. 1.2.3. </p>

</div>
</div>
<a class="anchor" id="gaf063056256428693d695a820eb13dc44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SPI_PATCH_VERSION&#160;&#160;&#160;(2U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Patch number of the driver version(&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;) e.g. 1.2.3. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gaf703b28cb6fe62eec40258bbb4b2381e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_p_i.html#gaf703b28cb6fe62eec40258bbb4b2381e">XMC_SPI_CH_BRG_SHIFT_CLOCK_OUTPUT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SPI Baudrate Generator shift clock output </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaf703b28cb6fe62eec40258bbb4b2381eae57defba0e28b37387753485a740acf2"></a>XMC_SPI_CH_BRG_SHIFT_CLOCK_OUTPUT_SCLK&#160;</td><td class="fielddoc">
<p>Baudrate Generator shift clock output: SCLK </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf703b28cb6fe62eec40258bbb4b2381eae8aea9225b3233a8cf60f426bb0368f8"></a>XMC_SPI_CH_BRG_SHIFT_CLOCK_OUTPUT_DX1&#160;</td><td class="fielddoc">
<p>Clock obtained as input from master: DX1 </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gad62a419e5f01dc507f3f731995873fe4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_p_i.html#gad62a419e5f01dc507f3f731995873fe4">XMC_SPI_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SPI Baudrate Generator shift clock passive level </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggad62a419e5f01dc507f3f731995873fe4a60da59e367df81e02204c193307c7543"></a>XMC_SPI_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_0_DELAY_DISABLED&#160;</td><td class="fielddoc">
<p>Passive clock level 0, delay disabled Passive clock level 1, delay disabled </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggad62a419e5f01dc507f3f731995873fe4adba7c97cc13e382c36fb79a927ba779d"></a>XMC_SPI_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_1_DELAY_DISABLED&#160;</td><td class="fielddoc">
<p>Passive clock level 0, delay enabled </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggad62a419e5f01dc507f3f731995873fe4a5d8efe2fd3be3cbb88685afcfc7f4e04"></a>XMC_SPI_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_0_DELAY_ENABLED&#160;</td><td class="fielddoc">
<p>Passive clock level 1, delay enabled </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gaaf40703e598cf0bd196246cc048dda10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_p_i.html#gaaf40703e598cf0bd196246cc048dda10">XMC_SPI_CH_BUS_MODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the SPI bus mode </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaaf40703e598cf0bd196246cc048dda10a6535e33ac253d974dbdade07b9bdc6d5"></a>XMC_SPI_CH_BUS_MODE_MASTER&#160;</td><td class="fielddoc">
<p>SPI Master </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaaf40703e598cf0bd196246cc048dda10a6ded2d0050c88da873e2cfc0167d3e54"></a>XMC_SPI_CH_BUS_MODE_SLAVE&#160;</td><td class="fielddoc">
<p>SPI Slave </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga3d2e9e07d36e47a2840855c7761f3d2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_p_i.html#ga3d2e9e07d36e47a2840855c7761f3d2f">XMC_SPI_CH_DATA_POLARITY_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the Polarity of the data inputs. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga3d2e9e07d36e47a2840855c7761f3d2fa07561a103212e36eb152fad4c6e0bc09"></a>XMC_SPI_CH_DATA_POLARITY_DIRECT&#160;</td><td class="fielddoc">
<p>The polarity of the data line is not inverted </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga3d2e9e07d36e47a2840855c7761f3d2fad4dced7ef4a2819a36fabb92a24a160b"></a>XMC_SPI_CH_DATA_POLARITY_INVERT&#160;</td><td class="fielddoc">
<p>The polarity of the data line is inverted </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga7cf84a07d3e3970c1b09369fcf3c12db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_p_i.html#ga7cf84a07d3e3970c1b09369fcf3c12db">XMC_SPI_CH_EVENT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines SPI specific events </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga7cf84a07d3e3970c1b09369fcf3c12dba4b9fc48875e84294585b5b62cd5faea3"></a>XMC_SPI_CH_EVENT_RECEIVE_START&#160;</td><td class="fielddoc">
<p>Receive start event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7cf84a07d3e3970c1b09369fcf3c12dba45328c5bfb41c4fa0d7fc47e51640c6d"></a>XMC_SPI_CH_EVENT_DATA_LOST&#160;</td><td class="fielddoc">
<p>Data lost event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7cf84a07d3e3970c1b09369fcf3c12dbadd8d1e2334f16528a036b045c0c9eefc"></a>XMC_SPI_CH_EVENT_TRANSMIT_SHIFT&#160;</td><td class="fielddoc">
<p>Transmit shift event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7cf84a07d3e3970c1b09369fcf3c12dbaf08fec199ecb9705918d10cdb24ed446"></a>XMC_SPI_CH_EVENT_TRANSMIT_BUFFER&#160;</td><td class="fielddoc">
<p>Transmit buffer event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7cf84a07d3e3970c1b09369fcf3c12dba0accbca5448646b799940028bd294fe8"></a>XMC_SPI_CH_EVENT_STANDARD_RECEIVE&#160;</td><td class="fielddoc">
<p>Receive event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7cf84a07d3e3970c1b09369fcf3c12dba1b751bd9beb2fcbcaaf6afd59ced9b94"></a>XMC_SPI_CH_EVENT_ALTERNATIVE_RECEIVE&#160;</td><td class="fielddoc">
<p>Alternate receive event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7cf84a07d3e3970c1b09369fcf3c12dba33d6fbed5535423f89e0413eb7f0ff34"></a>XMC_SPI_CH_EVENT_BAUD_RATE_GENERATOR&#160;</td><td class="fielddoc">
<p>Baudrate generator event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7cf84a07d3e3970c1b09369fcf3c12dbaeccd57639b56f8276d0cf3d4ff23285e"></a>XMC_SPI_CH_EVENT_PARITY_ERROR&#160;</td><td class="fielddoc">
<p>Parity error event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7cf84a07d3e3970c1b09369fcf3c12dba9957b6f9ec5e89ec4fe744ca9b85cb9a"></a>XMC_SPI_CH_EVENT_MSLS_CHANGE&#160;</td><td class="fielddoc">
<p>Master slave select(MSLS) output transition event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7cf84a07d3e3970c1b09369fcf3c12dbab0ccd895a632344bf17ad5003af08965"></a>XMC_SPI_CH_EVENT_DX2TIEN_ACTIVATED&#160;</td><td class="fielddoc">
<p>Slave select input signal transition event </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga52dd53cd4c107af8f6d72c6c6a011886"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_p_i.html#ga52dd53cd4c107af8f6d72c6c6a011886">XMC_SPI_CH_INPUT_FREQ_SLAVE_SELECT_DELAY_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines input frequency sources for slave select signal delay configuration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga52dd53cd4c107af8f6d72c6c6a011886a58b64a73bcb7179ea3154579254725c2"></a>XMC_SPI_CH_INPUT_FREQ_SLAVE_SELECT_DELAY_FPDIV&#160;</td><td class="fielddoc">
<p>Output of PDIV divider: FPDIV </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga52dd53cd4c107af8f6d72c6c6a011886aae8eded70ac9defd6fa10321482aecda"></a>XMC_SPI_CH_INPUT_FREQ_SLAVE_SELECT_DELAY_FPPP&#160;</td><td class="fielddoc">
<p>Peripheral clock: FPPP </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga52dd53cd4c107af8f6d72c6c6a011886a0c2051effe9ccca3dcd9f959874c4d36"></a>XMC_SPI_CH_INPUT_FREQ_SLAVE_SELECT_DELAY_FSCLK&#160;</td><td class="fielddoc">
<p>Shift clock: FSCLK </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga52dd53cd4c107af8f6d72c6c6a011886ad52df965918f9e56f530f872ed792d02"></a>XMC_SPI_CH_INPUT_FREQ_SLAVE_SELECT_DELAY_FMCLK&#160;</td><td class="fielddoc">
<p>Master clock: FMCLK </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga5e1e7ef1aea059d58462c59b0fd75f8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_p_i.html#ga5e1e7ef1aea059d58462c59b0fd75f8f">XMC_SPI_CH_INPUT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Define data and clock input stages </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga5e1e7ef1aea059d58462c59b0fd75f8fa3730321c216c06c0ae39693e68786d4c"></a>XMC_SPI_CH_INPUT_DIN0&#160;</td><td class="fielddoc">
<p>Data input stage 0 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga5e1e7ef1aea059d58462c59b0fd75f8fa5b0aed31501650341a5710a8db35b40a"></a>XMC_SPI_CH_INPUT_SLAVE_SCLKIN&#160;</td><td class="fielddoc">
<p>Clock input stage </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga5e1e7ef1aea059d58462c59b0fd75f8fa96fe102aaf89df811f501ca34f3967a0"></a>XMC_SPI_CH_INPUT_SLAVE_SELIN&#160;</td><td class="fielddoc">
<p>Slave select input stage </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga5e1e7ef1aea059d58462c59b0fd75f8fa32f593df13abbed01017df7ea1cd9b11"></a>XMC_SPI_CH_INPUT_DIN1&#160;</td><td class="fielddoc">
<p>Data input stage 1 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga5e1e7ef1aea059d58462c59b0fd75f8fad7d757c2e37f1d9678ee76c5ac58cd9b"></a>XMC_SPI_CH_INPUT_DIN2&#160;</td><td class="fielddoc">
<p>Data input stage 2 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga5e1e7ef1aea059d58462c59b0fd75f8fadce039080e9a2e2795af411defb8a17e"></a>XMC_SPI_CH_INPUT_DIN3&#160;</td><td class="fielddoc">
<p>Data input stage 3 </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga9dabbd3f51646f95b0719bf82c69c38f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_p_i.html#ga9dabbd3f51646f95b0719bf82c69c38f">XMC_SPI_CH_MODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Define SPI data transfer mode </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga9dabbd3f51646f95b0719bf82c69c38fa7ed5131d8a7ba77370debe459420e79a"></a>XMC_SPI_CH_MODE_STANDARD&#160;</td><td class="fielddoc">
<p>SPI standard full duplex mode </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga9dabbd3f51646f95b0719bf82c69c38fa17c7eb1a23dd44233a32bc40e1d91d7b"></a>XMC_SPI_CH_MODE_STANDARD_HALFDUPLEX&#160;</td><td class="fielddoc">
<p>SPI standard half duplex mode </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga9dabbd3f51646f95b0719bf82c69c38fa4c0d92f4303e350e8f221bd870ea5855"></a>XMC_SPI_CH_MODE_DUAL&#160;</td><td class="fielddoc">
<p>SPI half duplex mode with dual data lines </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga9dabbd3f51646f95b0719bf82c69c38fa3e0c7cf3a25d8091075bafaac56109b2"></a>XMC_SPI_CH_MODE_QUAD&#160;</td><td class="fielddoc">
<p>SPI half duplex mode with quad data lines </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga01a43390cf6218a5f16976f0b6027096"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_p_i.html#ga01a43390cf6218a5f16976f0b6027096">XMC_SPI_CH_SLAVE_SEL_MSLS_INV_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the Polarity of the slave select signals SELO[7:0] in relation to the master slave select signal MSLS. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga01a43390cf6218a5f16976f0b6027096a2d4df93fa0c9ae9bb7bc2050372d4150"></a>XMC_SPI_CH_SLAVE_SEL_SAME_AS_MSLS&#160;</td><td class="fielddoc">
<p>The SELO outputs have the same polarity as the MSLS signal (active high) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga01a43390cf6218a5f16976f0b6027096aa7c8920fcfd744c9236533eba2e87391"></a>XMC_SPI_CH_SLAVE_SEL_INV_TO_MSLS&#160;</td><td class="fielddoc">
<p>The SELO outputs have the inverted polarity to the MSLS signal (active low) </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga770391e79549c7df020fdd0f3864a808"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_p_i.html#ga770391e79549c7df020fdd0f3864a808">XMC_SPI_CH_SLAVE_SELECT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines Slave Select lines </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga770391e79549c7df020fdd0f3864a808a00be0d2c599ae2957bd0fed44fb88855"></a>XMC_SPI_CH_SLAVE_SELECT_0&#160;</td><td class="fielddoc">
<p>Slave Select line 0 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga770391e79549c7df020fdd0f3864a808a2690a4c89d59b73f382c5139ee3c7536"></a>XMC_SPI_CH_SLAVE_SELECT_1&#160;</td><td class="fielddoc">
<p>Slave Select line 1 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga770391e79549c7df020fdd0f3864a808af0bcf851c8a1b519dbc76693489288df"></a>XMC_SPI_CH_SLAVE_SELECT_2&#160;</td><td class="fielddoc">
<p>Slave Select line 2 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga770391e79549c7df020fdd0f3864a808a6db85b62c5780f013bab00d3cf3e01a3"></a>XMC_SPI_CH_SLAVE_SELECT_3&#160;</td><td class="fielddoc">
<p>Slave Select line 3 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga770391e79549c7df020fdd0f3864a808a1c8340b08676a487e080a6f9af45a548"></a>XMC_SPI_CH_SLAVE_SELECT_4&#160;</td><td class="fielddoc">
<p>Slave Select line 4 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga770391e79549c7df020fdd0f3864a808a53320f8b59200bf61ced7b50266e11f4"></a>XMC_SPI_CH_SLAVE_SELECT_5&#160;</td><td class="fielddoc">
<p>Slave Select line 5 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga770391e79549c7df020fdd0f3864a808a9c659e80688ec34014de2a9bcbb2a879"></a>XMC_SPI_CH_SLAVE_SELECT_6&#160;</td><td class="fielddoc">
<p>Slave Select line 6 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga770391e79549c7df020fdd0f3864a808a13b1ba1e6096ae777c0e0bd6428ba4fa"></a>XMC_SPI_CH_SLAVE_SELECT_7&#160;</td><td class="fielddoc">
<p>Slave Select line 7 </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga7c2761994b910b3e09b6373448a90762"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_p_i.html#ga7c2761994b910b3e09b6373448a90762">XMC_SPI_CH_STATUS_FLAG_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines SPI event status </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga7c2761994b910b3e09b6373448a90762a8eca08cb355c692a598c0dae8c8dc9f1"></a>XMC_SPI_CH_STATUS_FLAG_MSLS&#160;</td><td class="fielddoc">
<p>Status of Master slave select(MSLS) signal </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7c2761994b910b3e09b6373448a90762a2a5bf5f0e3d29181560104b7d1ede1ad"></a>XMC_SPI_CH_STATUS_FLAG_DX2S&#160;</td><td class="fielddoc">
<p>Status of slave select input(DX2) signal </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7c2761994b910b3e09b6373448a90762aa64256e3a419a6e5e78af40b13b06c07"></a>XMC_SPI_CH_STATUS_FLAG_MSLS_EVENT_DETECTED&#160;</td><td class="fielddoc">
<p>Status for master slave select output signal transition </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7c2761994b910b3e09b6373448a90762a6f535a37e10de454228ad80aa61186be"></a>XMC_SPI_CH_STATUS_FLAG_DX2T_EVENT_DETECTED&#160;</td><td class="fielddoc">
<p>Status for slave select input signal transition </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7c2761994b910b3e09b6373448a90762a5f02c5c437155e4305b61e31e858767f"></a>XMC_SPI_CH_STATUS_FLAG_PARITY_ERROR_EVENT_DETECTED&#160;</td><td class="fielddoc">
<p>Indicates status of the parity error </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7c2761994b910b3e09b6373448a90762aebb0f539334bf93e7956a471bfbd13af"></a>XMC_SPI_CH_STATUS_FLAG_RECEIVER_START_INDICATION&#160;</td><td class="fielddoc">
<p>Status for receive start event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7c2761994b910b3e09b6373448a90762a08c7ad534bb131f741d313d7ea28cbe3"></a>XMC_SPI_CH_STATUS_FLAG_DATA_LOST_INDICATION&#160;</td><td class="fielddoc">
<p>Status for data lost event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7c2761994b910b3e09b6373448a90762af609b97f1e6ea2c118c0b4d3682090d0"></a>XMC_SPI_CH_STATUS_FLAG_TRANSMIT_SHIFT_INDICATION&#160;</td><td class="fielddoc">
<p>Status for transmit shift event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7c2761994b910b3e09b6373448a90762a7054d7d1cc298711c1dd27b6ddc5c2f5"></a>XMC_SPI_CH_STATUS_FLAG_TRANSMIT_BUFFER_INDICATION&#160;</td><td class="fielddoc">
<p>Status for transmit buffer event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7c2761994b910b3e09b6373448a90762aebbab80c5922351320b1e1948633c27a"></a>XMC_SPI_CH_STATUS_FLAG_RECEIVE_INDICATION&#160;</td><td class="fielddoc">
<p>Status for receive event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7c2761994b910b3e09b6373448a90762a1d9c5c5eb3ac18540acb5c58fb8b126a"></a>XMC_SPI_CH_STATUS_FLAG_ALTERNATIVE_RECEIVE_INDICATION&#160;</td><td class="fielddoc">
<p>Status for alternative receive event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7c2761994b910b3e09b6373448a90762a8cece74a4527cac93aa69b958bb81309"></a>XMC_SPI_CH_STATUS_FLAG_BAUD_RATE_GENERATOR_INDICATION&#160;</td><td class="fielddoc">
<p>Status for baud rate generation error event </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga3f497bc1a5457fddd4f5e57f30c3531d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_p_i.html#ga3f497bc1a5457fddd4f5e57f30c3531d">XMC_SPI_CH_STATUS_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines return status of SPI driver APIs </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga3f497bc1a5457fddd4f5e57f30c3531dad6241ca094413611b4054d3222e58339"></a>XMC_SPI_CH_STATUS_OK&#160;</td><td class="fielddoc">
<p>Status of the Module: OK </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga3f497bc1a5457fddd4f5e57f30c3531da9d3531bfa6a78a7e74c58be3decf9440"></a>XMC_SPI_CH_STATUS_ERROR&#160;</td><td class="fielddoc">
<p>Status of the Module: ERROR </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga3f497bc1a5457fddd4f5e57f30c3531dac122b8021103d9d5807eaa51bb63b876"></a>XMC_SPI_CH_STATUS_BUSY&#160;</td><td class="fielddoc">
<p>The Module is busy </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga2a54f046194eee8c765c8c4ff4af73ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SPI_CH_ClearStatusFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">flag</td><td>Protocol event status to be cleared for detection of next occurence. Refer @ XMC_SPI_CH_STATUS_FLAG_t for valid values. <b>OR</b> combinations of these enum item can be used as input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Clears the events specified, by setting PSCR register.<br />
<br />
During communication the events occurred have to be cleared to detect their next occurence.<br />
e.g: During transmission Transmit buffer event occurs to indicating data word transfer has started. This event has to be cleared after transmission of each data word. Otherwise next event cannot be recognized.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_p_i.html#ga16747654a19c5dcef00d7f7e61d14f48">XMC_SPI_CH_GetStatusFlag()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gadaf15fe97c6fc0b78ac661e923521ee3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SPI_CH_ConfigureShiftClockOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___s_p_i.html#gad62a419e5f01dc507f3f731995873fe4">XMC_SPI_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_t</a>&#160;</td>
          <td class="paramname"><em>passive_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___s_p_i.html#gaf703b28cb6fe62eec40258bbb4b2381e">XMC_SPI_CH_BRG_SHIFT_CLOCK_OUTPUT_t</a>&#160;</td>
          <td class="paramname"><em>clock_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">passive_level</td><td>polarity and delay of the selected shift clock.<br />
 Refer <a class="el" href="group___s_p_i.html#gad62a419e5f01dc507f3f731995873fe4">XMC_SPI_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_t</a> for valid inputs. </td></tr>
    <tr><td class="paramname">clock_output</td><td>shift clock source.<br />
 Refer <a class="el" href="group___s_p_i.html#gaf703b28cb6fe62eec40258bbb4b2381e">XMC_SPI_CH_BRG_SHIFT_CLOCK_OUTPUT_t</a> for valid inputs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configures the shift clock source with the selected polarity and delay by setting BRG.SCLKOSEL and BRG.SCLKCFG.<br />
<br />
In Master mode operation, shift clock is generated by the internal baud rate generator. This SCLK is made available for external slave devices by SCLKOUT signal.<br />
In Slave mode, the signal is received from the external master. So the DX1(input) stage has to be connected to input.<br />
The shift clock output(SCLKOUT) signal polarity can be set relative to SCLK, with the delay of half the shift clock period. These settings are applicable only in master mode. </dd></dl>

<p>References <a class="el" href="group___u_s_i_c.html#gaba9a2e95af4e455dddd73f324577c876">XMC_USIC_CH_ConfigureShiftClockOutput()</a>.</p>

</div>
</div>
<a class="anchor" id="gaeb24e63f6664b519405dd75ca9d856fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SPI_CH_DisableEOF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Configure the handling of end of frame through hardware, by clearing TCSR.EOF bit.<br />
<br />
Typically this can be disabled, where the transmission control is done by the hardware.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_p_i.html#gae37ff42efc15af1807458ff0a47053ea">XMC_SPI_CH_EnableEOF()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8f3bb2759c5dc83f4df9674bc7521dfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SPI_CH_DisableEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">event</td><td>Protocol events which have to be disabled. Refer @ XMC_SPI_CH_EVENT_t for valid values. <b>OR</b> combinations of these enum item can be used as input.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables the SPI protocol specific events, by configuring PCR register.<br />
<br />
After disabling the events, <a class="el" href="group___s_p_i.html#ga91fef97e4d595f37fbfb60a4fd5624e4">XMC_SPI_CH_EnableEvent()</a> has to be invoked to re-enable the events.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_p_i.html#ga91fef97e4d595f37fbfb60a4fd5624e4">XMC_SPI_CH_EnableEvent()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga76bad04e2d660078ce675baa6320f1b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SPI_CH_DisableFEM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configure to disable the MSLS(Slave select signal) if the current data frame is considered as finished, by setting PCR.FEM bit.<br />
<br />
 When the last bit of a data word has been sent out and the transmit buffer TBUF does not contain new data, is considered as frame is ended and MSLS(Slave select signal) is disabled.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_p_i.html#ga50f619649550b90af1adfecb924ce0df">XMC_SPI_CH_EnableFEM()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gadf00d5c823846ca5c13f627baa541663"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SPI_CH_DisableInputInversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___s_p_i.html#ga5e1e7ef1aea059d58462c59b0fd75f8f">XMC_SPI_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">input</td><td>SPI channel input stage.<br />
 Refer <a class="el" href="group___s_p_i.html#ga5e1e7ef1aea059d58462c59b0fd75f8f">XMC_SPI_CH_INPUT_t</a> for valid inputs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables the polarity inversion of input data signal, by clearing DXyCR.DPOL(where y = <em>input</em>).<br />
<br />
Resets the input data polarity. Invoke <a class="el" href="group___s_p_i.html#ga68c629a48d4d82c08c1017a9c822deeb">XMC_SPI_CH_EnableInputInversion()</a> to apply inversion.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_p_i.html#ga68c629a48d4d82c08c1017a9c822deeb">XMC_SPI_CH_EnableInputInversion()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaeb85102d1ba6a3387e578819de6ccb9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SPI_CH_DisableInterwordDelay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables the delay after after each word, by clearing PCR.TIWEN bit.<br />
<br />
So the last data bit of a data word is directly followed by the first data bit of the next data word. If needed can be enabled by invoking <a class="el" href="group___s_p_i.html#gad7b042f05c42e05efd3ba52df303f1d6">XMC_SPI_CH_EnableInterwordDelay()</a>.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_p_i.html#gad7b042f05c42e05efd3ba52df303f1d6">XMC_SPI_CH_EnableInterwordDelay()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac7bd8be53e17d3285fd8fc87ec2a50bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SPI_CH_DisableMasterClock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables the generation of Master clock by clearing PCR.MCLK bit.<br />
<br />
This clock can be enabled by invoking <a class="el" href="group___s_p_i.html#gaf1bf70c8e262bdf3727e7bc2d21b578b">XMC_SPI_CH_EnableMasterClock()</a> as needed in the program.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_p_i.html#gaf1bf70c8e262bdf3727e7bc2d21b578b">XMC_SPI_CH_EnableMasterClock()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5b2480876aa7c3b1c9646156d015e398"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SPI_CH_DisableSlaveSelect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant ponter to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disable all the slave signals by clearing PCR.SELO bits.<br />
<br />
<a class="el" href="group___s_p_i.html#ga065897e36db1bbcffe141ad992cea9ce">XMC_SPI_CH_EnableSlaveSelect()</a> has to be invoked to start the communication with the desired slave again.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_p_i.html#ga065897e36db1bbcffe141ad992cea9ce">XMC_SPI_CH_EnableSlaveSelect()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac0243074b234e51bebab42c98a194a63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SPI_CH_DisableSOF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Set the control of the handling start of frame through hardware, by clearing TCSR.SOF bit.<br />
<br />
Typically this can be disabled, where the transmission control is done by the hardware.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_p_i.html#gad11bb01cc21d11bf8f7cfa0a1a2b8a46">XMC_SPI_CH_EnableSOF()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae37ff42efc15af1807458ff0a47053ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SPI_CH_EnableEOF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Configure the handling of end of frame through software, by setting TCSR.EOF bit.<br />
<br />
This can be used if the software handles the TBUF data without FIFO. If EOF is set, a valid content of the TBUF is considered as last word of a frame. After transfer of the last word, MSLS signal becomes inactive. For software handling of EOF bit, it is recommended to configure TCSR.WLEMD as 0. <br />
<b>Note:</b> The API should be called before putting the last data word of the frame to TBUF.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_p_i.html#gaeb24e63f6664b519405dd75ca9d856fc">XMC_SPI_CH_DisableEOF()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga91fef97e4d595f37fbfb60a4fd5624e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SPI_CH_EnableEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">event</td><td>Protocol events which have to be enabled. Refer @ XMC_SPI_CH_EVENT_t for valid values. <b>OR</b> combinations of these enum items can be used as input.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables the SPI protocol specific events, by configuring PCR register.<br />
<br />
Events can be enabled as needed using <a class="el" href="group___s_p_i.html#ga91fef97e4d595f37fbfb60a4fd5624e4">XMC_SPI_CH_EnableEvent()</a>. <a class="el" href="group___s_p_i.html#ga8f3bb2759c5dc83f4df9674bc7521dfa">XMC_SPI_CH_DisableEvent()</a> can be used to disable the events.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_p_i.html#ga8f3bb2759c5dc83f4df9674bc7521dfa">XMC_SPI_CH_DisableEvent()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga50f619649550b90af1adfecb924ce0df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SPI_CH_EnableFEM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd></dd></dl>
<p>Configure to keep MSLS(Slave select signal) active even after finishing the current data frame, by setting PCR.FEM bit.<br />
<br />
This is typically used during the transmission of multi-data word frames, where there is possibility of delay in delivering the data. Frame end mode is enabled in <a class="el" href="group___s_p_i.html#ga8b16f43a349603e746885a6d0d00b312">XMC_SPI_CH_Init()</a> during initialization. To disable <a class="el" href="group___s_p_i.html#ga76bad04e2d660078ce675baa6320f1b7">XMC_SPI_CH_DisableFEM()</a> can be invoked as needed in the program.</p>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_p_i.html#ga76bad04e2d660078ce675baa6320f1b7">XMC_SPI_CH_DisableFEM()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga68c629a48d4d82c08c1017a9c822deeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SPI_CH_EnableInputInversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___s_p_i.html#ga5e1e7ef1aea059d58462c59b0fd75f8f">XMC_SPI_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">input</td><td>SPI channel input stage.<br />
 Refer <a class="el" href="group___s_p_i.html#ga5e1e7ef1aea059d58462c59b0fd75f8f">XMC_SPI_CH_INPUT_t</a> for valid inputs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables the polarity inversion of input data signal, by setting DXyCR.DPOL(where y = <em>input</em>).<br />
<br />
This is not set in <a class="el" href="group___s_p_i.html#ga8b16f43a349603e746885a6d0d00b312">XMC_SPI_CH_Init()</a>. Invoke <a class="el" href="group___s_p_i.html#ga68c629a48d4d82c08c1017a9c822deeb">XMC_SPI_CH_EnableInputInversion()</a> as needed later in the program. To disable the inversion <a class="el" href="group___s_p_i.html#gadf00d5c823846ca5c13f627baa541663">XMC_SPI_CH_DisableInputInversion()</a> can be invoked.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_p_i.html#gadf00d5c823846ca5c13f627baa541663">XMC_SPI_CH_DisableInputInversion()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gad7b042f05c42e05efd3ba52df303f1d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SPI_CH_EnableInterwordDelay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables the delay after each word, by setting PCR.TIWEN bit.<br />
<br />
The inter word delay starts at the end of last SCLK cycle of data word. During this time no clock pulses are generated and MSLS signal stays active. If inter word delay is not enabled, last data bit of a data word is directly followed by the first data bit of the next data word. This is not enabled in <a class="el" href="group___s_p_i.html#ga8b16f43a349603e746885a6d0d00b312">XMC_SPI_CH_Init()</a>. To enable <a class="el" href="group___s_p_i.html#gad7b042f05c42e05efd3ba52df303f1d6">XMC_SPI_CH_EnableInterwordDelay()</a> has to be invoked as needed in the program. And can be disabled by invoking <a class="el" href="group___s_p_i.html#gaeb85102d1ba6a3387e578819de6ccb9d">XMC_SPI_CH_DisableInterwordDelay()</a>.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_p_i.html#gaeb85102d1ba6a3387e578819de6ccb9d">XMC_SPI_CH_DisableInterwordDelay()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf1bf70c8e262bdf3727e7bc2d21b578b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SPI_CH_EnableMasterClock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables the generation of Master clock by setting PCR.MCLK bit.<br />
<br />
This clock can be used as a clock reference for external devices. This is not enabled during initialization in <a class="el" href="group___s_p_i.html#ga8b16f43a349603e746885a6d0d00b312">XMC_SPI_CH_Init()</a>. Invoke <a class="el" href="group___s_p_i.html#gaf1bf70c8e262bdf3727e7bc2d21b578b">XMC_SPI_CH_EnableMasterClock()</a> to enable as needed in the program, or if it is disabled by <a class="el" href="group___s_p_i.html#gac7bd8be53e17d3285fd8fc87ec2a50bd">XMC_SPI_CH_DisableMasterClock()</a>.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_p_i.html#gac7bd8be53e17d3285fd8fc87ec2a50bd">XMC_SPI_CH_DisableMasterClock()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga065897e36db1bbcffe141ad992cea9ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SPI_CH_EnableSlaveSelect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___s_p_i.html#ga770391e79549c7df020fdd0f3864a808">XMC_SPI_CH_SLAVE_SELECT_t</a>&#160;</td>
          <td class="paramname"><em>slave</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">slave</td><td>Slave select signal.<br />
 Refer <a class="el" href="group___s_p_i.html#ga770391e79549c7df020fdd0f3864a808">XMC_SPI_CH_SLAVE_SELECT_t</a> for valid values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enable the selected slave signal by setting PCR.SELO bits.<br />
<br />
Each slave is connected with one slave select signal. This is not configured in <a class="el" href="group___s_p_i.html#ga8b16f43a349603e746885a6d0d00b312">XMC_SPI_CH_Init()</a>. Invoke <a class="el" href="group___s_p_i.html#ga065897e36db1bbcffe141ad992cea9ce">XMC_SPI_CH_EnableSlaveSelect()</a> with required <em>slave</em> to to start the communication. After finishing the communication <a class="el" href="group___s_p_i.html#ga5b2480876aa7c3b1c9646156d015e398">XMC_SPI_CH_DisableSlaveSelect()</a> can be invoked to disable the slaves.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_p_i.html#ga5b2480876aa7c3b1c9646156d015e398">XMC_SPI_CH_DisableSlaveSelect()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gad11bb01cc21d11bf8f7cfa0a1a2b8a46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SPI_CH_EnableSOF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Configure the handling of start of frame through software, by setting TCSR.SOF bit.<br />
<br />
This can be used if the software handles the TBUF data without FIFO. If SOF is set, a valid content of the TBUF is considered as first word of a new frame by finishing the currently running frame. For software handling of SOF bit, it is recommended to configure TCSR.WLEMD as 0. This is not configured during initialization. <a class="el" href="group___s_p_i.html#gad11bb01cc21d11bf8f7cfa0a1a2b8a46">XMC_SPI_CH_EnableSOF()</a> can be called as needed in the program and can be disabled by <a class="el" href="group___s_p_i.html#gac0243074b234e51bebab42c98a194a63">XMC_SPI_CH_DisableSOF()</a>.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_p_i.html#gac0243074b234e51bebab42c98a194a63">XMC_SPI_CH_DisableSOF()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga55ae75a9f812ee0ed92303074e990f97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t XMC_SPI_CH_GetReceivedData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint16_t Data read from the receive buffer.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Reads data from the receive buffer based on the FIFO selection.<br />
<br />
Invocation of <a class="el" href="group___s_p_i.html#gae797c93243d5ab6ad7c5b1de311d6a3c">XMC_SPI_CH_Receive()</a> receives the data and place it into receive buffer. After receiving the data <a class="el" href="group___s_p_i.html#ga55ae75a9f812ee0ed92303074e990f97">XMC_SPI_CH_GetReceivedData()</a> can be used to read the data from the buffer.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_p_i.html#gae797c93243d5ab6ad7c5b1de311d6a3c">XMC_SPI_CH_Receive()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga16747654a19c5dcef00d7f7e61d14f48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SPI_CH_GetStatusFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t Status of SPI protocol events.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Returns the status of the events, by reading PSR register.<br />
<br />
This indicates the status of the all the events, for SPI communication.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_p_i.html#ga2a54f046194eee8c765c8c4ff4af73ed">XMC_SPI_CH_ClearStatusFlag()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8b16f43a349603e746885a6d0d00b312"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SPI_CH_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___s_p_i___c_h___c_o_n_f_i_g__t.html">XMC_SPI_CH_CONFIG_t</a> *const&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">config</td><td>pointer to constant SPI channel configuration data structure.<br />
 Refer data structure <a class="el" href="struct_x_m_c___s_p_i___c_h___c_o_n_f_i_g__t.html">XMC_SPI_CH_CONFIG_t</a> for detail.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Initializes the selected SPI <em>channel</em> with the <em>config</em> structure.<br />
<br />
Enable SPI channel by calling <a class="el" href="group___u_s_i_c.html#ga0567321036170adb335fef9b36dc3b71">XMC_USIC_CH_Enable()</a> and then configures <ul>
<li>
Baudrate, </li>
<li>
Passive data level as active high, </li>
<li>
Shift control signal as active high, </li>
<li>
Frame length as 64U, </li>
<li>
Word length as 8U, </li>
<li>
Enable Hardware port control mode, </li>
<li>
Enable transmission of data TDV(Transmit data valid) bit is set to 1, </li>
<li>
Enable invalidation of data in TBUF once loaded into shift register, </li>
<li>
Parity mode settings </li>
</ul>
And if master mode is selected, <ul>
<li>
Enables MSLS signal generation, </li>
<li>
configures slave selection as normal mode, </li>
<li>
Set polarity for the Slave signal, </li>
<li>
Enable Frame end mode(MSLS signal is kept active after transmission of a frame) </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gae797c93243d5ab6ad7c5b1de311d6a3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SPI_CH_Receive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___s_p_i.html#ga9dabbd3f51646f95b0719bf82c69c38f">XMC_SPI_CH_MODE_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">mode</td><td>Communication mode of the SPI, based on this mode TCI(Transmit control information)is updated.<br />
 Refer <a class="el" href="group___s_p_i.html#ga9dabbd3f51646f95b0719bf82c69c38f">XMC_SPI_CH_MODE_t</a> for valid values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Transmits a dummy data(FFFFH) to provide clock for slave and receives the data from the slave.<br />
<br />
<a class="el" href="group___s_p_i.html#gae797c93243d5ab6ad7c5b1de311d6a3c">XMC_SPI_CH_Receive()</a> receives the data and places it into buffer based on the FIFO selection. After reception of data <a class="el" href="group___s_p_i.html#ga55ae75a9f812ee0ed92303074e990f97">XMC_SPI_CH_GetReceivedData()</a> can be invoked to read the data from the buffers.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>XMC_SPI_CH_GetReceivedDaa() </dd></dl>

</div>
</div>
<a class="anchor" id="ga41fd386bd95f41b0274c4fd162b1a539"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___s_p_i.html#ga3f497bc1a5457fddd4f5e57f30c3531d">XMC_SPI_CH_STATUS_t</a> XMC_SPI_CH_SetBaudrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>rate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">rate</td><td>Bus speed in bits per second</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XMC_SPI_CH_STATUS_t Status of the SPI driver after the request for setting baudrate is processed. <br />
 XMC_SPI_CH_STATUS_OK- If the baudrate is successfully changed. <br />
 XMC_SPI_CH_STATUS_ERROR- If the new baudrate value is out of range.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets the bus speed in bits per second</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_p_i.html#ga8b16f43a349603e746885a6d0d00b312">XMC_SPI_CH_Init()</a>, <a class="el" href="group___s_p_i.html#ga7fd532dae41a2b9d754aa3de0f412a8d">XMC_SPI_CH_Stop()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga72ca69c5bc68803067ff496538ff5f02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SPI_CH_SetBitOrderLsbFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Set the order of data transfer from LSB to MSB, by clearing SCTR.SDIR bit.<br />
<br />
This is typically based on the slave settings. Invoke <a class="el" href="group___s_p_i.html#ga72ca69c5bc68803067ff496538ff5f02">XMC_SPI_CH_SetBitOrderLsbFirst()</a> to set direction as needed in the program.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_p_i.html#ga8f4bbed2c9583c7a454951c83acbe646">XMC_SPI_CH_SetBitOrderMsbFirst()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8f4bbed2c9583c7a454951c83acbe646"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SPI_CH_SetBitOrderMsbFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Set the order of data transfer from MSB to LSB, by setting SCTR.SDIR bit.<br />
<br />
This is typically based on the slave settings. This is not set during <a class="el" href="group___s_p_i.html#ga8b16f43a349603e746885a6d0d00b312">XMC_SPI_CH_Init()</a>. Invoke <a class="el" href="group___s_p_i.html#ga8f4bbed2c9583c7a454951c83acbe646">XMC_SPI_CH_SetBitOrderMsbFirst()</a> to set direction as needed in the program.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_p_i.html#ga72ca69c5bc68803067ff496538ff5f02">XMC_SPI_CH_SetBitOrderLsbFirst()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaedb545863be3b85d6b2ec51503926432"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SPI_CH_SetFrameLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>frame_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">frame_length</td><td>Number of bits in a frame. <br />
 <b>Range:</b> 1 to 64. If the value 64 is configured, then the frame does not automatically end. User should explicitly end the frame.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Define the data frame length.<br />
<br />
Set the number of bits to be serially transmitted in a frame. The frame length should be multiples of word length. If the value is set to 64, the frame does not automatically end. Use <a class="el" href="group___s_p_i.html#ga5b2480876aa7c3b1c9646156d015e398">XMC_SPI_CH_DisableSlaveSelect()</a> to end the frame after all the data is transmitted.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#gabb9d02b8388a03cd28190c976cdb8b78">XMC_USIC_CH_SetWordLength()</a>, <a class="el" href="group___u_s_i_c.html#gaf1d2b03bb1350dfc628f0bfa9fb6ffb0">XMC_USIC_CH_EnableFrameLengthControl()</a>, <a class="el" href="group___s_p_i.html#ga5b2480876aa7c3b1c9646156d015e398">XMC_SPI_CH_DisableSlaveSelect()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab5800f69155c1ecadedf587fd567e2b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SPI_CH_SetInputSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___s_p_i.html#ga5e1e7ef1aea059d58462c59b0fd75f8f">XMC_SPI_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">input</td><td>SPI channel input stage.<br />
 Refer <a class="el" href="group___s_p_i.html#ga5e1e7ef1aea059d58462c59b0fd75f8f">XMC_SPI_CH_INPUT_t</a> for valid values </td></tr>
    <tr><td class="paramname">source</td><td>Input source select for the input stage. Range : [0 to 7]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Selects the data source for SPI input stage, by configuring DXCR.DSEL bits.<br />
<br />
Selects the input data signal source among DXnA, DXnB.. DXnG for the input stage. The API can be used for all the input stages like DX0CR, DX1CR etc. This is not done during initialization. This has to be configured before starting the SPI communication. </dd></dl>

<p>References <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a2572b0472db52f72c68f523f48c35620">XMC_USIC_CH_t::DXCR</a>, and <a class="el" href="group___u_s_i_c.html#ga7986fcfe3fd6bf9982e43b1eaabb02c2">XMC_USIC_CH_SetInputSource()</a>.</p>

</div>
</div>
<a class="anchor" id="ga14b1f10c37e326b76cd214f7c006add2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SPI_CH_SetInterruptNodePointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>service_request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">service_request</td><td>Service request number. Range: [0 to 5]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets the interrupt node for SPI channel events.<br />
<br />
For an event to generate interrupt, node pointer should be configured with service request(SR0, SR1..SR5). The NVIC node gets linked to the interrupt event by doing so. This is not configured in <a class="el" href="group___s_p_i.html#ga8b16f43a349603e746885a6d0d00b312">XMC_SPI_CH_Init()</a> during initialization.</dd></dl>
<dl class="section user"><dt>Note::</dt><dd><ol type="1">
<li>NVIC node should be separately enabled to generate the interrupt.</li>
</ol>
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga6f9467a0f290d65f7292b45cc29e32b4">XMC_USIC_CH_EnableEvent()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3902d15aaff83cbce1d0d9b252183ef5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SPI_CH_SetInterwordDelay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tinterword_delay_ns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">tinterword_delay_ns</td><td>delay in terms of nano seconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configures the inter word delay by setting PCR.PCTQ1, PCR.DCTQ1 bit fields.<br />
<br />
The inter word delay is dependent on the peripheral clock. The maximum possible value is calculated by using the below formula<br />
 Maximum inter word delay = ((1 + PCTQ1_max)(1 + DCTQ1_max)) / peripheral clock<br />
 where PCTQ1_max = 3 and DCTQ1_max = 31<br />
After configuring the inter word delay, this has to be enabled by invoking <a class="el" href="group___s_p_i.html#gad7b042f05c42e05efd3ba52df303f1d6">XMC_SPI_CH_EnableInterwordDelay()</a>.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_p_i.html#gad7b042f05c42e05efd3ba52df303f1d6">XMC_SPI_CH_EnableInterwordDelay()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga6c327beee42bdb3d24865f1bc19376d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SPI_CH_SetSlaveSelectPolarity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___s_p_i.html#ga01a43390cf6218a5f16976f0b6027096">XMC_SPI_CH_SLAVE_SEL_MSLS_INV_t</a>&#160;</td>
          <td class="paramname"><em>selo_inversion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">selo_inversion</td><td>Polarity of the slave select signal relative to the MSLS signal.<br />
 Refer <a class="el" href="group___s_p_i.html#ga01a43390cf6218a5f16976f0b6027096">XMC_SPI_CH_SLAVE_SEL_MSLS_INV_t</a> for valid values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Set the polarity of the slave select signal, by configuring PCR.SELINV bit.<br />
<br />
Normally MSLS signal is active low level signal. SO based on the slave inversion has to be applied. This is configured in <a class="el" href="group___s_p_i.html#ga8b16f43a349603e746885a6d0d00b312">XMC_SPI_CH_Init()</a> during initialization. Invoke <a class="el" href="group___s_p_i.html#ga6c327beee42bdb3d24865f1bc19376d8">XMC_SPI_CH_SetSlaveSelectPolarity()</a> with desired settings as needed later in the program. </dd></dl>

</div>
</div>
<a class="anchor" id="ga874157094bd9b28c5a5493eee577df72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SPI_CH_SetWordLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>word_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">word_length</td><td>Number of bits to be configured for a data word. <br />
 <b>Range:</b> 1 to 16.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Defines the data word length.<br />
<br />
Sets the number of bits to represent a data word. Frame length should be a multiple of word length.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_p_i.html#gaedb545863be3b85d6b2ec51503926432">XMC_SPI_CH_SetFrameLength()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4e3869696f61ef196fd2ea66a667bb0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SPI_CH_Start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Set the selected USIC channel to operate in SPI mode, by setting CCR.MODE bits.<br />
<br />
It should be executed after <a class="el" href="group___s_p_i.html#ga8b16f43a349603e746885a6d0d00b312">XMC_SPI_CH_Init()</a> during initialization. By invoking <a class="el" href="group___s_p_i.html#ga7fd532dae41a2b9d754aa3de0f412a8d">XMC_SPI_CH_Stop()</a>, the MODE is set to IDLE state. Call <a class="el" href="group___s_p_i.html#ga4e3869696f61ef196fd2ea66a667bb0e">XMC_SPI_CH_Start()</a> to set the SPI mode again, as needed later in the program.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_p_i.html#ga8b16f43a349603e746885a6d0d00b312">XMC_SPI_CH_Init()</a>, <a class="el" href="group___s_p_i.html#ga7fd532dae41a2b9d754aa3de0f412a8d">XMC_SPI_CH_Stop()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7fd532dae41a2b9d754aa3de0f412a8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___s_p_i.html#ga3f497bc1a5457fddd4f5e57f30c3531d">XMC_SPI_CH_STATUS_t</a> XMC_SPI_CH_Stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XMC_SPI_CH_STATUS_t Status of the SPI driver after the request for stopping is processed. <br />
 XMC_SPI_CH_STATUS_OK- If the USIC channel is successfully put to IDLE mode. <br />
 XMC_SPI_CH_STATUS_BUSY- If the USIC channel is busy transmitting data.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Set the selected SPI channel to IDLE mode, by clearing CCR.MODE bits.<br />
<br />
After calling XMC_SPI_CH_Stop, channel is IDLE mode. So no communication is supported. <a class="el" href="group___s_p_i.html#ga4e3869696f61ef196fd2ea66a667bb0e">XMC_SPI_CH_Start()</a> has to be invoked to start the communication again.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_p_i.html#ga4e3869696f61ef196fd2ea66a667bb0e">XMC_SPI_CH_Start()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga273573d7d388e93ff9018ff87abe9dc0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SPI_CH_Transmit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___s_p_i.html#ga9dabbd3f51646f95b0719bf82c69c38f">XMC_SPI_CH_MODE_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">data</td><td>Data to be transmitted </td></tr>
    <tr><td class="paramname">mode</td><td>Communication mode of the SPI, based on this mode TCI(Transmit control information)is updated.<br />
 Refer <a class="el" href="group___s_p_i.html#ga9dabbd3f51646f95b0719bf82c69c38f">XMC_SPI_CH_MODE_t</a> for valid values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Puts the data into FIFO, if FIFO mode is enabled or else into standard buffer, by setting the proper mode.<br />
<br />
In Dual and Quad modes, hardware port control(CCR.HPCEN) mode is enabled. By enabling this the direction of the data pin is updated by hardware itself. TCI(Transmit Control Information) allows dynamic control of both the data shift mode and pin direction during data transfers by writing to SCTR.DSM and SCTR.HPCDIR bit fields. To support this auto update, TCSR.HPCMD(Hardware Port control) will be enabled during the initialization using <a class="el" href="group___s_p_i.html#ga8b16f43a349603e746885a6d0d00b312">XMC_SPI_CH_Init()</a> for all modes.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_p_i.html#gae797c93243d5ab6ad7c5b1de311d6a3c">XMC_SPI_CH_Receive()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga64bac76e587d62fe0089b813397eb8ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XMC_DRIVER_VERSION_t XMC_SPI_GetDriverVersion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Data structure (::XMC_DRIVER_VERSION_t) storing driver version</dd></dl>
<dl class="section user"><dt>Description: </dt><dd>Return the version of the low level driver <br />
</dd></dl>
<dl class="section user"><dt></dt><dd>The function can be used to check application software compatibility with a specific version of the low level driver. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Feb 27 2015 10:51:56 for XMC Peripheral Library for XMC1000 Family by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
