<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>XMC Peripheral Library for XMC1000 Family: UART</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="IFX_LOGO_4C_medium.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">XMC Peripheral Library for XMC1000 Family
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">UART<div class="ingroups"><a class="el" href="group___x_m_clib.html">XMC Peripheral Library</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___u_a_r_t___c_h___c_o_n_f_i_g__t.html">XMC_UART_CH_CONFIG_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaa602c4cefc38468626d006e8f5476d7e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gaa602c4cefc38468626d006e8f5476d7e">XMC_UART_MAJOR_VERSION</a>&#160;&#160;&#160;(1U)</td></tr>
<tr class="separator:gaa602c4cefc38468626d006e8f5476d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga956a4c6ab560bcdaa9e9801a33a77fe4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga956a4c6ab560bcdaa9e9801a33a77fe4">XMC_UART_MINOR_VERSION</a>&#160;&#160;&#160;(0U)</td></tr>
<tr class="separator:ga956a4c6ab560bcdaa9e9801a33a77fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3aa13f2f22f9cb934d79bf3c7be06f7e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga3aa13f2f22f9cb934d79bf3c7be06f7e">XMC_UART_PATCH_VERSION</a>&#160;&#160;&#160;(2U)</td></tr>
<tr class="separator:ga3aa13f2f22f9cb934d79bf3c7be06f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga122d0cf7042ea6cb81ccdb50df5f62b6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga122d0cf7042ea6cb81ccdb50df5f62b6">XMC_UART_CH_EVENT_t</a> { <br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga122d0cf7042ea6cb81ccdb50df5f62b6addd2af8f6f565002a1b4ea856b7bbcee">XMC_UART_CH_EVENT_RECEIVE_START</a> = (int32_t)(0x80000000U | USIC_CH_CCR_RSIEN_Msk), 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga122d0cf7042ea6cb81ccdb50df5f62b6a6e76badf4b36a6fa694cd7c4c0d873b9">XMC_UART_CH_EVENT_DATA_LOST</a> = (int32_t)(0x80000000U | USIC_CH_CCR_DLIEN_Msk), 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga122d0cf7042ea6cb81ccdb50df5f62b6af28054e5044087c68da450015df6771f">XMC_UART_CH_EVENT_TRANSMIT_SHIFT</a> = (int32_t)(0x80000000U | USIC_CH_CCR_TSIEN_Msk), 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga122d0cf7042ea6cb81ccdb50df5f62b6a26b35a7f887b79474fa97856749f182b">XMC_UART_CH_EVENT_TRANSMIT_BUFFER</a> = (int32_t)(0x80000000U | USIC_CH_CCR_TBIEN_Msk), 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga122d0cf7042ea6cb81ccdb50df5f62b6a3fec2fc1685b8db717c095a21053240a">XMC_UART_CH_EVENT_STANDARD_RECEIVE</a> = (int32_t)(0x80000000U | USIC_CH_CCR_RIEN_Msk), 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga122d0cf7042ea6cb81ccdb50df5f62b6ad640d6bca0daeeb45ac4023b1e4db5b4">XMC_UART_CH_EVENT_ALTERNATIVE_RECEIVE</a> = (int32_t)(0x80000000U | USIC_CH_CCR_AIEN_Msk), 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga122d0cf7042ea6cb81ccdb50df5f62b6ac9364f8566efee358ffc0491940122e2">XMC_UART_CH_EVENT_BAUD_RATE_GENERATOR</a> = (int32_t)(0x80000000U | USIC_CH_CCR_BRGIEN_Msk), 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga122d0cf7042ea6cb81ccdb50df5f62b6a266352a130a03ea0a41565bc695ef146">XMC_UART_CH_EVENT_SYNCHRONIZATION_BREAK</a> = USIC_CH_PCR_ASCMode_SBIEN_Msk, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga122d0cf7042ea6cb81ccdb50df5f62b6acf263e5b91743a7e5d424d551a9f177b">XMC_UART_CH_EVENT_COLLISION</a> = USIC_CH_PCR_ASCMode_CDEN_Msk, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga122d0cf7042ea6cb81ccdb50df5f62b6a9045609949ae1b88827a4ec8fd005b93">XMC_UART_CH_EVENT_RECEIVER_NOISE</a> = USIC_CH_PCR_ASCMode_RNIEN_Msk, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga122d0cf7042ea6cb81ccdb50df5f62b6aef5d7acb2f77f77405a56b2c04fbaba5">XMC_UART_CH_EVENT_FORMAT_ERROR</a> = USIC_CH_PCR_ASCMode_FEIEN_Msk, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga122d0cf7042ea6cb81ccdb50df5f62b6a2ea7a5f9780633b9cb5702c1fc7296d2">XMC_UART_CH_EVENT_FRAME_FINISHED</a> = USIC_CH_PCR_ASCMode_FFIEN_Msk
<br />
 }</td></tr>
<tr class="separator:ga122d0cf7042ea6cb81ccdb50df5f62b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2deb0d11792f241e1e5c02e6a4063998"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga2deb0d11792f241e1e5c02e6a4063998">XMC_UART_CH_INPUT_SAMPLING_FREQ_t</a> { <br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga2deb0d11792f241e1e5c02e6a4063998a916e6151ac686996fbef2b0c059d0527">XMC_UART_CH_INPUT_SAMPLING_FREQ_FPERIPH</a> = XMC_USIC_CH_INPUT_SAMPLING_FREQ_FPERIPH, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga2deb0d11792f241e1e5c02e6a4063998ac1ae8f6ca1096c61ca0619dae0a18b92">XMC_UART_CH_INPUT_SAMPLING_FREQ_FRACTIONAL_DIVIDER</a> = XMC_USIC_CH_INPUT_SAMPLING_FREQ_FRACTIONAL_DIVIDER
<br />
 }</td></tr>
<tr class="separator:ga2deb0d11792f241e1e5c02e6a4063998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7358da2d90633473ae9de4636ddb3a46"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a> { <a class="el" href="group___u_a_r_t.html#gga7358da2d90633473ae9de4636ddb3a46acaf414b76fa9b98df96b90edbf3edc3d">XMC_UART_CH_INPUT_RXD</a> = 0UL
 }</td></tr>
<tr class="separator:ga7358da2d90633473ae9de4636ddb3a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga802a057f335dc7bc1465ae11b19d09af"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga802a057f335dc7bc1465ae11b19d09af">XMC_UART_CH_STATUS_FLAG_t</a> { <br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga802a057f335dc7bc1465ae11b19d09afa8838558f1c949dfdfa117908e21d7058">XMC_UART_CH_STATUS_FLAG_TRANSMISSION_IDLE</a> = USIC_CH_PSR_ASCMode_TXIDLE_Msk, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga802a057f335dc7bc1465ae11b19d09afa02d60fc761d9eee4c4d1c525f2429a5c">XMC_UART_CH_STATUS_FLAG_RECEPTION_IDLE</a> = USIC_CH_PSR_ASCMode_RXIDLE_Msk, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga802a057f335dc7bc1465ae11b19d09afaeaf9ee65696e36e06e012e0e3e5b5855">XMC_UART_CH_STATUS_FLAG_SYNCHRONIZATION_BREAK_DETECTED</a> = USIC_CH_PSR_ASCMode_SBD_Msk, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga802a057f335dc7bc1465ae11b19d09afa1127a4bc2e8bca81c351cdc344245fd0">XMC_UART_CH_STATUS_FLAG_COLLISION_DETECTED</a> = USIC_CH_PSR_ASCMode_COL_Msk, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga802a057f335dc7bc1465ae11b19d09afa147a2ad3b6ab6a1aacb07fa971eb1275">XMC_UART_CH_STATUS_FLAG_RECEIVER_NOISE_DETECTED</a> = USIC_CH_PSR_ASCMode_RNS_Msk, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga802a057f335dc7bc1465ae11b19d09afaf6d928be53c8c901a05872e3ef950bc7">XMC_UART_CH_STATUS_FLAG_FORMAT_ERROR_IN_STOP_BIT_0</a> = USIC_CH_PSR_ASCMode_FER0_Msk, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga802a057f335dc7bc1465ae11b19d09afa5733cca57c6cff9c79da3c824e644a72">XMC_UART_CH_STATUS_FLAG_FORMAT_ERROR_IN_STOP_BIT_1</a> = USIC_CH_PSR_ASCMode_FER1_Msk, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga802a057f335dc7bc1465ae11b19d09afa5abbfe2717ee3117550e329d90769863">XMC_UART_CH_STATUS_FLAG_RECEIVE_FRAME_FINISHED</a> = USIC_CH_PSR_ASCMode_RFF_Msk, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga802a057f335dc7bc1465ae11b19d09afae8fe75675b2f99f20032577dd0ca4f7c">XMC_UART_CH_STATUS_FLAG_TRANSMITTER_FRAME_FINISHED</a> = USIC_CH_PSR_ASCMode_TFF_Msk, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga802a057f335dc7bc1465ae11b19d09afa68079f24c35e5259c9984e39c602db45">XMC_UART_CH_STATUS_FLAG_TRANSFER_STATUS_BUSY</a> = USIC_CH_PSR_ASCMode_BUSY_Msk, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga802a057f335dc7bc1465ae11b19d09afa81b11006a6b243c9f04f4a8a9f5c5735">XMC_UART_CH_STATUS_FLAG_RECEIVER_START_INDICATION</a> = USIC_CH_PSR_ASCMode_RSIF_Msk, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga802a057f335dc7bc1465ae11b19d09afadcd6021f9d2ab0764ae114b544a1244a">XMC_UART_CH_STATUS_FLAG_DATA_LOST_INDICATION</a> = USIC_CH_PSR_ASCMode_DLIF_Msk, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga802a057f335dc7bc1465ae11b19d09afa4b78514f4ad98fead964ecf359c673ae">XMC_UART_CH_STATUS_FLAG_TRANSMIT_SHIFT_INDICATION</a> = USIC_CH_PSR_ASCMode_TSIF_Msk, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga802a057f335dc7bc1465ae11b19d09afaa8188ae95171fc9461c3c4905e41739b">XMC_UART_CH_STATUS_FLAG_TRANSMIT_BUFFER_INDICATION</a> = USIC_CH_PSR_ASCMode_TBIF_Msk, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga802a057f335dc7bc1465ae11b19d09afa47f5b38bcab2bc0e1b009cffcca18855">XMC_UART_CH_STATUS_FLAG_RECEIVE_INDICATION</a> = USIC_CH_PSR_ASCMode_RIF_Msk, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga802a057f335dc7bc1465ae11b19d09afaaac652362ebf22f1b23c1e2e4dd52cfa">XMC_UART_CH_STATUS_FLAG_ALTERNATIVE_RECEIVE_INDICATION</a> = USIC_CH_PSR_ASCMode_AIF_Msk, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#gga802a057f335dc7bc1465ae11b19d09afa5e66e98130f3a6f072c57295a1a779f7">XMC_UART_CH_STATUS_FLAG_BAUD_RATE_GENERATOR_INDICATION</a> = USIC_CH_PSR_ASCMode_BRGIF_Msk
<br />
 }</td></tr>
<tr class="separator:ga802a057f335dc7bc1465ae11b19d09af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd220ce3211af8111e0af876a0619788"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gadd220ce3211af8111e0af876a0619788">XMC_UART_CH_STATUS_t</a> { <br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#ggadd220ce3211af8111e0af876a0619788a1d4d4ea36dc6c0ceb6599efed42f0559">XMC_UART_CH_STATUS_OK</a>, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#ggadd220ce3211af8111e0af876a0619788a146ec14a2e6f316f449c332a863289b0">XMC_UART_CH_STATUS_ERROR</a>, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t.html#ggadd220ce3211af8111e0af876a0619788a410817c31e098fd03c04f4d5ecb76ef1">XMC_UART_CH_STATUS_BUSY</a>
<br />
 }</td></tr>
<tr class="separator:gadd220ce3211af8111e0af876a0619788"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6840ff2cfd59836fea619b9c1cfbbac5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga6840ff2cfd59836fea619b9c1cfbbac5">XMC_UART_CH_ClearStatusFlag</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint32_t flag)</td></tr>
<tr class="separator:ga6840ff2cfd59836fea619b9c1cfbbac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87743034df2fe747615ce39a6b870a0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga87743034df2fe747615ce39a6b870a0c">XMC_UART_CH_DisableEvent</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint32_t event)</td></tr>
<tr class="separator:ga87743034df2fe747615ce39a6b870a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef225ec3a0bc7db11ddf0b4f260a905c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gaef225ec3a0bc7db11ddf0b4f260a905c">XMC_UART_CH_DisableInputDigitalFilter</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a> input)</td></tr>
<tr class="separator:gaef225ec3a0bc7db11ddf0b4f260a905c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd566960d84740ec0c0713197839b071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gafd566960d84740ec0c0713197839b071">XMC_UART_CH_DisableInputInversion</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a> input)</td></tr>
<tr class="separator:gafd566960d84740ec0c0713197839b071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga655549975b9c7dce3fb9f28c89b5685f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga655549975b9c7dce3fb9f28c89b5685f">XMC_UART_CH_DisableInputSync</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a> input)</td></tr>
<tr class="separator:ga655549975b9c7dce3fb9f28c89b5685f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf511dd60e7f23bc40bad0207ff9bd266"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gaf511dd60e7f23bc40bad0207ff9bd266">XMC_UART_CH_EnableEvent</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint32_t event)</td></tr>
<tr class="separator:gaf511dd60e7f23bc40bad0207ff9bd266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeec73a4f59460bbe97aad10c1d925c73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gaeec73a4f59460bbe97aad10c1d925c73">XMC_UART_CH_EnableInputDigitalFilter</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a> input)</td></tr>
<tr class="separator:gaeec73a4f59460bbe97aad10c1d925c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95acf430dde4497f55838626ec22b808"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga95acf430dde4497f55838626ec22b808">XMC_UART_CH_EnableInputInversion</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a> input)</td></tr>
<tr class="separator:ga95acf430dde4497f55838626ec22b808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52aa3807f291f58be66b4d946aec7d47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga52aa3807f291f58be66b4d946aec7d47">XMC_UART_CH_EnableInputSync</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a> input)</td></tr>
<tr class="separator:ga52aa3807f291f58be66b4d946aec7d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga578c15fc0df2e8ea7a265c92c0a26536"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga578c15fc0df2e8ea7a265c92c0a26536">XMC_UART_CH_GetReceivedData</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga578c15fc0df2e8ea7a265c92c0a26536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5578bae41ea73c00dd704924c63f7370"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga5578bae41ea73c00dd704924c63f7370">XMC_UART_CH_GetStatusFlag</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga5578bae41ea73c00dd704924c63f7370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga719ad21f9ccaf9585dd0b473b4daef7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga719ad21f9ccaf9585dd0b473b4daef7e">XMC_UART_CH_Init</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="struct_x_m_c___u_a_r_t___c_h___c_o_n_f_i_g__t.html">XMC_UART_CH_CONFIG_t</a> *const config)</td></tr>
<tr class="separator:ga719ad21f9ccaf9585dd0b473b4daef7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f757d62a86fc8944cf7188137490b62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t.html#gadd220ce3211af8111e0af876a0619788">XMC_UART_CH_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga0f757d62a86fc8944cf7188137490b62">XMC_UART_CH_SetBaudrate</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, uint32_t rate, uint32_t oversampling)</td></tr>
<tr class="separator:ga0f757d62a86fc8944cf7188137490b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f6eb4a3265729b4b7cf7e3d198130d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga9f6eb4a3265729b4b7cf7e3d198130d6">XMC_UART_CH_SetFrameLength</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint8_t frame_length)</td></tr>
<tr class="separator:ga9f6eb4a3265729b4b7cf7e3d198130d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6c3cf150769886938ceb811557db243"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gad6c3cf150769886938ceb811557db243">XMC_UART_CH_SetInputSamplingFreq</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a> input, const <a class="el" href="group___u_a_r_t.html#ga2deb0d11792f241e1e5c02e6a4063998">XMC_UART_CH_INPUT_SAMPLING_FREQ_t</a> sampling_freq)</td></tr>
<tr class="separator:gad6c3cf150769886938ceb811557db243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f6aded563def78ca10e8638889bd898"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga1f6aded563def78ca10e8638889bd898">XMC_UART_CH_SetInputSource</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a> input, const uint8_t source)</td></tr>
<tr class="separator:ga1f6aded563def78ca10e8638889bd898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa013e09337b1c9c05b41eac29b2518ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gaa013e09337b1c9c05b41eac29b2518ea">XMC_UART_CH_SetInterruptNodePointer</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint8_t service_request)</td></tr>
<tr class="separator:gaa013e09337b1c9c05b41eac29b2518ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12f39dca3684261d4e35aeb7af9c82a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga12f39dca3684261d4e35aeb7af9c82a9">XMC_UART_CH_SetPulseLength</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint8_t pulse_length)</td></tr>
<tr class="separator:ga12f39dca3684261d4e35aeb7af9c82a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacabdceef217f1be937dc494ce9140765"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gacabdceef217f1be937dc494ce9140765">XMC_UART_CH_SetSamplePoint</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint32_t sample_point)</td></tr>
<tr class="separator:gacabdceef217f1be937dc494ce9140765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b12b3bdebda3d3a6c28d5c79a12735b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga6b12b3bdebda3d3a6c28d5c79a12735b">XMC_UART_CH_SetWordLength</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint8_t word_length)</td></tr>
<tr class="separator:ga6b12b3bdebda3d3a6c28d5c79a12735b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga786385b5527c6c6405d7e9e3626e0587"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga786385b5527c6c6405d7e9e3626e0587">XMC_UART_CH_Start</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga786385b5527c6c6405d7e9e3626e0587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga083e4d7b2be613994d61ebc9841f7ebd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t.html#gadd220ce3211af8111e0af876a0619788">XMC_UART_CH_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga083e4d7b2be613994d61ebc9841f7ebd">XMC_UART_CH_Stop</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga083e4d7b2be613994d61ebc9841f7ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a9b41f5d74a0dde43d9b19166ffa7c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga3a9b41f5d74a0dde43d9b19166ffa7c6">XMC_UART_CH_Transmit</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint16_t data)</td></tr>
<tr class="separator:ga3a9b41f5d74a0dde43d9b19166ffa7c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4aeec10dcd8e8115ac5d7ffee48f2c35"><td class="memItemLeft" align="right" valign="top">XMC_DRIVER_VERSION_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga4aeec10dcd8e8115ac5d7ffee48f2c35">XMC_UART_GetDriverVersion</a> (void)</td></tr>
<tr class="separator:ga4aeec10dcd8e8115ac5d7ffee48f2c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The UART driver uses Universal Serial Interface Channel(USIC) module to implement UART protocol. It provides APIs to configure USIC channel for UART communication. The driver enables the user in getting the status of UART protocol events, configuring interrupt service requests, protocol related parameter configuration etc.</p>
<p>UART driver features:</p><ol type="1">
<li>Configuration structure <a class="el" href="struct_x_m_c___u_a_r_t___c_h___c_o_n_f_i_g__t.html">XMC_UART_CH_CONFIG_t</a> and initialization function <a class="el" href="group___u_a_r_t.html#ga719ad21f9ccaf9585dd0b473b4daef7e">XMC_UART_CH_Init()</a></li>
<li>Enumeration of events with their bit masks <a class="el" href="group___u_a_r_t.html#ga122d0cf7042ea6cb81ccdb50df5f62b6">XMC_UART_CH_EVENT_t</a>, <a class="el" href="group___u_a_r_t.html#ga802a057f335dc7bc1465ae11b19d09af">XMC_UART_CH_STATUS_FLAG_t</a></li>
<li>Allows the selection of input source for the DX0 input stage using the API <a class="el" href="group___u_a_r_t.html#ga1f6aded563def78ca10e8638889bd898">XMC_UART_CH_SetInputSource()</a></li>
<li>Allows configuration of baudrate using <a class="el" href="group___u_a_r_t.html#ga0f757d62a86fc8944cf7188137490b62">XMC_UART_CH_SetBaudrate()</a> and configuration of data length using <a class="el" href="group___u_a_r_t.html#ga6b12b3bdebda3d3a6c28d5c79a12735b">XMC_UART_CH_SetWordLength()</a> and <a class="el" href="group___u_a_r_t.html#ga9f6eb4a3265729b4b7cf7e3d198130d6">XMC_UART_CH_SetFrameLength()</a></li>
<li>Provides the status of UART protocol events, <a class="el" href="group___u_a_r_t.html#ga5578bae41ea73c00dd704924c63f7370">XMC_UART_CH_GetStatusFlag()</a></li>
<li>Allows transmission of data using <a class="el" href="group___u_a_r_t.html#ga3a9b41f5d74a0dde43d9b19166ffa7c6">XMC_UART_CH_Transmit()</a> and gets received data using <a class="el" href="group___u_a_r_t.html#ga578c15fc0df2e8ea7a265c92c0a26536">XMC_UART_CH_GetReceivedData()</a> </li>
</ol>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gaa602c4cefc38468626d006e8f5476d7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_UART_MAJOR_VERSION&#160;&#160;&#160;(1U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Version number : Major version </p>

</div>
</div>
<a class="anchor" id="ga956a4c6ab560bcdaa9e9801a33a77fe4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_UART_MINOR_VERSION&#160;&#160;&#160;(0U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Version number : Minor version </p>

</div>
</div>
<a class="anchor" id="ga3aa13f2f22f9cb934d79bf3c7be06f7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_UART_PATCH_VERSION&#160;&#160;&#160;(2U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Version number : Patch version </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga122d0cf7042ea6cb81ccdb50df5f62b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t.html#ga122d0cf7042ea6cb81ccdb50df5f62b6">XMC_UART_CH_EVENT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UART configuration events. The enums can be used for configuring events using the CCR register. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga122d0cf7042ea6cb81ccdb50df5f62b6addd2af8f6f565002a1b4ea856b7bbcee"></a>XMC_UART_CH_EVENT_RECEIVE_START&#160;</td><td class="fielddoc">
<p>Receive start event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga122d0cf7042ea6cb81ccdb50df5f62b6a6e76badf4b36a6fa694cd7c4c0d873b9"></a>XMC_UART_CH_EVENT_DATA_LOST&#160;</td><td class="fielddoc">
<p>Data lost event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga122d0cf7042ea6cb81ccdb50df5f62b6af28054e5044087c68da450015df6771f"></a>XMC_UART_CH_EVENT_TRANSMIT_SHIFT&#160;</td><td class="fielddoc">
<p>Transmit shift event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga122d0cf7042ea6cb81ccdb50df5f62b6a26b35a7f887b79474fa97856749f182b"></a>XMC_UART_CH_EVENT_TRANSMIT_BUFFER&#160;</td><td class="fielddoc">
<p>Transmit buffer event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga122d0cf7042ea6cb81ccdb50df5f62b6a3fec2fc1685b8db717c095a21053240a"></a>XMC_UART_CH_EVENT_STANDARD_RECEIVE&#160;</td><td class="fielddoc">
<p>Receive event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga122d0cf7042ea6cb81ccdb50df5f62b6ad640d6bca0daeeb45ac4023b1e4db5b4"></a>XMC_UART_CH_EVENT_ALTERNATIVE_RECEIVE&#160;</td><td class="fielddoc">
<p>Alternate receive event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga122d0cf7042ea6cb81ccdb50df5f62b6ac9364f8566efee358ffc0491940122e2"></a>XMC_UART_CH_EVENT_BAUD_RATE_GENERATOR&#160;</td><td class="fielddoc">
<p>Baudrate generator event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga122d0cf7042ea6cb81ccdb50df5f62b6a266352a130a03ea0a41565bc695ef146"></a>XMC_UART_CH_EVENT_SYNCHRONIZATION_BREAK&#160;</td><td class="fielddoc">
<p>Event synchronization break </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga122d0cf7042ea6cb81ccdb50df5f62b6acf263e5b91743a7e5d424d551a9f177b"></a>XMC_UART_CH_EVENT_COLLISION&#160;</td><td class="fielddoc">
<p>Event collision </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga122d0cf7042ea6cb81ccdb50df5f62b6a9045609949ae1b88827a4ec8fd005b93"></a>XMC_UART_CH_EVENT_RECEIVER_NOISE&#160;</td><td class="fielddoc">
<p>Event receiver noise </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga122d0cf7042ea6cb81ccdb50df5f62b6aef5d7acb2f77f77405a56b2c04fbaba5"></a>XMC_UART_CH_EVENT_FORMAT_ERROR&#160;</td><td class="fielddoc">
<p>Event format error </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga122d0cf7042ea6cb81ccdb50df5f62b6a2ea7a5f9780633b9cb5702c1fc7296d2"></a>XMC_UART_CH_EVENT_FRAME_FINISHED&#160;</td><td class="fielddoc">
<p>Event frame finished </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga2deb0d11792f241e1e5c02e6a4063998"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t.html#ga2deb0d11792f241e1e5c02e6a4063998">XMC_UART_CH_INPUT_SAMPLING_FREQ_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UART Input sampling frequency options </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga2deb0d11792f241e1e5c02e6a4063998a916e6151ac686996fbef2b0c059d0527"></a>XMC_UART_CH_INPUT_SAMPLING_FREQ_FPERIPH&#160;</td><td class="fielddoc">
<p>Sampling frequency input fperiph </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga2deb0d11792f241e1e5c02e6a4063998ac1ae8f6ca1096c61ca0619dae0a18b92"></a>XMC_UART_CH_INPUT_SAMPLING_FREQ_FRACTIONAL_DIVIDER&#160;</td><td class="fielddoc">
<p>Sampling frequency input fractional divider </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga7358da2d90633473ae9de4636ddb3a46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UART input stages </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga7358da2d90633473ae9de4636ddb3a46acaf414b76fa9b98df96b90edbf3edc3d"></a>XMC_UART_CH_INPUT_RXD&#160;</td><td class="fielddoc">
<p>UART input stage DX0 </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga802a057f335dc7bc1465ae11b19d09af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t.html#ga802a057f335dc7bc1465ae11b19d09af">XMC_UART_CH_STATUS_FLAG_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UART portocol status. The enum values can be used for getting the status of UART channel. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga802a057f335dc7bc1465ae11b19d09afa8838558f1c949dfdfa117908e21d7058"></a>XMC_UART_CH_STATUS_FLAG_TRANSMISSION_IDLE&#160;</td><td class="fielddoc">
<p>UART Protocol Status transmit IDLE </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga802a057f335dc7bc1465ae11b19d09afa02d60fc761d9eee4c4d1c525f2429a5c"></a>XMC_UART_CH_STATUS_FLAG_RECEPTION_IDLE&#160;</td><td class="fielddoc">
<p>UART Protocol Status receive IDLE </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga802a057f335dc7bc1465ae11b19d09afaeaf9ee65696e36e06e012e0e3e5b5855"></a>XMC_UART_CH_STATUS_FLAG_SYNCHRONIZATION_BREAK_DETECTED&#160;</td><td class="fielddoc">
<p>UART Protocol Status synchronization break detected </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga802a057f335dc7bc1465ae11b19d09afa1127a4bc2e8bca81c351cdc344245fd0"></a>XMC_UART_CH_STATUS_FLAG_COLLISION_DETECTED&#160;</td><td class="fielddoc">
<p>UART Protocol Status collision detected </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga802a057f335dc7bc1465ae11b19d09afa147a2ad3b6ab6a1aacb07fa971eb1275"></a>XMC_UART_CH_STATUS_FLAG_RECEIVER_NOISE_DETECTED&#160;</td><td class="fielddoc">
<p>UART Protocol Status receiver noise detected </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga802a057f335dc7bc1465ae11b19d09afaf6d928be53c8c901a05872e3ef950bc7"></a>XMC_UART_CH_STATUS_FLAG_FORMAT_ERROR_IN_STOP_BIT_0&#160;</td><td class="fielddoc">
<p>UART Protocol Status format error in stop bit 0 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga802a057f335dc7bc1465ae11b19d09afa5733cca57c6cff9c79da3c824e644a72"></a>XMC_UART_CH_STATUS_FLAG_FORMAT_ERROR_IN_STOP_BIT_1&#160;</td><td class="fielddoc">
<p>UART Protocol Status format error in stop bit 1 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga802a057f335dc7bc1465ae11b19d09afa5abbfe2717ee3117550e329d90769863"></a>XMC_UART_CH_STATUS_FLAG_RECEIVE_FRAME_FINISHED&#160;</td><td class="fielddoc">
<p>UART Protocol Status receive frame finished </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga802a057f335dc7bc1465ae11b19d09afae8fe75675b2f99f20032577dd0ca4f7c"></a>XMC_UART_CH_STATUS_FLAG_TRANSMITTER_FRAME_FINISHED&#160;</td><td class="fielddoc">
<p>UART Protocol Status transmit frame finished </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga802a057f335dc7bc1465ae11b19d09afa68079f24c35e5259c9984e39c602db45"></a>XMC_UART_CH_STATUS_FLAG_TRANSFER_STATUS_BUSY&#160;</td><td class="fielddoc">
<p>UART Protocol Status transfer status busy </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga802a057f335dc7bc1465ae11b19d09afa81b11006a6b243c9f04f4a8a9f5c5735"></a>XMC_UART_CH_STATUS_FLAG_RECEIVER_START_INDICATION&#160;</td><td class="fielddoc">
<p>UART Protocol Status receive start indication flag </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga802a057f335dc7bc1465ae11b19d09afadcd6021f9d2ab0764ae114b544a1244a"></a>XMC_UART_CH_STATUS_FLAG_DATA_LOST_INDICATION&#160;</td><td class="fielddoc">
<p>UART Protocol Status data lost indication flag </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga802a057f335dc7bc1465ae11b19d09afa4b78514f4ad98fead964ecf359c673ae"></a>XMC_UART_CH_STATUS_FLAG_TRANSMIT_SHIFT_INDICATION&#160;</td><td class="fielddoc">
<p>UART Protocol Status transmit shift indication flag </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga802a057f335dc7bc1465ae11b19d09afaa8188ae95171fc9461c3c4905e41739b"></a>XMC_UART_CH_STATUS_FLAG_TRANSMIT_BUFFER_INDICATION&#160;</td><td class="fielddoc">
<p>UART Protocol Status transmit buffer indication flag </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga802a057f335dc7bc1465ae11b19d09afa47f5b38bcab2bc0e1b009cffcca18855"></a>XMC_UART_CH_STATUS_FLAG_RECEIVE_INDICATION&#160;</td><td class="fielddoc">
<p>UART Protocol Status receive indication flag </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga802a057f335dc7bc1465ae11b19d09afaaac652362ebf22f1b23c1e2e4dd52cfa"></a>XMC_UART_CH_STATUS_FLAG_ALTERNATIVE_RECEIVE_INDICATION&#160;</td><td class="fielddoc">
<p>UART Protocol Status alternative receive indication flag </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga802a057f335dc7bc1465ae11b19d09afa5e66e98130f3a6f072c57295a1a779f7"></a>XMC_UART_CH_STATUS_FLAG_BAUD_RATE_GENERATOR_INDICATION&#160;</td><td class="fielddoc">
<p>UART Protocol Status baudrate generator indication flag </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gadd220ce3211af8111e0af876a0619788"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t.html#gadd220ce3211af8111e0af876a0619788">XMC_UART_CH_STATUS_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UART driver status </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggadd220ce3211af8111e0af876a0619788a1d4d4ea36dc6c0ceb6599efed42f0559"></a>XMC_UART_CH_STATUS_OK&#160;</td><td class="fielddoc">
<p>UART driver status : OK </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggadd220ce3211af8111e0af876a0619788a146ec14a2e6f316f449c332a863289b0"></a>XMC_UART_CH_STATUS_ERROR&#160;</td><td class="fielddoc">
<p>UART driver status : ERROR </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggadd220ce3211af8111e0af876a0619788a410817c31e098fd03c04f4d5ecb76ef1"></a>XMC_UART_CH_STATUS_BUSY&#160;</td><td class="fielddoc">
<p>UART driver status : BUSY </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga6840ff2cfd59836fea619b9c1cfbbac5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_ClearStatusFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
    <tr><td class="paramname">flag</td><td>UART events to be cleared. <br />
 <b>Range:</b> Use <a class="el" href="group___u_a_r_t.html#ga802a057f335dc7bc1465ae11b19d09af">XMC_UART_CH_STATUS_FLAG_t</a> enumerations for event bitmasks. <a class="el" href="group___u_a_r_t.html#gga802a057f335dc7bc1465ae11b19d09afa8838558f1c949dfdfa117908e21d7058">XMC_UART_CH_STATUS_FLAG_TRANSMISSION_IDLE</a>, <a class="el" href="group___u_a_r_t.html#gga802a057f335dc7bc1465ae11b19d09afa02d60fc761d9eee4c4d1c525f2429a5c">XMC_UART_CH_STATUS_FLAG_RECEPTION_IDLE</a>, <a class="el" href="group___u_a_r_t.html#gga802a057f335dc7bc1465ae11b19d09afaeaf9ee65696e36e06e012e0e3e5b5855">XMC_UART_CH_STATUS_FLAG_SYNCHRONIZATION_BREAK_DETECTED</a> etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Clears the status of UART channel events.<br />
<br />
Multiple events can be combined using the bitwise OR operation and configured in one function call. XMC_UART_CH_STATUS_FLAG_t enumerates multiple event bitmasks. These enumerations can be used as input to the API. Events are cleared by setting the bitmask to the PSCR register.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga87743034df2fe747615ce39a6b870a0c">XMC_UART_CH_DisableEvent()</a>, <a class="el" href="group___u_a_r_t.html#ga5578bae41ea73c00dd704924c63f7370">XMC_UART_CH_GetStatusFlag()</a><br />
<br />
<br />
</dd></dl>

<p>References <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a725284f672801993f9ab5dcf3ef1e5c7">XMC_USIC_CH_t::PSCR</a>.</p>

</div>
</div>
<a class="anchor" id="ga87743034df2fe747615ce39a6b870a0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_DisableEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
    <tr><td class="paramname">event</td><td>Bitmask of events to disable. Use the type <a class="el" href="group___u_a_r_t.html#ga122d0cf7042ea6cb81ccdb50df5f62b6">XMC_UART_CH_EVENT_t</a> for naming events.<br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#gga122d0cf7042ea6cb81ccdb50df5f62b6addd2af8f6f565002a1b4ea856b7bbcee">XMC_UART_CH_EVENT_RECEIVE_START</a>, <a class="el" href="group___u_a_r_t.html#gga122d0cf7042ea6cb81ccdb50df5f62b6a6e76badf4b36a6fa694cd7c4c0d873b9">XMC_UART_CH_EVENT_DATA_LOST</a>, <a class="el" href="group___u_a_r_t.html#gga122d0cf7042ea6cb81ccdb50df5f62b6af28054e5044087c68da450015df6771f">XMC_UART_CH_EVENT_TRANSMIT_SHIFT</a>, <a class="el" href="group___u_a_r_t.html#gga122d0cf7042ea6cb81ccdb50df5f62b6a26b35a7f887b79474fa97856749f182b">XMC_UART_CH_EVENT_TRANSMIT_BUFFER</a>, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables the interrupt events by clearing the bits in CCR register.<br />
<br />
Multiple events can be combined using the bitwise OR operation and configured in one function call. XMC_UART_CH_EVENT_FLAG_t enumerates multiple event bitmasks. These enumerations can be used as input to the API.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga6840ff2cfd59836fea619b9c1cfbbac5">XMC_UART_CH_ClearStatusFlag()</a>, <a class="el" href="group___u_a_r_t.html#gaf511dd60e7f23bc40bad0207ff9bd266">XMC_UART_CH_EnableEvent()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gaef225ec3a0bc7db11ddf0b4f260a905c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_DisableInputDigitalFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
    <tr><td class="paramname">input</td><td>UART channel input stage of type <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a>. <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#gga7358da2d90633473ae9de4636ddb3a46acaf414b76fa9b98df96b90edbf3edc3d">XMC_UART_CH_INPUT_RXD</a> (for DX0), XMC_UART_CH_INPUT_RXD1 (for DX3), XMC_UART_CH_INPUT_RXD2 (for DX5). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables the digital filter for UART input stage.<br />
<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#gaeec73a4f59460bbe97aad10c1d925c73">XMC_UART_CH_EnableInputDigitalFilter()</a><br />
<br />
<br />
</dd></dl>

<p>References <a class="el" href="group___u_s_i_c.html#ga1db3c5e7fe198de01001e0ee43dd4fef">XMC_USIC_CH_DisableInputDigitalFilter()</a>.</p>

</div>
</div>
<a class="anchor" id="gafd566960d84740ec0c0713197839b071"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_DisableInputInversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
    <tr><td class="paramname">input</td><td>UART channel input stage of type <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a>. <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#gga7358da2d90633473ae9de4636ddb3a46acaf414b76fa9b98df96b90edbf3edc3d">XMC_UART_CH_INPUT_RXD</a> (for DX0), XMC_UART_CH_INPUT_RXD1 (for DX3), XMC_UART_CH_INPUT_RXD2 (for DX5). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables input inversion for UART input data signal.<br />
<br />
Resets the input data polarity for the UART input data signal. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga95acf430dde4497f55838626ec22b808">XMC_UART_CH_EnableInputInversion()</a><br />
<br />
<br />
</dd></dl>

<p>References <a class="el" href="group___u_s_i_c.html#gaa018c766c173f43dbdba8c821a90a645">XMC_USIC_CH_DisableInputInversion()</a>.</p>

</div>
</div>
<a class="anchor" id="ga655549975b9c7dce3fb9f28c89b5685f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_DisableInputSync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
    <tr><td class="paramname">input</td><td>UART channel input stage of type <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a>. <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#gga7358da2d90633473ae9de4636ddb3a46acaf414b76fa9b98df96b90edbf3edc3d">XMC_UART_CH_INPUT_RXD</a> (for DX0), XMC_UART_CH_INPUT_RXD1 (for DX3), XMC_UART_CH_INPUT_RXD2 (for DX5). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables synchronous input for the UART input stage.<br />
<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga52aa3807f291f58be66b4d946aec7d47">XMC_UART_CH_EnableInputSync()</a>, <a class="el" href="group___u_a_r_t.html#gaeec73a4f59460bbe97aad10c1d925c73">XMC_UART_CH_EnableInputDigitalFilter()</a><br />
<br />
<br />
</dd></dl>

<p>References <a class="el" href="group___u_s_i_c.html#gaad85027beef2c0cf3dd897e889acf939">XMC_USIC_CH_DisableInputSync()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf511dd60e7f23bc40bad0207ff9bd266"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_EnableEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
    <tr><td class="paramname">event</td><td>Event bitmasks to enable. Use the type <a class="el" href="group___u_a_r_t.html#ga122d0cf7042ea6cb81ccdb50df5f62b6">XMC_UART_CH_EVENT_t</a> for naming events. <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#gga122d0cf7042ea6cb81ccdb50df5f62b6addd2af8f6f565002a1b4ea856b7bbcee">XMC_UART_CH_EVENT_RECEIVE_START</a>, <a class="el" href="group___u_a_r_t.html#gga122d0cf7042ea6cb81ccdb50df5f62b6a6e76badf4b36a6fa694cd7c4c0d873b9">XMC_UART_CH_EVENT_DATA_LOST</a>, <a class="el" href="group___u_a_r_t.html#gga122d0cf7042ea6cb81ccdb50df5f62b6af28054e5044087c68da450015df6771f">XMC_UART_CH_EVENT_TRANSMIT_SHIFT</a>, <a class="el" href="group___u_a_r_t.html#gga122d0cf7042ea6cb81ccdb50df5f62b6a26b35a7f887b79474fa97856749f182b">XMC_UART_CH_EVENT_TRANSMIT_BUFFER</a>, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables interrupt events for UART communication.<br />
<br />
Multiple events can be combined using the bitwise OR operation and configured in one function call. <a class="el" href="group___u_a_r_t.html#ga122d0cf7042ea6cb81ccdb50df5f62b6">XMC_UART_CH_EVENT_t</a> enumerates multiple event bitmasks. These enumerations can be used as input to the API. Events are configured by setting bits in the CCR register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga87743034df2fe747615ce39a6b870a0c">XMC_UART_CH_DisableEvent()</a>, <a class="el" href="group___u_a_r_t.html#gaa013e09337b1c9c05b41eac29b2518ea">XMC_UART_CH_SetInterruptNodePointer()</a>, <a class="el" href="group___u_a_r_t.html#ga5578bae41ea73c00dd704924c63f7370">XMC_UART_CH_GetStatusFlag()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="gaeec73a4f59460bbe97aad10c1d925c73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_EnableInputDigitalFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
    <tr><td class="paramname">input</td><td>UART channel input stage of type <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a>. <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#gga7358da2d90633473ae9de4636ddb3a46acaf414b76fa9b98df96b90edbf3edc3d">XMC_UART_CH_INPUT_RXD</a> (for DX0), XMC_UART_CH_INPUT_RXD1 (for DX3), XMC_UART_CH_INPUT_RXD2 (for DX5). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables the digital filter for UART input stage.<br />
<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#gaef225ec3a0bc7db11ddf0b4f260a905c">XMC_UART_CH_DisableInputDigitalFilter()</a><br />
<br />
<br />
</dd></dl>

<p>References <a class="el" href="group___u_s_i_c.html#ga6a776750022b67a7d4075fb06eac39dc">XMC_USIC_CH_EnableInputDigitalFilter()</a>.</p>

</div>
</div>
<a class="anchor" id="ga95acf430dde4497f55838626ec22b808"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_EnableInputInversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
    <tr><td class="paramname">input</td><td>UART channel input stage of type <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a>. <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#gga7358da2d90633473ae9de4636ddb3a46acaf414b76fa9b98df96b90edbf3edc3d">XMC_UART_CH_INPUT_RXD</a> (for DX0), XMC_UART_CH_INPUT_RXD1 (for DX3), XMC_UART_CH_INPUT_RXD2 (for DX5). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables input inversion for UART input data signal.<br />
<br />
Polarity of the input source can be changed to provide inverted data input. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#gafd566960d84740ec0c0713197839b071">XMC_UART_CH_DisableInputInversion()</a><br />
<br />
<br />
</dd></dl>

<p>References <a class="el" href="group___u_s_i_c.html#gae13b2003ea4d8703a9990d1e90048dc3">XMC_USIC_CH_EnableInputInversion()</a>.</p>

</div>
</div>
<a class="anchor" id="ga52aa3807f291f58be66b4d946aec7d47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_EnableInputSync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
    <tr><td class="paramname">input</td><td>UART channel input stage of type <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a>. <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#gga7358da2d90633473ae9de4636ddb3a46acaf414b76fa9b98df96b90edbf3edc3d">XMC_UART_CH_INPUT_RXD</a> (for DX0), XMC_UART_CH_INPUT_RXD1 (for DX3), XMC_UART_CH_INPUT_RXD2 (for DX5). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables synchronous input for the UART input stage.<br />
<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga655549975b9c7dce3fb9f28c89b5685f">XMC_UART_CH_DisableInputSync()</a>, <a class="el" href="group___u_a_r_t.html#gaeec73a4f59460bbe97aad10c1d925c73">XMC_UART_CH_EnableInputDigitalFilter()</a><br />
<br />
<br />
</dd></dl>

<p>References <a class="el" href="group___u_s_i_c.html#ga1a5edb9ab8796da1f86be687fab65f32">XMC_USIC_CH_EnableInputSync()</a>.</p>

</div>
</div>
<a class="anchor" id="ga578c15fc0df2e8ea7a265c92c0a26536"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t XMC_UART_CH_GetReceivedData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint16_t Received data over UART communication channel. </dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides one word of data received over UART communication channel.<br />
<br />
Based on the channel configuration, data is either read from the receive FIFO or RBUF register. Before returning the value, there is no check for data validity. User should check the appropriate data receive flags(standard receive/alternative receive/FIFO standard receive/FIFO alternative receive) before executing the API. Reading from an empty receive FIFO can generate a receive error event.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga5578bae41ea73c00dd704924c63f7370">XMC_UART_CH_GetStatusFlag()</a>, <a class="el" href="group___u_a_r_t.html#ga3a9b41f5d74a0dde43d9b19166ffa7c6">XMC_UART_CH_Transmit()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga5578bae41ea73c00dd704924c63f7370"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_UART_CH_GetStatusFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of UART channel events. <br />
 <b>Range:</b> Use <a class="el" href="group___u_a_r_t.html#ga802a057f335dc7bc1465ae11b19d09af">XMC_UART_CH_STATUS_FLAG_t</a> enumerations for event bitmasks. <a class="el" href="group___u_a_r_t.html#gga802a057f335dc7bc1465ae11b19d09afa8838558f1c949dfdfa117908e21d7058">XMC_UART_CH_STATUS_FLAG_TRANSMISSION_IDLE</a>, <a class="el" href="group___u_a_r_t.html#gga802a057f335dc7bc1465ae11b19d09afa02d60fc761d9eee4c4d1c525f2429a5c">XMC_UART_CH_STATUS_FLAG_RECEPTION_IDLE</a>, <a class="el" href="group___u_a_r_t.html#gga802a057f335dc7bc1465ae11b19d09afaeaf9ee65696e36e06e012e0e3e5b5855">XMC_UART_CH_STATUS_FLAG_SYNCHRONIZATION_BREAK_DETECTED</a> etc.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the status of UART channel events.<br />
<br />
Status provided by the API represents the status of multiple events at their bit positions. The bitmasks can be obtained using the enumeration XMC_UART_CH_STATUS_FLAG_t. Event status is obtained by reading the register PSR_ASCMode.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#gaf511dd60e7f23bc40bad0207ff9bd266">XMC_UART_CH_EnableEvent()</a>, <a class="el" href="group___u_a_r_t.html#ga6840ff2cfd59836fea619b9c1cfbbac5">XMC_UART_CH_ClearStatusFlag()</a><br />
<br />
<br />
</dd></dl>

<p>References <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a2439bcdd2050b881f24f78626aec9c67">XMC_USIC_CH_t::PSR_ASCMode</a>.</p>

</div>
</div>
<a class="anchor" id="ga719ad21f9ccaf9585dd0b473b4daef7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___u_a_r_t___c_h___c_o_n_f_i_g__t.html">XMC_UART_CH_CONFIG_t</a> *const&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
    <tr><td class="paramname">config</td><td>Constant pointer to UART configuration structure of type <a class="el" href="struct_x_m_c___u_a_r_t___c_h___c_o_n_f_i_g__t.html">XMC_UART_CH_CONFIG_t</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XMC_UART_CH_STATUS_t Status of initializing the USIC channel for UART protocol.<br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ggadd220ce3211af8111e0af876a0619788a1d4d4ea36dc6c0ceb6599efed42f0559">XMC_UART_CH_STATUS_OK</a> if initialization is successful.<br />
 <a class="el" href="group___u_a_r_t.html#ggadd220ce3211af8111e0af876a0619788a146ec14a2e6f316f449c332a863289b0">XMC_UART_CH_STATUS_ERROR</a> if configuration of baudrate failed.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Initializes the USIC channel for UART protocol.<br />
<br />
During the initialization, USIC channel is enabled, baudrate is configured with the defined oversampling value in the intialization structure. If the oversampling value is set to 0 in the structure, the default oversampling of 16 is considered. Sampling point for each symbol is configured at the half of sampling period. Symbol value is decided by the majority decision among 3 samples. Word length is configured with the number of data bits. If the value of <em>frame_length</em> is 0, then USIC channel frame length is set to the same value as word length. If <em>frame_length</em> is greater than 0, it is set as the USIC channel frame length. Parity mode is set to the value configured for <em>parity_mode</em>. The USIC channel should be set to UART mode by calling the <a class="el" href="group___u_a_r_t.html#ga786385b5527c6c6405d7e9e3626e0587">XMC_UART_CH_Start()</a> API after the initialization.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga786385b5527c6c6405d7e9e3626e0587">XMC_UART_CH_Start()</a>, <a class="el" href="group___u_a_r_t.html#ga083e4d7b2be613994d61ebc9841f7ebd">XMC_UART_CH_Stop()</a>, <a class="el" href="group___u_a_r_t.html#ga3a9b41f5d74a0dde43d9b19166ffa7c6">XMC_UART_CH_Transmit()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga0f757d62a86fc8944cf7188137490b62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t.html#gadd220ce3211af8111e0af876a0619788">XMC_UART_CH_STATUS_t</a> XMC_UART_CH_SetBaudrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>oversampling</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
    <tr><td class="paramname">rate</td><td>Desired baudrate. <br />
 <b>Range:</b> minimum value = 100, maximum value depends on the peripheral clock frequency<br />
 and <em>oversampling</em>. Maximum baudrate can be derived using the formula: (fperiph * 1023)/(1024 * oversampling) </td></tr>
    <tr><td class="paramname">oversampling</td><td>Required oversampling. The value indicates the number of time quanta for one symbol of data.<br />
 This can be related to the number of samples for each logic state of the data signal.<br />
 <b>Range:</b> 4 to 32. Value should be chosen based on the protocol used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XMC_UART_CH_STATUS_t Status indicating the baudrate configuration.<br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ggaf0ce1333656386f14f018b400beb9e39a7f5eeda6309c7b3a3e8f08380ed47e3c">XMC_USIC_CH_STATUS_OK</a> if baudrate is successfully configured, <a class="el" href="group___u_s_i_c.html#ggaf0ce1333656386f14f018b400beb9e39af9cf48d10eb977902d20eeaed491bcf0">XMC_USIC_CH_STATUS_ERROR</a> if desired baudrate or oversampling is invalid.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets the bus speed in bits per second.<br />
<br />
Derives the values of <em>STEP</em> and PDIV to arrive at the optimum realistic speed possible. <em>oversampling</em> is the number of samples to be taken for each symbol of UART protocol. Default <em>oversampling</em> of 16 is considered if the input <em>oversampling</em> is less than 4. It is recommended to keep a minimum oversampling of 4 for UART.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga719ad21f9ccaf9585dd0b473b4daef7e">XMC_UART_CH_Init()</a>, <a class="el" href="group___u_a_r_t.html#ga083e4d7b2be613994d61ebc9841f7ebd">XMC_UART_CH_Stop()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9f6eb4a3265729b4b7cf7e3d198130d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_SetFrameLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>frame_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
    <tr><td class="paramname">frame_length</td><td>Number of data bits in each UART frame. <br />
 <b>Range:</b> minimum= 1, maximum= 64. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets the number of data bits for UART communication.<br />
<br />
The frame length is configured by setting the input value to <em>SCTR</em> register. The value of <em>frame_length</em> will be decremented by 1, before setting it to the register. Frame length should not be set to 64 for UART communication.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga6b12b3bdebda3d3a6c28d5c79a12735b">XMC_UART_CH_SetWordLength()</a> <br />
<br />
<br />
</dd></dl>

<p>References <a class="el" href="group___u_s_i_c.html#ga23964f6d982b35388f3a7c82f5634e0f">XMC_USIC_CH_SetFrameLength()</a>.</p>

</div>
</div>
<a class="anchor" id="gad6c3cf150769886938ceb811557db243"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_SetInputSamplingFreq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t.html#ga2deb0d11792f241e1e5c02e6a4063998">XMC_UART_CH_INPUT_SAMPLING_FREQ_t</a>&#160;</td>
          <td class="paramname"><em>sampling_freq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
    <tr><td class="paramname">input</td><td>UART channel input stage of type <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a>. <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#gga7358da2d90633473ae9de4636ddb3a46acaf414b76fa9b98df96b90edbf3edc3d">XMC_UART_CH_INPUT_RXD</a> (for DX0), XMC_UART_CH_INPUT_RXD1 (for DX3), XMC_UART_CH_INPUT_RXD2 (for DX5). </td></tr>
    <tr><td class="paramname">sampling_freq</td><td>Input sampling frequency. <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#gga2deb0d11792f241e1e5c02e6a4063998a916e6151ac686996fbef2b0c059d0527">XMC_UART_CH_INPUT_SAMPLING_FREQ_FPERIPH</a>, <a class="el" href="group___u_a_r_t.html#gga2deb0d11792f241e1e5c02e6a4063998ac1ae8f6ca1096c61ca0619dae0a18b92">XMC_UART_CH_INPUT_SAMPLING_FREQ_FRACTIONAL_DIVIDER</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets the sampling frequency for the UART input stage.<br />
<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga52aa3807f291f58be66b4d946aec7d47">XMC_UART_CH_EnableInputSync()</a>, <a class="el" href="group___u_a_r_t.html#gaeec73a4f59460bbe97aad10c1d925c73">XMC_UART_CH_EnableInputDigitalFilter()</a><br />
<br />
<br />
</dd></dl>

<p>References <a class="el" href="group___u_s_i_c.html#ga77ed1338593c1492f35321494aedfa48">XMC_USIC_CH_SetInputSamplingFreq()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1f6aded563def78ca10e8638889bd898"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_SetInputSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
    <tr><td class="paramname">input</td><td>UART channel input stage of type <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a>. <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#gga7358da2d90633473ae9de4636ddb3a46acaf414b76fa9b98df96b90edbf3edc3d">XMC_UART_CH_INPUT_RXD</a> (for DX0), XMC_UART_CH_INPUT_RXD1 (for DX3), XMC_UART_CH_INPUT_RXD2 (for DX5). </td></tr>
    <tr><td class="paramname">source</td><td>Input source select for the input stage. The table provided below maps the decimal value with the input source. <table class="doxtable">
<tr>
<td>0</td><td>DXnA</td></tr>
<tr>
<td>1</td><td>DXnB</td></tr>
<tr>
<td>2</td><td>DXnC</td></tr>
<tr>
<td>3</td><td>DXnD </td></tr>
<tr>
<td>4</td><td>DXnE</td></tr>
<tr>
<td>5</td><td>DXnF</td></tr>
<tr>
<td>6</td><td>DXnG</td></tr>
<tr>
<td>7</td><td>Always 1 </td></tr>
</table>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets input soource for the UART communication.<br />
<br />
It is used for configuring the input stage for data reception. Selects the input data signal source among DXnA, DXnB.. DXnG for the input stage. The API can be used for the input stages DX0, DX3 and DX5.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga95acf430dde4497f55838626ec22b808">XMC_UART_CH_EnableInputInversion()</a> <br />
<br />
<br />
</dd></dl>

<p>References <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a2572b0472db52f72c68f523f48c35620">XMC_USIC_CH_t::DXCR</a>, and <a class="el" href="group___u_s_i_c.html#ga7986fcfe3fd6bf9982e43b1eaabb02c2">XMC_USIC_CH_SetInputSource()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa013e09337b1c9c05b41eac29b2518ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_SetInterruptNodePointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>service_request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
    <tr><td class="paramname">service_request</td><td>Service request number for generating protocol interrupts.<br />
 <b>Range:</b> 0 to 5. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets the interrupt node for UART channel protocol events.<br />
<br />
For all the protocol events enlisted in the enumeration XMC_UART_CH_EVENT_t, one common interrupt gets generated. The service request connects the interrupt node to the UART protocol events. Note: NVIC node should be separately enabled to generate the interrupt.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#gaf511dd60e7f23bc40bad0207ff9bd266">XMC_UART_CH_EnableEvent()</a> <br />
<br />
<br />
</dd></dl>

<p>References <a class="el" href="group___u_s_i_c.html#gga074b5b1abff43f98316c7a5b69523e62a3b99d0d6e93882ea791e8952cc993a7b">XMC_USIC_CH_INTERRUPT_NODE_POINTER_PROTOCOL</a>, and <a class="el" href="group___u_s_i_c.html#ga52f9fc18049dbc906b127e1f3662b4b3">XMC_USIC_CH_SetInterruptNodePointer()</a>.</p>

</div>
</div>
<a class="anchor" id="ga12f39dca3684261d4e35aeb7af9c82a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_SetPulseLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>pulse_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
    <tr><td class="paramname">pulse_length</td><td>Length of the zero pulse in number of time quanta. <br />
 <b>Range:</b> 0 to 7. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets the length of zero pulse in number of time quanta. Value 0 indicates one time quanta.<br />
<br />
Maximum possible is 8 time quanta with the value configured as 7.<br />
The value is set to PCR_ASCMode register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga95acf430dde4497f55838626ec22b808">XMC_UART_CH_EnableInputInversion()</a>, <a class="el" href="group___u_a_r_t.html#gacabdceef217f1be937dc494ce9140765">XMC_UART_CH_SetSamplePoint()</a> <br />
<br />
<br />
</dd></dl>

<p>References <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#ad8388a3741a38746b8258c4276c816e7">XMC_USIC_CH_t::PCR_ASCMode</a>.</p>

</div>
</div>
<a class="anchor" id="gacabdceef217f1be937dc494ce9140765"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_SetSamplePoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>sample_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
    <tr><td class="paramname">sample_point</td><td>Sample point among the number of samples. <br />
 <b>Range:</b> minimum= 0, maximum= <em>oversampling</em> (DCTQ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets the sample point among the multiple samples for each UART symbol.<br />
<br />
The sample point is the one sample among number of samples set as oversampling. The value should be less than the oversampling value. <a class="el" href="group___u_a_r_t.html#ga719ad21f9ccaf9585dd0b473b4daef7e">XMC_UART_CH_Init()</a> sets the sample point to the sample at the centre. For example if the oversampling is 16, then the sample point is set to 9. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga95acf430dde4497f55838626ec22b808">XMC_UART_CH_EnableInputInversion()</a>, <a class="el" href="group___u_a_r_t.html#gacabdceef217f1be937dc494ce9140765">XMC_UART_CH_SetSamplePoint()</a> <br />
<br />
<br />
</dd></dl>

<p>References <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#ad8388a3741a38746b8258c4276c816e7">XMC_USIC_CH_t::PCR_ASCMode</a>.</p>

</div>
</div>
<a class="anchor" id="ga6b12b3bdebda3d3a6c28d5c79a12735b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_SetWordLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>word_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
    <tr><td class="paramname">word_length</td><td>Data word length. <br />
 <b>Range:</b> minimum= 1, maximum= 16. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets the data word length in number of bits.<br />
<br />
Word length can range from 1 to 16. It indicates the number of data bits in a data word. The value of <em>word_length</em> will be decremented by 1 before setting the value to <em>SCTR</em> register. If the UART data bits is more than 16, then the frame length should be set to the actual number of bits and word length should be configured with the number of bits expected in each transaction. For example, if number of data bits for UART communication is 20 bits, then the frame length should be set as 20. Word length can be set based on the transmit and receive handling. If data is stored as 8bit array, then the word length can be set to 8. In this case, a full message of UART data should be transmitted/ received as 3 data words.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga9f6eb4a3265729b4b7cf7e3d198130d6">XMC_UART_CH_SetFrameLength()</a> <br />
<br />
<br />
</dd></dl>

<p>References <a class="el" href="group___u_s_i_c.html#gabb9d02b8388a03cd28190c976cdb8b78">XMC_USIC_CH_SetWordLength()</a>.</p>

</div>
</div>
<a class="anchor" id="ga786385b5527c6c6405d7e9e3626e0587"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_Start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets the USIC channel operation mode to UART mode.<br />
<br />
CCR register bitfield <em>Mode</em> is set to 2(UART mode). This API should be called after configuring the USIC channel. Transmission and reception can happen only when the UART mode is set. This is an inline function.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga083e4d7b2be613994d61ebc9841f7ebd">XMC_UART_CH_Stop()</a>, <a class="el" href="group___u_a_r_t.html#ga3a9b41f5d74a0dde43d9b19166ffa7c6">XMC_UART_CH_Transmit()</a><br />
<br />
<br />
</dd></dl>

<p>References <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html#a5e1322e27c40bf91d172f9673f205c97">XMC_USIC_CH_t::CCR</a>, and <a class="el" href="group___u_s_i_c.html#ggac052842418ff3dda00900219ebda5de7a0130416b257e28bf39a388658dd61469">XMC_USIC_CH_OPERATING_MODE_UART</a>.</p>

</div>
</div>
<a class="anchor" id="ga083e4d7b2be613994d61ebc9841f7ebd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t.html#gadd220ce3211af8111e0af876a0619788">XMC_UART_CH_STATUS_t</a> XMC_UART_CH_Stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XMC_UART_CH_STATUS_t Status to indicate if the communication channel is stopped successfully.<br />
 <a class="el" href="group___u_a_r_t.html#ggadd220ce3211af8111e0af876a0619788a1d4d4ea36dc6c0ceb6599efed42f0559">XMC_UART_CH_STATUS_OK</a> if the communication channel is stopped. <a class="el" href="group___u_a_r_t.html#ggadd220ce3211af8111e0af876a0619788a410817c31e098fd03c04f4d5ecb76ef1">XMC_UART_CH_STATUS_BUSY</a> if the communication channel is busy.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Stops the UART communication.<br />
<br />
CCR register bitfield <em>Mode</em> is reset. This disables the communication. Before starting the communication again, the channel has to be reconfigured.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga719ad21f9ccaf9585dd0b473b4daef7e">XMC_UART_CH_Init()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga3a9b41f5d74a0dde43d9b19166ffa7c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_Transmit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a>, <a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a> to XMC_USIC2_CH1 based on device support. </td></tr>
    <tr><td class="paramname">data</td><td>Data to be transmitted. <br />
 <b>Range:</b> 16 bit unsigned data within the range 0 to 65535. Actual size of data transmitted depends on the configured number of bits for the UART protocol in the register SCTR. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Transmits data over serial communication channel using UART protocol.<br />
<br />
Based on the channel configuration, data is either put to the transmit FIFO or to TBUF register. Before putting data to TBUF, the API waits for TBUF to finish shifting its contents to shift register. So user can continuously execute the API without checking for TBUF busy status. Based on the number of data bits configured, the lower significant bits will be extracted for transmission.</dd></dl>
<p>Note: When FIFO is not configured, the API waits for the TBUF to be available. This makes the execution a blocking call.</p>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga578c15fc0df2e8ea7a265c92c0a26536">XMC_UART_CH_GetReceivedData()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="ga4aeec10dcd8e8115ac5d7ffee48f2c35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XMC_DRIVER_VERSION_t XMC_UART_GetDriverVersion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Data structure (::XMC_DRIVER_VERSION_t) storing driver version</dd></dl>
<dl class="section user"><dt>Description: </dt><dd>Return the version of the low level driver <br />
</dd></dl>
<dl class="section user"><dt></dt><dd>The function can be used to check application software compatibility with a specific version of the low level driver. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Feb 27 2015 10:51:56 for XMC Peripheral Library for XMC1000 Family by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
